"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Camunda Platform REST API
 * OpenApi Spec for Camunda Platform REST API.
 *
 * The version of the OpenAPI document: 7.13.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProcessDefinitionApiFp = exports.ProcessDefinitionApiAxiosParamCreator = exports.MetricsApi = exports.MetricsApiFactory = exports.MetricsApiFp = exports.MetricsApiAxiosParamCreator = exports.MessageApi = exports.MessageApiFactory = exports.MessageApiFp = exports.MessageApiAxiosParamCreator = exports.ExternalTaskApi = exports.ExternalTaskApiFactory = exports.ExternalTaskApiFp = exports.ExternalTaskApiAxiosParamCreator = exports.EventSubscriptionApi = exports.EventSubscriptionApiFactory = exports.EventSubscriptionApiFp = exports.EventSubscriptionApiAxiosParamCreator = exports.EngineApi = exports.EngineApiFactory = exports.EngineApiFp = exports.EngineApiAxiosParamCreator = exports.DeploymentApi = exports.DeploymentApiFactory = exports.DeploymentApiFp = exports.DeploymentApiAxiosParamCreator = exports.ConditionApi = exports.ConditionApiFactory = exports.ConditionApiFp = exports.ConditionApiAxiosParamCreator = exports.VariableQueryParameterDtoOperatorEnum = exports.TaskQueryDtoSortingSortOrderEnum = exports.TaskQueryDtoSortingSortByEnum = exports.TaskQueryDtoDelegationStateEnum = exports.TaskDtoDelegationStateEnum = exports.SchemaLogQueryDtoSortingSortOrderEnum = exports.SchemaLogQueryDtoSortingSortByEnum = exports.RestartProcessInstanceModificationInstructionDtoTypeEnum = exports.ProcessInstanceQueryDtoSortingSortOrderEnum = exports.ProcessInstanceQueryDtoSortingSortByEnum = exports.ProcessInstanceModificationInstructionDtoTypeEnum = exports.MessageCorrelationResultWithVariableDtoResultTypeEnum = exports.HistoricProcessInstanceQueryDtoSortingSortOrderEnum = exports.HistoricProcessInstanceQueryDtoSortingSortByEnum = exports.HistoricProcessInstanceQueryDtoIncidentStatusEnum = exports.ExternalTaskQueryDtoSortingSortOrderEnum = exports.ExternalTaskQueryDtoSortingSortByEnum = exports.EventSubscriptionQueryDtoSortingSortOrderEnum = exports.EventSubscriptionQueryDtoSortingSortByEnum = exports.EventSubscriptionQueryDtoEventTypeEnum = void 0;
exports.VersionApi = exports.VersionApiFactory = exports.VersionApiFp = exports.VersionApiAxiosParamCreator = exports.TaskVariableApi = exports.TaskVariableApiFactory = exports.TaskVariableApiFp = exports.TaskVariableApiAxiosParamCreator = exports.TaskLocalVariableApi = exports.TaskLocalVariableApiFactory = exports.TaskLocalVariableApiFp = exports.TaskLocalVariableApiAxiosParamCreator = exports.TaskIdentityLinkApi = exports.TaskIdentityLinkApiFactory = exports.TaskIdentityLinkApiFp = exports.TaskIdentityLinkApiAxiosParamCreator = exports.TaskCommentApi = exports.TaskCommentApiFactory = exports.TaskCommentApiFp = exports.TaskCommentApiAxiosParamCreator = exports.TaskAttachmentApi = exports.TaskAttachmentApiFactory = exports.TaskAttachmentApiFp = exports.TaskAttachmentApiAxiosParamCreator = exports.TaskApi = exports.TaskApiFactory = exports.TaskApiFp = exports.TaskApiAxiosParamCreator = exports.SignalApi = exports.SignalApiFactory = exports.SignalApiFp = exports.SignalApiAxiosParamCreator = exports.SchemaLogApi = exports.SchemaLogApiFactory = exports.SchemaLogApiFp = exports.SchemaLogApiAxiosParamCreator = exports.ProcessInstanceApi = exports.ProcessInstanceApiFactory = exports.ProcessInstanceApiFp = exports.ProcessInstanceApiAxiosParamCreator = exports.ProcessDefinitionApi = exports.ProcessDefinitionApiFactory = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
exports.EventSubscriptionQueryDtoEventTypeEnum = {
    Message: 'message',
    Signal: 'signal',
    Compensate: 'compensate',
    Conditional: 'conditional'
};
exports.EventSubscriptionQueryDtoSortingSortByEnum = {
    Created: 'created',
    TenantId: 'tenantId'
};
exports.EventSubscriptionQueryDtoSortingSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
};
exports.ExternalTaskQueryDtoSortingSortByEnum = {
    Id: 'id',
    LockExpirationTime: 'lockExpirationTime',
    ProcessInstanceId: 'processInstanceId',
    ProcessDefinitionId: 'processDefinitionId',
    ProcessDefinitionKey: 'processDefinitionKey',
    TaskPriority: 'taskPriority',
    TenantId: 'tenantId'
};
exports.ExternalTaskQueryDtoSortingSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
};
exports.HistoricProcessInstanceQueryDtoIncidentStatusEnum = {
    Open: 'open',
    Resolved: 'resolved'
};
exports.HistoricProcessInstanceQueryDtoSortingSortByEnum = {
    InstanceId: 'instanceId',
    DefinitionId: 'definitionId',
    DefinitionKey: 'definitionKey',
    DefinitionName: 'definitionName',
    DefinitionVersion: 'definitionVersion',
    BusinessKey: 'businessKey',
    StartTime: 'startTime',
    EndTime: 'endTime',
    Duration: 'duration',
    TenantId: 'tenantId'
};
exports.HistoricProcessInstanceQueryDtoSortingSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
};
exports.MessageCorrelationResultWithVariableDtoResultTypeEnum = {
    Execution: 'Execution',
    ProcessDefinition: 'ProcessDefinition'
};
exports.ProcessInstanceModificationInstructionDtoTypeEnum = {
    Cancel: 'cancel',
    StartBeforeActivity: 'startBeforeActivity',
    StartAfterActivity: 'startAfterActivity',
    StartTransition: 'startTransition'
};
exports.ProcessInstanceQueryDtoSortingSortByEnum = {
    InstanceId: 'instanceId',
    DefinitionId: 'definitionId',
    DefinitionKey: 'definitionKey',
    BusinessKey: 'businessKey',
    TenantId: 'tenantId'
};
exports.ProcessInstanceQueryDtoSortingSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
};
exports.RestartProcessInstanceModificationInstructionDtoTypeEnum = {
    StartBeforeActivity: 'startBeforeActivity',
    StartAfterActivity: 'startAfterActivity',
    StartTransition: 'startTransition'
};
exports.SchemaLogQueryDtoSortingSortByEnum = {
    Timestamp: 'timestamp'
};
exports.SchemaLogQueryDtoSortingSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
};
exports.TaskDtoDelegationStateEnum = {
    Pending: 'PENDING',
    Resolved: 'RESOLVED'
};
exports.TaskQueryDtoDelegationStateEnum = {
    Pending: 'PENDING',
    Resolved: 'RESOLVED'
};
exports.TaskQueryDtoSortingSortByEnum = {
    InstanceId: 'instanceId',
    CaseInstanceId: 'caseInstanceId',
    DueDate: 'dueDate',
    ExecutionId: 'executionId',
    CaseExecutionId: 'caseExecutionId',
    Assignee: 'assignee',
    Created: 'created',
    Description: 'description',
    Id: 'id',
    Name: 'name',
    NameCaseInsensitive: 'nameCaseInsensitive',
    Priority: 'priority',
    ProcessVariable: 'processVariable',
    ExecutionVariable: 'executionVariable',
    TaskVariable: 'taskVariable',
    CaseExecutionVariable: 'caseExecutionVariable',
    CaseInstanceVariable: 'caseInstanceVariable'
};
exports.TaskQueryDtoSortingSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
};
exports.VariableQueryParameterDtoOperatorEnum = {
    Eq: 'eq',
    Neq: 'neq',
    Gt: 'gt',
    Gteq: 'gteq',
    Lt: 'lt',
    Lteq: 'lteq',
    Like: 'like'
};
/**
 * ConditionApi - axios parameter creator
 * @export
 */
const ConditionApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Triggers evaluation of conditions for conditional start event(s).  Internally this maps to the engines condition evaluation builder method ConditionEvaluationBuilder#evaluateStartConditions().  For more information see the [Conditional Start Events](https://docs.camunda.org/manual/7.13/reference/bpmn20/events/conditional-events/#conditional-start-event) section of the [BPMN 2.0 Implementation Reference](https://docs.camunda.org/manual/7.13/reference/bpmn20/).
         * @param {EvaluationConditionDto} [evaluationConditionDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluateCondition: async (evaluationConditionDto, options = {}) => {
            const localVarPath = `/condition`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(evaluationConditionDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.ConditionApiAxiosParamCreator = ConditionApiAxiosParamCreator;
/**
 * ConditionApi - functional programming interface
 * @export
 */
const ConditionApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ConditionApiAxiosParamCreator)(configuration);
    return {
        /**
         * Triggers evaluation of conditions for conditional start event(s).  Internally this maps to the engines condition evaluation builder method ConditionEvaluationBuilder#evaluateStartConditions().  For more information see the [Conditional Start Events](https://docs.camunda.org/manual/7.13/reference/bpmn20/events/conditional-events/#conditional-start-event) section of the [BPMN 2.0 Implementation Reference](https://docs.camunda.org/manual/7.13/reference/bpmn20/).
         * @param {EvaluationConditionDto} [evaluationConditionDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluateCondition(evaluationConditionDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluateCondition(evaluationConditionDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.ConditionApiFp = ConditionApiFp;
/**
 * ConditionApi - factory interface
 * @export
 */
const ConditionApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ConditionApiFp)(configuration);
    return {
        /**
         * Triggers evaluation of conditions for conditional start event(s).  Internally this maps to the engines condition evaluation builder method ConditionEvaluationBuilder#evaluateStartConditions().  For more information see the [Conditional Start Events](https://docs.camunda.org/manual/7.13/reference/bpmn20/events/conditional-events/#conditional-start-event) section of the [BPMN 2.0 Implementation Reference](https://docs.camunda.org/manual/7.13/reference/bpmn20/).
         * @param {EvaluationConditionDto} [evaluationConditionDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluateCondition(evaluationConditionDto, options) {
            return localVarFp.evaluateCondition(evaluationConditionDto, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ConditionApiFactory = ConditionApiFactory;
/**
 * ConditionApi - object-oriented interface
 * @export
 * @class ConditionApi
 * @extends {BaseAPI}
 */
class ConditionApi extends base_1.BaseAPI {
    /**
     * Triggers evaluation of conditions for conditional start event(s).  Internally this maps to the engines condition evaluation builder method ConditionEvaluationBuilder#evaluateStartConditions().  For more information see the [Conditional Start Events](https://docs.camunda.org/manual/7.13/reference/bpmn20/events/conditional-events/#conditional-start-event) section of the [BPMN 2.0 Implementation Reference](https://docs.camunda.org/manual/7.13/reference/bpmn20/).
     * @param {EvaluationConditionDto} [evaluationConditionDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConditionApi
     */
    evaluateCondition(evaluationConditionDto, options) {
        return (0, exports.ConditionApiFp)(this.configuration).evaluateCondition(evaluationConditionDto, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ConditionApi = ConditionApi;
/**
 * DeploymentApi - axios parameter creator
 * @export
 */
const DeploymentApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates a deployment.  **Security Consideration**  Deployments can contain custom code in form of scripts or EL expressions to customize process behavior. This may be abused for remote execution of arbitrary code.
         * @param {string} [tenantId] The tenant id for the deployment to be created.
         * @param {string} [deploymentSource] The source for the deployment to be created.
         * @param {boolean} [deployChangedOnly] A flag indicating whether the process engine should perform duplicate checking on a per-resource basis. If set to true, only those resources that have actually changed are deployed. Checks are made against resources included previous deployments of the same name and only against the latest versions of those resources. If set to true, the option enable-duplicate-filtering is overridden and set to true.
         * @param {boolean} [enableDuplicateFiltering] A flag indicating whether the process engine should perform duplicate checking for the deployment or not. This allows you to check if a deployment with the same name and the same resouces already exists and if true, not create a new deployment but instead return the existing deployment. The default value is false.
         * @param {string} [deploymentName] The name for the deployment to be created.
         * @param {any} [data] The binary data to create the deployment resource. It is possible to have more than one form part with different form part names for the binary data to create a deployment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeployment: async (tenantId, deploymentSource, deployChangedOnly, enableDuplicateFiltering, deploymentName, data, options = {}) => {
            const localVarPath = `/deployment/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            if (tenantId !== undefined) {
                localVarFormParams.append('tenant-id', tenantId);
            }
            if (deploymentSource !== undefined) {
                localVarFormParams.append('deployment-source', deploymentSource);
            }
            if (deployChangedOnly !== undefined) {
                localVarFormParams.append('deploy-changed-only', deployChangedOnly);
            }
            if (enableDuplicateFiltering !== undefined) {
                localVarFormParams.append('enable-duplicate-filtering', enableDuplicateFiltering);
            }
            if (deploymentName !== undefined) {
                localVarFormParams.append('deployment-name', deploymentName);
            }
            if (data !== undefined) {
                localVarFormParams.append('data', data);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a deployment by id.
         * @param {string} id The id of the deployment to be deleted.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this deployment should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] &#x60;true&#x60;, if all input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeployment: async (id, cascade, skipCustomListeners, skipIoMappings, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteDeployment', 'id', id);
            const localVarPath = `/deployment/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (cascade !== undefined) {
                localVarQueryParameter['cascade'] = cascade;
            }
            if (skipCustomListeners !== undefined) {
                localVarQueryParameter['skipCustomListeners'] = skipCustomListeners;
            }
            if (skipIoMappings !== undefined) {
                localVarQueryParameter['skipIoMappings'] = skipIoMappings;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a deployment by id, according to the `Deployment` interface of the engine.
         * @param {string} id The id of the deployment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployment: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getDeployment', 'id', id);
            const localVarPath = `/deployment/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a deployment resource by resource id for the given deployment.
         * @param {string} id The id of the deployment
         * @param {string} resourceId The id of the deployment resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentResource: async (id, resourceId, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getDeploymentResource', 'id', id);
            // verify required parameter 'resourceId' is not null or undefined
            (0, common_1.assertParamExists)('getDeploymentResource', 'resourceId', resourceId);
            const localVarPath = `/deployment/{id}/resources/{resourceId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"resourceId"}}`, encodeURIComponent(String(resourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the binary content of a deployment resource for the given deployment by id.
         * @param {string} id The id of the deployment.
         * @param {string} resourceId The id of the deployment resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentResourceData: async (id, resourceId, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getDeploymentResourceData', 'id', id);
            // verify required parameter 'resourceId' is not null or undefined
            (0, common_1.assertParamExists)('getDeploymentResourceData', 'resourceId', resourceId);
            const localVarPath = `/deployment/{id}/resources/{resourceId}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"resourceId"}}`, encodeURIComponent(String(resourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all deployment resources of a given deployment.
         * @param {string} id The id of the deployment to retrieve the deployment resources for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentResources: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getDeploymentResources', 'id', id);
            const localVarPath = `/deployment/{id}/resources`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for deployments that fulfill given parameters. Parameters may be the properties of deployments, such as the id or name or a range of the deployment time. The size of the result set can be retrieved by using the [Get Deployment count](https://docs.camunda.org/manual/7.13/reference/rest/deployment/get-query-count/) method.
         * @param {string} [id] Filter by deployment id
         * @param {string} [name] Filter by the deployment name. Exact match.
         * @param {string} [nameLike] Filter by the deployment name that the parameter is a substring of. The parameter can include the wildcard &#x60;%&#x60; to express like-strategy such as: starts with (&#x60;%&#x60;name), ends with (name&#x60;%&#x60;) or contains (&#x60;%&#x60;name&#x60;%&#x60;).
         * @param {string} [source] Filter by the deployment source.
         * @param {boolean} [withoutSource] Filter by the deployment source whereby source is equal to &#x60;null&#x60;.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A deployment must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include deployments which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeDeploymentsWithoutTenantId] Include deployments which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [after] Restricts to all deployments after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [before] Restricts to all deployments before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployments: async (id, name, nameLike, source, withoutSource, tenantIdIn, withoutTenantId, includeDeploymentsWithoutTenantId, after, before, sortBy, sortOrder, firstResult, maxResults, options = {}) => {
            const localVarPath = `/deployment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (nameLike !== undefined) {
                localVarQueryParameter['nameLike'] = nameLike;
            }
            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }
            if (withoutSource !== undefined) {
                localVarQueryParameter['withoutSource'] = withoutSource;
            }
            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }
            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }
            if (includeDeploymentsWithoutTenantId !== undefined) {
                localVarQueryParameter['includeDeploymentsWithoutTenantId'] = includeDeploymentsWithoutTenantId;
            }
            if (after !== undefined) {
                localVarQueryParameter['after'] = (after instanceof Date) ?
                    after.toISOString() :
                    after;
            }
            if (before !== undefined) {
                localVarQueryParameter['before'] = (before instanceof Date) ?
                    before.toISOString() :
                    before;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }
            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }
            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for the number of deployments that fulfill given parameters. Takes the same parameters as the [Get Deployments](https://docs.camunda.org/manual/7.13/reference/rest/deployment/get-query/) method.
         * @param {string} [id] Filter by deployment id
         * @param {string} [name] Filter by the deployment name. Exact match.
         * @param {string} [nameLike] Filter by the deployment name that the parameter is a substring of. The parameter can include the wildcard &#x60;%&#x60; to express like-strategy such as: starts with (&#x60;%&#x60;name), ends with (name&#x60;%&#x60;) or contains (&#x60;%&#x60;name&#x60;%&#x60;).
         * @param {string} [source] Filter by the deployment source.
         * @param {boolean} [withoutSource] Filter by the deployment source whereby source is equal to &#x60;null&#x60;.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A deployment must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include deployments which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeDeploymentsWithoutTenantId] Include deployments which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [after] Restricts to all deployments after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [before] Restricts to all deployments before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentsCount: async (id, name, nameLike, source, withoutSource, tenantIdIn, withoutTenantId, includeDeploymentsWithoutTenantId, after, before, options = {}) => {
            const localVarPath = `/deployment/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (nameLike !== undefined) {
                localVarQueryParameter['nameLike'] = nameLike;
            }
            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }
            if (withoutSource !== undefined) {
                localVarQueryParameter['withoutSource'] = withoutSource;
            }
            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }
            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }
            if (includeDeploymentsWithoutTenantId !== undefined) {
                localVarQueryParameter['includeDeploymentsWithoutTenantId'] = includeDeploymentsWithoutTenantId;
            }
            if (after !== undefined) {
                localVarQueryParameter['after'] = (after instanceof Date) ?
                    after.toISOString() :
                    after;
            }
            if (before !== undefined) {
                localVarQueryParameter['before'] = (before instanceof Date) ?
                    before.toISOString() :
                    before;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Re-deploys an existing deployment.  The deployment resources to re-deploy can be restricted by using the properties `resourceIds` or `resourceNames`. If no deployment resources to re-deploy are passed then all existing resources of the given deployment are re-deployed.  **Warning**: Deployments can contain custom code in form of scripts or EL expressions to customize process behavior. This may be abused for remote execution of arbitrary code. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) in the user guide for details.
         * @param {string} id The id of the deployment to re-deploy.
         * @param {RedeploymentDto} [redeploymentDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeploy: async (id, redeploymentDto, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('redeploy', 'id', id);
            const localVarPath = `/deployment/{id}/redeploy`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(redeploymentDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.DeploymentApiAxiosParamCreator = DeploymentApiAxiosParamCreator;
/**
 * DeploymentApi - functional programming interface
 * @export
 */
const DeploymentApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.DeploymentApiAxiosParamCreator)(configuration);
    return {
        /**
         * Creates a deployment.  **Security Consideration**  Deployments can contain custom code in form of scripts or EL expressions to customize process behavior. This may be abused for remote execution of arbitrary code.
         * @param {string} [tenantId] The tenant id for the deployment to be created.
         * @param {string} [deploymentSource] The source for the deployment to be created.
         * @param {boolean} [deployChangedOnly] A flag indicating whether the process engine should perform duplicate checking on a per-resource basis. If set to true, only those resources that have actually changed are deployed. Checks are made against resources included previous deployments of the same name and only against the latest versions of those resources. If set to true, the option enable-duplicate-filtering is overridden and set to true.
         * @param {boolean} [enableDuplicateFiltering] A flag indicating whether the process engine should perform duplicate checking for the deployment or not. This allows you to check if a deployment with the same name and the same resouces already exists and if true, not create a new deployment but instead return the existing deployment. The default value is false.
         * @param {string} [deploymentName] The name for the deployment to be created.
         * @param {any} [data] The binary data to create the deployment resource. It is possible to have more than one form part with different form part names for the binary data to create a deployment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDeployment(tenantId, deploymentSource, deployChangedOnly, enableDuplicateFiltering, deploymentName, data, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDeployment(tenantId, deploymentSource, deployChangedOnly, enableDuplicateFiltering, deploymentName, data, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Deletes a deployment by id.
         * @param {string} id The id of the deployment to be deleted.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this deployment should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] &#x60;true&#x60;, if all input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDeployment(id, cascade, skipCustomListeners, skipIoMappings, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeployment(id, cascade, skipCustomListeners, skipIoMappings, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves a deployment by id, according to the `Deployment` interface of the engine.
         * @param {string} id The id of the deployment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeployment(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeployment(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves a deployment resource by resource id for the given deployment.
         * @param {string} id The id of the deployment
         * @param {string} resourceId The id of the deployment resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeploymentResource(id, resourceId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeploymentResource(id, resourceId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves the binary content of a deployment resource for the given deployment by id.
         * @param {string} id The id of the deployment.
         * @param {string} resourceId The id of the deployment resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeploymentResourceData(id, resourceId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeploymentResourceData(id, resourceId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves all deployment resources of a given deployment.
         * @param {string} id The id of the deployment to retrieve the deployment resources for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeploymentResources(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeploymentResources(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Queries for deployments that fulfill given parameters. Parameters may be the properties of deployments, such as the id or name or a range of the deployment time. The size of the result set can be retrieved by using the [Get Deployment count](https://docs.camunda.org/manual/7.13/reference/rest/deployment/get-query-count/) method.
         * @param {string} [id] Filter by deployment id
         * @param {string} [name] Filter by the deployment name. Exact match.
         * @param {string} [nameLike] Filter by the deployment name that the parameter is a substring of. The parameter can include the wildcard &#x60;%&#x60; to express like-strategy such as: starts with (&#x60;%&#x60;name), ends with (name&#x60;%&#x60;) or contains (&#x60;%&#x60;name&#x60;%&#x60;).
         * @param {string} [source] Filter by the deployment source.
         * @param {boolean} [withoutSource] Filter by the deployment source whereby source is equal to &#x60;null&#x60;.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A deployment must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include deployments which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeDeploymentsWithoutTenantId] Include deployments which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [after] Restricts to all deployments after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [before] Restricts to all deployments before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeployments(id, name, nameLike, source, withoutSource, tenantIdIn, withoutTenantId, includeDeploymentsWithoutTenantId, after, before, sortBy, sortOrder, firstResult, maxResults, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeployments(id, name, nameLike, source, withoutSource, tenantIdIn, withoutTenantId, includeDeploymentsWithoutTenantId, after, before, sortBy, sortOrder, firstResult, maxResults, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Queries for the number of deployments that fulfill given parameters. Takes the same parameters as the [Get Deployments](https://docs.camunda.org/manual/7.13/reference/rest/deployment/get-query/) method.
         * @param {string} [id] Filter by deployment id
         * @param {string} [name] Filter by the deployment name. Exact match.
         * @param {string} [nameLike] Filter by the deployment name that the parameter is a substring of. The parameter can include the wildcard &#x60;%&#x60; to express like-strategy such as: starts with (&#x60;%&#x60;name), ends with (name&#x60;%&#x60;) or contains (&#x60;%&#x60;name&#x60;%&#x60;).
         * @param {string} [source] Filter by the deployment source.
         * @param {boolean} [withoutSource] Filter by the deployment source whereby source is equal to &#x60;null&#x60;.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A deployment must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include deployments which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeDeploymentsWithoutTenantId] Include deployments which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [after] Restricts to all deployments after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [before] Restricts to all deployments before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeploymentsCount(id, name, nameLike, source, withoutSource, tenantIdIn, withoutTenantId, includeDeploymentsWithoutTenantId, after, before, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeploymentsCount(id, name, nameLike, source, withoutSource, tenantIdIn, withoutTenantId, includeDeploymentsWithoutTenantId, after, before, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Re-deploys an existing deployment.  The deployment resources to re-deploy can be restricted by using the properties `resourceIds` or `resourceNames`. If no deployment resources to re-deploy are passed then all existing resources of the given deployment are re-deployed.  **Warning**: Deployments can contain custom code in form of scripts or EL expressions to customize process behavior. This may be abused for remote execution of arbitrary code. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) in the user guide for details.
         * @param {string} id The id of the deployment to re-deploy.
         * @param {RedeploymentDto} [redeploymentDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redeploy(id, redeploymentDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redeploy(id, redeploymentDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.DeploymentApiFp = DeploymentApiFp;
/**
 * DeploymentApi - factory interface
 * @export
 */
const DeploymentApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.DeploymentApiFp)(configuration);
    return {
        /**
         * Creates a deployment.  **Security Consideration**  Deployments can contain custom code in form of scripts or EL expressions to customize process behavior. This may be abused for remote execution of arbitrary code.
         * @param {string} [tenantId] The tenant id for the deployment to be created.
         * @param {string} [deploymentSource] The source for the deployment to be created.
         * @param {boolean} [deployChangedOnly] A flag indicating whether the process engine should perform duplicate checking on a per-resource basis. If set to true, only those resources that have actually changed are deployed. Checks are made against resources included previous deployments of the same name and only against the latest versions of those resources. If set to true, the option enable-duplicate-filtering is overridden and set to true.
         * @param {boolean} [enableDuplicateFiltering] A flag indicating whether the process engine should perform duplicate checking for the deployment or not. This allows you to check if a deployment with the same name and the same resouces already exists and if true, not create a new deployment but instead return the existing deployment. The default value is false.
         * @param {string} [deploymentName] The name for the deployment to be created.
         * @param {any} [data] The binary data to create the deployment resource. It is possible to have more than one form part with different form part names for the binary data to create a deployment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeployment(tenantId, deploymentSource, deployChangedOnly, enableDuplicateFiltering, deploymentName, data, options) {
            return localVarFp.createDeployment(tenantId, deploymentSource, deployChangedOnly, enableDuplicateFiltering, deploymentName, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a deployment by id.
         * @param {string} id The id of the deployment to be deleted.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this deployment should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] &#x60;true&#x60;, if all input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeployment(id, cascade, skipCustomListeners, skipIoMappings, options) {
            return localVarFp.deleteDeployment(id, cascade, skipCustomListeners, skipIoMappings, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a deployment by id, according to the `Deployment` interface of the engine.
         * @param {string} id The id of the deployment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployment(id, options) {
            return localVarFp.getDeployment(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a deployment resource by resource id for the given deployment.
         * @param {string} id The id of the deployment
         * @param {string} resourceId The id of the deployment resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentResource(id, resourceId, options) {
            return localVarFp.getDeploymentResource(id, resourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the binary content of a deployment resource for the given deployment by id.
         * @param {string} id The id of the deployment.
         * @param {string} resourceId The id of the deployment resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentResourceData(id, resourceId, options) {
            return localVarFp.getDeploymentResourceData(id, resourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all deployment resources of a given deployment.
         * @param {string} id The id of the deployment to retrieve the deployment resources for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentResources(id, options) {
            return localVarFp.getDeploymentResources(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for deployments that fulfill given parameters. Parameters may be the properties of deployments, such as the id or name or a range of the deployment time. The size of the result set can be retrieved by using the [Get Deployment count](https://docs.camunda.org/manual/7.13/reference/rest/deployment/get-query-count/) method.
         * @param {string} [id] Filter by deployment id
         * @param {string} [name] Filter by the deployment name. Exact match.
         * @param {string} [nameLike] Filter by the deployment name that the parameter is a substring of. The parameter can include the wildcard &#x60;%&#x60; to express like-strategy such as: starts with (&#x60;%&#x60;name), ends with (name&#x60;%&#x60;) or contains (&#x60;%&#x60;name&#x60;%&#x60;).
         * @param {string} [source] Filter by the deployment source.
         * @param {boolean} [withoutSource] Filter by the deployment source whereby source is equal to &#x60;null&#x60;.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A deployment must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include deployments which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeDeploymentsWithoutTenantId] Include deployments which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [after] Restricts to all deployments after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [before] Restricts to all deployments before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployments(id, name, nameLike, source, withoutSource, tenantIdIn, withoutTenantId, includeDeploymentsWithoutTenantId, after, before, sortBy, sortOrder, firstResult, maxResults, options) {
            return localVarFp.getDeployments(id, name, nameLike, source, withoutSource, tenantIdIn, withoutTenantId, includeDeploymentsWithoutTenantId, after, before, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for the number of deployments that fulfill given parameters. Takes the same parameters as the [Get Deployments](https://docs.camunda.org/manual/7.13/reference/rest/deployment/get-query/) method.
         * @param {string} [id] Filter by deployment id
         * @param {string} [name] Filter by the deployment name. Exact match.
         * @param {string} [nameLike] Filter by the deployment name that the parameter is a substring of. The parameter can include the wildcard &#x60;%&#x60; to express like-strategy such as: starts with (&#x60;%&#x60;name), ends with (name&#x60;%&#x60;) or contains (&#x60;%&#x60;name&#x60;%&#x60;).
         * @param {string} [source] Filter by the deployment source.
         * @param {boolean} [withoutSource] Filter by the deployment source whereby source is equal to &#x60;null&#x60;.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A deployment must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include deployments which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeDeploymentsWithoutTenantId] Include deployments which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [after] Restricts to all deployments after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [before] Restricts to all deployments before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentsCount(id, name, nameLike, source, withoutSource, tenantIdIn, withoutTenantId, includeDeploymentsWithoutTenantId, after, before, options) {
            return localVarFp.getDeploymentsCount(id, name, nameLike, source, withoutSource, tenantIdIn, withoutTenantId, includeDeploymentsWithoutTenantId, after, before, options).then((request) => request(axios, basePath));
        },
        /**
         * Re-deploys an existing deployment.  The deployment resources to re-deploy can be restricted by using the properties `resourceIds` or `resourceNames`. If no deployment resources to re-deploy are passed then all existing resources of the given deployment are re-deployed.  **Warning**: Deployments can contain custom code in form of scripts or EL expressions to customize process behavior. This may be abused for remote execution of arbitrary code. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) in the user guide for details.
         * @param {string} id The id of the deployment to re-deploy.
         * @param {RedeploymentDto} [redeploymentDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeploy(id, redeploymentDto, options) {
            return localVarFp.redeploy(id, redeploymentDto, options).then((request) => request(axios, basePath));
        },
    };
};
exports.DeploymentApiFactory = DeploymentApiFactory;
/**
 * DeploymentApi - object-oriented interface
 * @export
 * @class DeploymentApi
 * @extends {BaseAPI}
 */
class DeploymentApi extends base_1.BaseAPI {
    /**
     * Creates a deployment.  **Security Consideration**  Deployments can contain custom code in form of scripts or EL expressions to customize process behavior. This may be abused for remote execution of arbitrary code.
     * @param {string} [tenantId] The tenant id for the deployment to be created.
     * @param {string} [deploymentSource] The source for the deployment to be created.
     * @param {boolean} [deployChangedOnly] A flag indicating whether the process engine should perform duplicate checking on a per-resource basis. If set to true, only those resources that have actually changed are deployed. Checks are made against resources included previous deployments of the same name and only against the latest versions of those resources. If set to true, the option enable-duplicate-filtering is overridden and set to true.
     * @param {boolean} [enableDuplicateFiltering] A flag indicating whether the process engine should perform duplicate checking for the deployment or not. This allows you to check if a deployment with the same name and the same resouces already exists and if true, not create a new deployment but instead return the existing deployment. The default value is false.
     * @param {string} [deploymentName] The name for the deployment to be created.
     * @param {any} [data] The binary data to create the deployment resource. It is possible to have more than one form part with different form part names for the binary data to create a deployment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    createDeployment(tenantId, deploymentSource, deployChangedOnly, enableDuplicateFiltering, deploymentName, data, options) {
        return (0, exports.DeploymentApiFp)(this.configuration).createDeployment(tenantId, deploymentSource, deployChangedOnly, enableDuplicateFiltering, deploymentName, data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes a deployment by id.
     * @param {string} id The id of the deployment to be deleted.
     * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this deployment should be deleted.
     * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
     * @param {boolean} [skipIoMappings] &#x60;true&#x60;, if all input/output mappings should not be invoked.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    deleteDeployment(id, cascade, skipCustomListeners, skipIoMappings, options) {
        return (0, exports.DeploymentApiFp)(this.configuration).deleteDeployment(id, cascade, skipCustomListeners, skipIoMappings, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a deployment by id, according to the `Deployment` interface of the engine.
     * @param {string} id The id of the deployment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    getDeployment(id, options) {
        return (0, exports.DeploymentApiFp)(this.configuration).getDeployment(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a deployment resource by resource id for the given deployment.
     * @param {string} id The id of the deployment
     * @param {string} resourceId The id of the deployment resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    getDeploymentResource(id, resourceId, options) {
        return (0, exports.DeploymentApiFp)(this.configuration).getDeploymentResource(id, resourceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the binary content of a deployment resource for the given deployment by id.
     * @param {string} id The id of the deployment.
     * @param {string} resourceId The id of the deployment resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    getDeploymentResourceData(id, resourceId, options) {
        return (0, exports.DeploymentApiFp)(this.configuration).getDeploymentResourceData(id, resourceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves all deployment resources of a given deployment.
     * @param {string} id The id of the deployment to retrieve the deployment resources for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    getDeploymentResources(id, options) {
        return (0, exports.DeploymentApiFp)(this.configuration).getDeploymentResources(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for deployments that fulfill given parameters. Parameters may be the properties of deployments, such as the id or name or a range of the deployment time. The size of the result set can be retrieved by using the [Get Deployment count](https://docs.camunda.org/manual/7.13/reference/rest/deployment/get-query-count/) method.
     * @param {string} [id] Filter by deployment id
     * @param {string} [name] Filter by the deployment name. Exact match.
     * @param {string} [nameLike] Filter by the deployment name that the parameter is a substring of. The parameter can include the wildcard &#x60;%&#x60; to express like-strategy such as: starts with (&#x60;%&#x60;name), ends with (name&#x60;%&#x60;) or contains (&#x60;%&#x60;name&#x60;%&#x60;).
     * @param {string} [source] Filter by the deployment source.
     * @param {boolean} [withoutSource] Filter by the deployment source whereby source is equal to &#x60;null&#x60;.
     * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A deployment must have one of the given tenant ids.
     * @param {boolean} [withoutTenantId] Only include deployments which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [includeDeploymentsWithoutTenantId] Include deployments which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [after] Restricts to all deployments after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {string} [before] Restricts to all deployments before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    getDeployments(id, name, nameLike, source, withoutSource, tenantIdIn, withoutTenantId, includeDeploymentsWithoutTenantId, after, before, sortBy, sortOrder, firstResult, maxResults, options) {
        return (0, exports.DeploymentApiFp)(this.configuration).getDeployments(id, name, nameLike, source, withoutSource, tenantIdIn, withoutTenantId, includeDeploymentsWithoutTenantId, after, before, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for the number of deployments that fulfill given parameters. Takes the same parameters as the [Get Deployments](https://docs.camunda.org/manual/7.13/reference/rest/deployment/get-query/) method.
     * @param {string} [id] Filter by deployment id
     * @param {string} [name] Filter by the deployment name. Exact match.
     * @param {string} [nameLike] Filter by the deployment name that the parameter is a substring of. The parameter can include the wildcard &#x60;%&#x60; to express like-strategy such as: starts with (&#x60;%&#x60;name), ends with (name&#x60;%&#x60;) or contains (&#x60;%&#x60;name&#x60;%&#x60;).
     * @param {string} [source] Filter by the deployment source.
     * @param {boolean} [withoutSource] Filter by the deployment source whereby source is equal to &#x60;null&#x60;.
     * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A deployment must have one of the given tenant ids.
     * @param {boolean} [withoutTenantId] Only include deployments which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [includeDeploymentsWithoutTenantId] Include deployments which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [after] Restricts to all deployments after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {string} [before] Restricts to all deployments before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    getDeploymentsCount(id, name, nameLike, source, withoutSource, tenantIdIn, withoutTenantId, includeDeploymentsWithoutTenantId, after, before, options) {
        return (0, exports.DeploymentApiFp)(this.configuration).getDeploymentsCount(id, name, nameLike, source, withoutSource, tenantIdIn, withoutTenantId, includeDeploymentsWithoutTenantId, after, before, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Re-deploys an existing deployment.  The deployment resources to re-deploy can be restricted by using the properties `resourceIds` or `resourceNames`. If no deployment resources to re-deploy are passed then all existing resources of the given deployment are re-deployed.  **Warning**: Deployments can contain custom code in form of scripts or EL expressions to customize process behavior. This may be abused for remote execution of arbitrary code. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) in the user guide for details.
     * @param {string} id The id of the deployment to re-deploy.
     * @param {RedeploymentDto} [redeploymentDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    redeploy(id, redeploymentDto, options) {
        return (0, exports.DeploymentApiFp)(this.configuration).redeploy(id, redeploymentDto, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.DeploymentApi = DeploymentApi;
/**
 * EngineApi - axios parameter creator
 * @export
 */
const EngineApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves the names of all process engines available on your platform. **Note**: You cannot prepend `/engine/{name}` to this method.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessEngineNames: async (options = {}) => {
            const localVarPath = `/engine`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.EngineApiAxiosParamCreator = EngineApiAxiosParamCreator;
/**
 * EngineApi - functional programming interface
 * @export
 */
const EngineApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.EngineApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieves the names of all process engines available on your platform. **Note**: You cannot prepend `/engine/{name}` to this method.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessEngineNames(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessEngineNames(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.EngineApiFp = EngineApiFp;
/**
 * EngineApi - factory interface
 * @export
 */
const EngineApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.EngineApiFp)(configuration);
    return {
        /**
         * Retrieves the names of all process engines available on your platform. **Note**: You cannot prepend `/engine/{name}` to this method.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessEngineNames(options) {
            return localVarFp.getProcessEngineNames(options).then((request) => request(axios, basePath));
        },
    };
};
exports.EngineApiFactory = EngineApiFactory;
/**
 * EngineApi - object-oriented interface
 * @export
 * @class EngineApi
 * @extends {BaseAPI}
 */
class EngineApi extends base_1.BaseAPI {
    /**
     * Retrieves the names of all process engines available on your platform. **Note**: You cannot prepend `/engine/{name}` to this method.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EngineApi
     */
    getProcessEngineNames(options) {
        return (0, exports.EngineApiFp)(this.configuration).getProcessEngineNames(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.EngineApi = EngineApi;
/**
 * EventSubscriptionApi - axios parameter creator
 * @export
 */
const EventSubscriptionApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Queries for event subscriptions that fulfill given parameters. The size of the result set can be retrieved by using the [Get Event Subscriptions count](https://docs.camunda.org/manual/7.13/reference/rest/event-subscription/get-query-count/) method.
         * @param {string} [eventSubscriptionId] Only select subscription with the given id.
         * @param {string} [eventName] Only select subscriptions for events with the given name.
         * @param {'message' | 'signal' | 'compensate' | 'conditional'} [eventType] Only select subscriptions for events with the given type. Valid values: &#x60;message&#x60;, &#x60;signal&#x60;, &#x60;compensate&#x60; and &#x60;conditional&#x60;.
         * @param {string} [executionId] Only select subscriptions that belong to an execution with the given id.
         * @param {string} [processInstanceId] Only select subscriptions that belong to a process instance with the given id.
         * @param {string} [activityId] Only select subscriptions that belong to an activity with the given id.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. Only select subscriptions that belong to one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only select subscriptions which have no tenant id. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeEventSubscriptionsWithoutTenantId] Select event subscriptions which have no tenant id. Can be used in combination with tenantIdIn parameter. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {'created' | 'tenantId'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSubscriptions: async (eventSubscriptionId, eventName, eventType, executionId, processInstanceId, activityId, tenantIdIn, withoutTenantId, includeEventSubscriptionsWithoutTenantId, sortBy, sortOrder, firstResult, maxResults, options = {}) => {
            const localVarPath = `/event-subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (eventSubscriptionId !== undefined) {
                localVarQueryParameter['eventSubscriptionId'] = eventSubscriptionId;
            }
            if (eventName !== undefined) {
                localVarQueryParameter['eventName'] = eventName;
            }
            if (eventType !== undefined) {
                localVarQueryParameter['eventType'] = eventType;
            }
            if (executionId !== undefined) {
                localVarQueryParameter['executionId'] = executionId;
            }
            if (processInstanceId !== undefined) {
                localVarQueryParameter['processInstanceId'] = processInstanceId;
            }
            if (activityId !== undefined) {
                localVarQueryParameter['activityId'] = activityId;
            }
            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }
            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }
            if (includeEventSubscriptionsWithoutTenantId !== undefined) {
                localVarQueryParameter['includeEventSubscriptionsWithoutTenantId'] = includeEventSubscriptionsWithoutTenantId;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }
            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }
            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for the number of event subscriptions that fulfill given parameters. Takes the same parameters as the [Get Event Subscriptions](https://docs.camunda.org/manual/7.13/reference/rest/event-subscription/get-query/) method.
         * @param {string} [eventSubscriptionId] Only select subscription with the given id.
         * @param {string} [eventName] Only select subscriptions for events with the given name.
         * @param {'message' | 'signal' | 'compensate' | 'conditional'} [eventType] Only select subscriptions for events with the given type. Valid values: &#x60;message&#x60;, &#x60;signal&#x60;, &#x60;compensate&#x60; and &#x60;conditional&#x60;.
         * @param {string} [executionId] Only select subscriptions that belong to an execution with the given id.
         * @param {string} [processInstanceId] Only select subscriptions that belong to a process instance with the given id.
         * @param {string} [activityId] Only select subscriptions that belong to an activity with the given id.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. Only select subscriptions that belong to one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only select subscriptions which have no tenant id. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeEventSubscriptionsWithoutTenantId] Select event subscriptions which have no tenant id. Can be used in combination with tenantIdIn parameter. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSubscriptionsCount: async (eventSubscriptionId, eventName, eventType, executionId, processInstanceId, activityId, tenantIdIn, withoutTenantId, includeEventSubscriptionsWithoutTenantId, options = {}) => {
            const localVarPath = `/event-subscription/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (eventSubscriptionId !== undefined) {
                localVarQueryParameter['eventSubscriptionId'] = eventSubscriptionId;
            }
            if (eventName !== undefined) {
                localVarQueryParameter['eventName'] = eventName;
            }
            if (eventType !== undefined) {
                localVarQueryParameter['eventType'] = eventType;
            }
            if (executionId !== undefined) {
                localVarQueryParameter['executionId'] = executionId;
            }
            if (processInstanceId !== undefined) {
                localVarQueryParameter['processInstanceId'] = processInstanceId;
            }
            if (activityId !== undefined) {
                localVarQueryParameter['activityId'] = activityId;
            }
            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }
            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }
            if (includeEventSubscriptionsWithoutTenantId !== undefined) {
                localVarQueryParameter['includeEventSubscriptionsWithoutTenantId'] = includeEventSubscriptionsWithoutTenantId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.EventSubscriptionApiAxiosParamCreator = EventSubscriptionApiAxiosParamCreator;
/**
 * EventSubscriptionApi - functional programming interface
 * @export
 */
const EventSubscriptionApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.EventSubscriptionApiAxiosParamCreator)(configuration);
    return {
        /**
         * Queries for event subscriptions that fulfill given parameters. The size of the result set can be retrieved by using the [Get Event Subscriptions count](https://docs.camunda.org/manual/7.13/reference/rest/event-subscription/get-query-count/) method.
         * @param {string} [eventSubscriptionId] Only select subscription with the given id.
         * @param {string} [eventName] Only select subscriptions for events with the given name.
         * @param {'message' | 'signal' | 'compensate' | 'conditional'} [eventType] Only select subscriptions for events with the given type. Valid values: &#x60;message&#x60;, &#x60;signal&#x60;, &#x60;compensate&#x60; and &#x60;conditional&#x60;.
         * @param {string} [executionId] Only select subscriptions that belong to an execution with the given id.
         * @param {string} [processInstanceId] Only select subscriptions that belong to a process instance with the given id.
         * @param {string} [activityId] Only select subscriptions that belong to an activity with the given id.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. Only select subscriptions that belong to one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only select subscriptions which have no tenant id. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeEventSubscriptionsWithoutTenantId] Select event subscriptions which have no tenant id. Can be used in combination with tenantIdIn parameter. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {'created' | 'tenantId'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventSubscriptions(eventSubscriptionId, eventName, eventType, executionId, processInstanceId, activityId, tenantIdIn, withoutTenantId, includeEventSubscriptionsWithoutTenantId, sortBy, sortOrder, firstResult, maxResults, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventSubscriptions(eventSubscriptionId, eventName, eventType, executionId, processInstanceId, activityId, tenantIdIn, withoutTenantId, includeEventSubscriptionsWithoutTenantId, sortBy, sortOrder, firstResult, maxResults, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Queries for the number of event subscriptions that fulfill given parameters. Takes the same parameters as the [Get Event Subscriptions](https://docs.camunda.org/manual/7.13/reference/rest/event-subscription/get-query/) method.
         * @param {string} [eventSubscriptionId] Only select subscription with the given id.
         * @param {string} [eventName] Only select subscriptions for events with the given name.
         * @param {'message' | 'signal' | 'compensate' | 'conditional'} [eventType] Only select subscriptions for events with the given type. Valid values: &#x60;message&#x60;, &#x60;signal&#x60;, &#x60;compensate&#x60; and &#x60;conditional&#x60;.
         * @param {string} [executionId] Only select subscriptions that belong to an execution with the given id.
         * @param {string} [processInstanceId] Only select subscriptions that belong to a process instance with the given id.
         * @param {string} [activityId] Only select subscriptions that belong to an activity with the given id.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. Only select subscriptions that belong to one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only select subscriptions which have no tenant id. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeEventSubscriptionsWithoutTenantId] Select event subscriptions which have no tenant id. Can be used in combination with tenantIdIn parameter. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventSubscriptionsCount(eventSubscriptionId, eventName, eventType, executionId, processInstanceId, activityId, tenantIdIn, withoutTenantId, includeEventSubscriptionsWithoutTenantId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventSubscriptionsCount(eventSubscriptionId, eventName, eventType, executionId, processInstanceId, activityId, tenantIdIn, withoutTenantId, includeEventSubscriptionsWithoutTenantId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.EventSubscriptionApiFp = EventSubscriptionApiFp;
/**
 * EventSubscriptionApi - factory interface
 * @export
 */
const EventSubscriptionApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.EventSubscriptionApiFp)(configuration);
    return {
        /**
         * Queries for event subscriptions that fulfill given parameters. The size of the result set can be retrieved by using the [Get Event Subscriptions count](https://docs.camunda.org/manual/7.13/reference/rest/event-subscription/get-query-count/) method.
         * @param {string} [eventSubscriptionId] Only select subscription with the given id.
         * @param {string} [eventName] Only select subscriptions for events with the given name.
         * @param {'message' | 'signal' | 'compensate' | 'conditional'} [eventType] Only select subscriptions for events with the given type. Valid values: &#x60;message&#x60;, &#x60;signal&#x60;, &#x60;compensate&#x60; and &#x60;conditional&#x60;.
         * @param {string} [executionId] Only select subscriptions that belong to an execution with the given id.
         * @param {string} [processInstanceId] Only select subscriptions that belong to a process instance with the given id.
         * @param {string} [activityId] Only select subscriptions that belong to an activity with the given id.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. Only select subscriptions that belong to one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only select subscriptions which have no tenant id. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeEventSubscriptionsWithoutTenantId] Select event subscriptions which have no tenant id. Can be used in combination with tenantIdIn parameter. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {'created' | 'tenantId'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSubscriptions(eventSubscriptionId, eventName, eventType, executionId, processInstanceId, activityId, tenantIdIn, withoutTenantId, includeEventSubscriptionsWithoutTenantId, sortBy, sortOrder, firstResult, maxResults, options) {
            return localVarFp.getEventSubscriptions(eventSubscriptionId, eventName, eventType, executionId, processInstanceId, activityId, tenantIdIn, withoutTenantId, includeEventSubscriptionsWithoutTenantId, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for the number of event subscriptions that fulfill given parameters. Takes the same parameters as the [Get Event Subscriptions](https://docs.camunda.org/manual/7.13/reference/rest/event-subscription/get-query/) method.
         * @param {string} [eventSubscriptionId] Only select subscription with the given id.
         * @param {string} [eventName] Only select subscriptions for events with the given name.
         * @param {'message' | 'signal' | 'compensate' | 'conditional'} [eventType] Only select subscriptions for events with the given type. Valid values: &#x60;message&#x60;, &#x60;signal&#x60;, &#x60;compensate&#x60; and &#x60;conditional&#x60;.
         * @param {string} [executionId] Only select subscriptions that belong to an execution with the given id.
         * @param {string} [processInstanceId] Only select subscriptions that belong to a process instance with the given id.
         * @param {string} [activityId] Only select subscriptions that belong to an activity with the given id.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. Only select subscriptions that belong to one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only select subscriptions which have no tenant id. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeEventSubscriptionsWithoutTenantId] Select event subscriptions which have no tenant id. Can be used in combination with tenantIdIn parameter. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSubscriptionsCount(eventSubscriptionId, eventName, eventType, executionId, processInstanceId, activityId, tenantIdIn, withoutTenantId, includeEventSubscriptionsWithoutTenantId, options) {
            return localVarFp.getEventSubscriptionsCount(eventSubscriptionId, eventName, eventType, executionId, processInstanceId, activityId, tenantIdIn, withoutTenantId, includeEventSubscriptionsWithoutTenantId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.EventSubscriptionApiFactory = EventSubscriptionApiFactory;
/**
 * EventSubscriptionApi - object-oriented interface
 * @export
 * @class EventSubscriptionApi
 * @extends {BaseAPI}
 */
class EventSubscriptionApi extends base_1.BaseAPI {
    /**
     * Queries for event subscriptions that fulfill given parameters. The size of the result set can be retrieved by using the [Get Event Subscriptions count](https://docs.camunda.org/manual/7.13/reference/rest/event-subscription/get-query-count/) method.
     * @param {string} [eventSubscriptionId] Only select subscription with the given id.
     * @param {string} [eventName] Only select subscriptions for events with the given name.
     * @param {'message' | 'signal' | 'compensate' | 'conditional'} [eventType] Only select subscriptions for events with the given type. Valid values: &#x60;message&#x60;, &#x60;signal&#x60;, &#x60;compensate&#x60; and &#x60;conditional&#x60;.
     * @param {string} [executionId] Only select subscriptions that belong to an execution with the given id.
     * @param {string} [processInstanceId] Only select subscriptions that belong to a process instance with the given id.
     * @param {string} [activityId] Only select subscriptions that belong to an activity with the given id.
     * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. Only select subscriptions that belong to one of the given tenant ids.
     * @param {boolean} [withoutTenantId] Only select subscriptions which have no tenant id. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [includeEventSubscriptionsWithoutTenantId] Select event subscriptions which have no tenant id. Can be used in combination with tenantIdIn parameter. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {'created' | 'tenantId'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSubscriptionApi
     */
    getEventSubscriptions(eventSubscriptionId, eventName, eventType, executionId, processInstanceId, activityId, tenantIdIn, withoutTenantId, includeEventSubscriptionsWithoutTenantId, sortBy, sortOrder, firstResult, maxResults, options) {
        return (0, exports.EventSubscriptionApiFp)(this.configuration).getEventSubscriptions(eventSubscriptionId, eventName, eventType, executionId, processInstanceId, activityId, tenantIdIn, withoutTenantId, includeEventSubscriptionsWithoutTenantId, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for the number of event subscriptions that fulfill given parameters. Takes the same parameters as the [Get Event Subscriptions](https://docs.camunda.org/manual/7.13/reference/rest/event-subscription/get-query/) method.
     * @param {string} [eventSubscriptionId] Only select subscription with the given id.
     * @param {string} [eventName] Only select subscriptions for events with the given name.
     * @param {'message' | 'signal' | 'compensate' | 'conditional'} [eventType] Only select subscriptions for events with the given type. Valid values: &#x60;message&#x60;, &#x60;signal&#x60;, &#x60;compensate&#x60; and &#x60;conditional&#x60;.
     * @param {string} [executionId] Only select subscriptions that belong to an execution with the given id.
     * @param {string} [processInstanceId] Only select subscriptions that belong to a process instance with the given id.
     * @param {string} [activityId] Only select subscriptions that belong to an activity with the given id.
     * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. Only select subscriptions that belong to one of the given tenant ids.
     * @param {boolean} [withoutTenantId] Only select subscriptions which have no tenant id. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [includeEventSubscriptionsWithoutTenantId] Select event subscriptions which have no tenant id. Can be used in combination with tenantIdIn parameter. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSubscriptionApi
     */
    getEventSubscriptionsCount(eventSubscriptionId, eventName, eventType, executionId, processInstanceId, activityId, tenantIdIn, withoutTenantId, includeEventSubscriptionsWithoutTenantId, options) {
        return (0, exports.EventSubscriptionApiFp)(this.configuration).getEventSubscriptionsCount(eventSubscriptionId, eventName, eventType, executionId, processInstanceId, activityId, tenantIdIn, withoutTenantId, includeEventSubscriptionsWithoutTenantId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.EventSubscriptionApi = EventSubscriptionApi;
/**
 * ExternalTaskApi - axios parameter creator
 * @export
 */
const ExternalTaskApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Completes an external task by id and updates process variables.
         * @param {string} id The id of the task to complete.
         * @param {CompleteExternalTaskDto} [completeExternalTaskDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeExternalTaskResource: async (id, completeExternalTaskDto, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('completeExternalTaskResource', 'id', id);
            const localVarPath = `/external-task/{id}/complete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(completeExternalTaskDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Extends the timeout of the lock by a given amount of time.
         * @param {string} id The id of the external task.
         * @param {ExtendLockOnExternalTaskDto} [extendLockOnExternalTaskDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extendLock: async (id, extendLockOnExternalTaskDto, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('extendLock', 'id', id);
            const localVarPath = `/external-task/{id}/extendLock`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(extendLockOnExternalTaskDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches and locks a specific number of external tasks for execution by a worker. Query can be restricted to specific task topics and for each task topic an individual lock time can be provided.
         * @param {FetchExternalTasksDto} [fetchExternalTasksDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAndLock: async (fetchExternalTasksDto, options = {}) => {
            const localVarPath = `/external-task/fetchAndLock`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(fetchExternalTasksDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves an external task by id, corresponding to the `ExternalTask` interface in the engine.
         * @param {string} id The id of the external task to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalTask: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getExternalTask', 'id', id);
            const localVarPath = `/external-task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the error details in the context of a running external task by id.
         * @param {string} id The id of the external task for which the error details should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalTaskErrorDetails: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getExternalTaskErrorDetails', 'id', id);
            const localVarPath = `/external-task/{id}/errorDetails`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for the external tasks that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of executions. The size of the result set can be retrieved by using the [Get External Task Count](https://docs.camunda.org/manual/7.13/reference/rest/external-task/get-query-count/) method.
         * @param {string} [externalTaskId] Filter by an external task\&#39;s id.
         * @param {string} [externalTaskIdIn] Filter by the comma-separated list of external task ids.
         * @param {string} [topicName] Filter by an external task topic.
         * @param {string} [workerId] Filter by the id of the worker that the task was most recently locked by.
         * @param {boolean} [locked] Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [notLocked] Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [withRetriesLeft] Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [noRetriesLeft] Only include external tasks that have 0 retries. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {string} [lockExpirationAfter] Restrict to external tasks that have a lock that expires after a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [lockExpirationBefore] Restrict to external tasks that have a lock that expires before a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [activityId] Filter by the id of the activity that an external task is created for.
         * @param {string} [activityIdIn] Filter by the comma-separated list of ids of the activities that an external task is created for.
         * @param {string} [executionId] Filter by the id of the execution that an external task belongs to.
         * @param {string} [processInstanceId] Filter by the id of the process instance that an external task belongs to.
         * @param {string} [processInstanceIdIn] Filter by a comma-separated list of process instance ids that an external task may belong to.
         * @param {string} [processDefinitionId] Filter by the id of the process definition that an external task belongs to.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. An external task must have one of the given tenant ids.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {number} [priorityHigherThanOrEquals] Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {number} [priorityLowerThanOrEquals] Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {'id' | 'lockExpirationTime' | 'processInstanceId' | 'processDefinitionId' | 'processDefinitionKey' | 'taskPriority' | 'tenantId'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalTasks: async (externalTaskId, externalTaskIdIn, topicName, workerId, locked, notLocked, withRetriesLeft, noRetriesLeft, lockExpirationAfter, lockExpirationBefore, activityId, activityIdIn, executionId, processInstanceId, processInstanceIdIn, processDefinitionId, tenantIdIn, active, suspended, priorityHigherThanOrEquals, priorityLowerThanOrEquals, sortBy, sortOrder, firstResult, maxResults, options = {}) => {
            const localVarPath = `/external-task`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (externalTaskId !== undefined) {
                localVarQueryParameter['externalTaskId'] = externalTaskId;
            }
            if (externalTaskIdIn !== undefined) {
                localVarQueryParameter['externalTaskIdIn'] = externalTaskIdIn;
            }
            if (topicName !== undefined) {
                localVarQueryParameter['topicName'] = topicName;
            }
            if (workerId !== undefined) {
                localVarQueryParameter['workerId'] = workerId;
            }
            if (locked !== undefined) {
                localVarQueryParameter['locked'] = locked;
            }
            if (notLocked !== undefined) {
                localVarQueryParameter['notLocked'] = notLocked;
            }
            if (withRetriesLeft !== undefined) {
                localVarQueryParameter['withRetriesLeft'] = withRetriesLeft;
            }
            if (noRetriesLeft !== undefined) {
                localVarQueryParameter['noRetriesLeft'] = noRetriesLeft;
            }
            if (lockExpirationAfter !== undefined) {
                localVarQueryParameter['lockExpirationAfter'] = (lockExpirationAfter instanceof Date) ?
                    lockExpirationAfter.toISOString() :
                    lockExpirationAfter;
            }
            if (lockExpirationBefore !== undefined) {
                localVarQueryParameter['lockExpirationBefore'] = (lockExpirationBefore instanceof Date) ?
                    lockExpirationBefore.toISOString() :
                    lockExpirationBefore;
            }
            if (activityId !== undefined) {
                localVarQueryParameter['activityId'] = activityId;
            }
            if (activityIdIn !== undefined) {
                localVarQueryParameter['activityIdIn'] = activityIdIn;
            }
            if (executionId !== undefined) {
                localVarQueryParameter['executionId'] = executionId;
            }
            if (processInstanceId !== undefined) {
                localVarQueryParameter['processInstanceId'] = processInstanceId;
            }
            if (processInstanceIdIn !== undefined) {
                localVarQueryParameter['processInstanceIdIn'] = processInstanceIdIn;
            }
            if (processDefinitionId !== undefined) {
                localVarQueryParameter['processDefinitionId'] = processDefinitionId;
            }
            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }
            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }
            if (suspended !== undefined) {
                localVarQueryParameter['suspended'] = suspended;
            }
            if (priorityHigherThanOrEquals !== undefined) {
                localVarQueryParameter['priorityHigherThanOrEquals'] = priorityHigherThanOrEquals;
            }
            if (priorityLowerThanOrEquals !== undefined) {
                localVarQueryParameter['priorityLowerThanOrEquals'] = priorityLowerThanOrEquals;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }
            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }
            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for the number of external tasks that fulfill given parameters. Takes the same parameters as the [Get External Tasks](https://docs.camunda.org/manual/7.13/reference/rest/external-task/get-query/) method.
         * @param {string} [externalTaskId] Filter by an external task\&#39;s id.
         * @param {string} [externalTaskIdIn] Filter by the comma-separated list of external task ids.
         * @param {string} [topicName] Filter by an external task topic.
         * @param {string} [workerId] Filter by the id of the worker that the task was most recently locked by.
         * @param {boolean} [locked] Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [notLocked] Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [withRetriesLeft] Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [noRetriesLeft] Only include external tasks that have 0 retries. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {string} [lockExpirationAfter] Restrict to external tasks that have a lock that expires after a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [lockExpirationBefore] Restrict to external tasks that have a lock that expires before a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [activityId] Filter by the id of the activity that an external task is created for.
         * @param {string} [activityIdIn] Filter by the comma-separated list of ids of the activities that an external task is created for.
         * @param {string} [executionId] Filter by the id of the execution that an external task belongs to.
         * @param {string} [processInstanceId] Filter by the id of the process instance that an external task belongs to.
         * @param {string} [processInstanceIdIn] Filter by a comma-separated list of process instance ids that an external task may belong to.
         * @param {string} [processDefinitionId] Filter by the id of the process definition that an external task belongs to.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. An external task must have one of the given tenant ids.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {number} [priorityHigherThanOrEquals] Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {number} [priorityLowerThanOrEquals] Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalTasksCount: async (externalTaskId, externalTaskIdIn, topicName, workerId, locked, notLocked, withRetriesLeft, noRetriesLeft, lockExpirationAfter, lockExpirationBefore, activityId, activityIdIn, executionId, processInstanceId, processInstanceIdIn, processDefinitionId, tenantIdIn, active, suspended, priorityHigherThanOrEquals, priorityLowerThanOrEquals, options = {}) => {
            const localVarPath = `/external-task/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (externalTaskId !== undefined) {
                localVarQueryParameter['externalTaskId'] = externalTaskId;
            }
            if (externalTaskIdIn !== undefined) {
                localVarQueryParameter['externalTaskIdIn'] = externalTaskIdIn;
            }
            if (topicName !== undefined) {
                localVarQueryParameter['topicName'] = topicName;
            }
            if (workerId !== undefined) {
                localVarQueryParameter['workerId'] = workerId;
            }
            if (locked !== undefined) {
                localVarQueryParameter['locked'] = locked;
            }
            if (notLocked !== undefined) {
                localVarQueryParameter['notLocked'] = notLocked;
            }
            if (withRetriesLeft !== undefined) {
                localVarQueryParameter['withRetriesLeft'] = withRetriesLeft;
            }
            if (noRetriesLeft !== undefined) {
                localVarQueryParameter['noRetriesLeft'] = noRetriesLeft;
            }
            if (lockExpirationAfter !== undefined) {
                localVarQueryParameter['lockExpirationAfter'] = (lockExpirationAfter instanceof Date) ?
                    lockExpirationAfter.toISOString() :
                    lockExpirationAfter;
            }
            if (lockExpirationBefore !== undefined) {
                localVarQueryParameter['lockExpirationBefore'] = (lockExpirationBefore instanceof Date) ?
                    lockExpirationBefore.toISOString() :
                    lockExpirationBefore;
            }
            if (activityId !== undefined) {
                localVarQueryParameter['activityId'] = activityId;
            }
            if (activityIdIn !== undefined) {
                localVarQueryParameter['activityIdIn'] = activityIdIn;
            }
            if (executionId !== undefined) {
                localVarQueryParameter['executionId'] = executionId;
            }
            if (processInstanceId !== undefined) {
                localVarQueryParameter['processInstanceId'] = processInstanceId;
            }
            if (processInstanceIdIn !== undefined) {
                localVarQueryParameter['processInstanceIdIn'] = processInstanceIdIn;
            }
            if (processDefinitionId !== undefined) {
                localVarQueryParameter['processDefinitionId'] = processDefinitionId;
            }
            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }
            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }
            if (suspended !== undefined) {
                localVarQueryParameter['suspended'] = suspended;
            }
            if (priorityHigherThanOrEquals !== undefined) {
                localVarQueryParameter['priorityHigherThanOrEquals'] = priorityHigherThanOrEquals;
            }
            if (priorityLowerThanOrEquals !== undefined) {
                localVarQueryParameter['priorityLowerThanOrEquals'] = priorityLowerThanOrEquals;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for distinct topic names of external tasks that fulfill given parameters. Query can be restricted to only tasks with retries left, tasks that are locked, or tasks that are unlocked. The parameters withLockedTasks and withUnlockedTasks are exclusive. Setting them both to true will return an empty list. Providing no parameters will return a list of all distinct topic names with external tasks.
         * @param {boolean} [withLockedTasks] Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [withUnlockedTasks] Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [withRetriesLeft] Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicNames: async (withLockedTasks, withUnlockedTasks, withRetriesLeft, options = {}) => {
            const localVarPath = `/external-task/topic-names`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (withLockedTasks !== undefined) {
                localVarQueryParameter['withLockedTasks'] = withLockedTasks;
            }
            if (withUnlockedTasks !== undefined) {
                localVarQueryParameter['withUnlockedTasks'] = withUnlockedTasks;
            }
            if (withRetriesLeft !== undefined) {
                localVarQueryParameter['withRetriesLeft'] = withRetriesLeft;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reports a business error in the context of a running external task by id. The error code must be specified to identify the BPMN error handler.
         * @param {string} id The id of the external task in which context a BPMN error is reported.
         * @param {ExternalTaskBpmnError} [externalTaskBpmnError]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleExternalTaskBpmnError: async (id, externalTaskBpmnError, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('handleExternalTaskBpmnError', 'id', id);
            const localVarPath = `/external-task/{id}/bpmnError`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(externalTaskBpmnError, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reports a failure to execute an external task by id. A number of retries and a timeout until the task can be retried can be specified. If retries are set to 0, an incident for this task is created.
         * @param {string} id The id of the external task to report a failure for.
         * @param {ExternalTaskFailureDto} [externalTaskFailureDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleFailure: async (id, externalTaskFailureDto, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('handleFailure', 'id', id);
            const localVarPath = `/external-task/{id}/failure`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(externalTaskFailureDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for external tasks that fulfill given parameters in the form of a JSON object.  This method is slightly more powerful than the [Get External Tasks](https://docs.camunda.org/manual/7.13/reference/rest/external-task/get-query/) method because it allows to specify a hierarchical result sorting.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {ExternalTaskQueryDto} [externalTaskQueryDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryExternalTasks: async (firstResult, maxResults, externalTaskQueryDto, options = {}) => {
            const localVarPath = `/external-task`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }
            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(externalTaskQueryDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for the number of external tasks that fulfill given parameters. This method takes the same message body as the [Get External Tasks (POST)](https://docs.camunda.org/manual/7.13/reference/rest/external-task/post-query/) method.
         * @param {ExternalTaskQueryDto} [externalTaskQueryDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryExternalTasksCount: async (externalTaskQueryDto, options = {}) => {
            const localVarPath = `/external-task/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(externalTaskQueryDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the priority of an existing external task by id. The default value of a priority is 0.
         * @param {string} id The id of the external task to set the priority for.
         * @param {PriorityDto} [priorityDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalTaskResourcePriority: async (id, priorityDto, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('setExternalTaskResourcePriority', 'id', id);
            const localVarPath = `/external-task/{id}/priority`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(priorityDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the number of retries left to execute an external task by id. If retries are set to 0, an  incident is created.
         * @param {string} id The id of the external task to set the number of retries for.
         * @param {RetriesDto} [retriesDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalTaskResourceRetries: async (id, retriesDto, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('setExternalTaskResourceRetries', 'id', id);
            const localVarPath = `/external-task/{id}/retries`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(retriesDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the number of retries left to execute external tasks by id synchronously. If retries are set to 0,  an incident is created.
         * @param {SetRetriesForExternalTasksDto} [setRetriesForExternalTasksDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalTaskRetries: async (setRetriesForExternalTasksDto, options = {}) => {
            const localVarPath = `/external-task/retries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(setRetriesForExternalTasksDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the number of retries left to execute external tasks by id asynchronously. If retries are set to 0, an incident is created.
         * @param {SetRetriesForExternalTasksDto} [setRetriesForExternalTasksDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalTaskRetriesAsyncOperation: async (setRetriesForExternalTasksDto, options = {}) => {
            const localVarPath = `/external-task/retries-async`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(setRetriesForExternalTasksDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unlocks an external task by id. Clears the task\'s lock expiration time and worker id.
         * @param {string} id The id of the external task to unlock.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlock: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('unlock', 'id', id);
            const localVarPath = `/external-task/{id}/unlock`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.ExternalTaskApiAxiosParamCreator = ExternalTaskApiAxiosParamCreator;
/**
 * ExternalTaskApi - functional programming interface
 * @export
 */
const ExternalTaskApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ExternalTaskApiAxiosParamCreator)(configuration);
    return {
        /**
         * Completes an external task by id and updates process variables.
         * @param {string} id The id of the task to complete.
         * @param {CompleteExternalTaskDto} [completeExternalTaskDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeExternalTaskResource(id, completeExternalTaskDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeExternalTaskResource(id, completeExternalTaskDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Extends the timeout of the lock by a given amount of time.
         * @param {string} id The id of the external task.
         * @param {ExtendLockOnExternalTaskDto} [extendLockOnExternalTaskDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extendLock(id, extendLockOnExternalTaskDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extendLock(id, extendLockOnExternalTaskDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Fetches and locks a specific number of external tasks for execution by a worker. Query can be restricted to specific task topics and for each task topic an individual lock time can be provided.
         * @param {FetchExternalTasksDto} [fetchExternalTasksDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchAndLock(fetchExternalTasksDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchAndLock(fetchExternalTasksDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves an external task by id, corresponding to the `ExternalTask` interface in the engine.
         * @param {string} id The id of the external task to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExternalTask(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExternalTask(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves the error details in the context of a running external task by id.
         * @param {string} id The id of the external task for which the error details should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExternalTaskErrorDetails(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExternalTaskErrorDetails(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Queries for the external tasks that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of executions. The size of the result set can be retrieved by using the [Get External Task Count](https://docs.camunda.org/manual/7.13/reference/rest/external-task/get-query-count/) method.
         * @param {string} [externalTaskId] Filter by an external task\&#39;s id.
         * @param {string} [externalTaskIdIn] Filter by the comma-separated list of external task ids.
         * @param {string} [topicName] Filter by an external task topic.
         * @param {string} [workerId] Filter by the id of the worker that the task was most recently locked by.
         * @param {boolean} [locked] Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [notLocked] Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [withRetriesLeft] Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [noRetriesLeft] Only include external tasks that have 0 retries. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {string} [lockExpirationAfter] Restrict to external tasks that have a lock that expires after a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [lockExpirationBefore] Restrict to external tasks that have a lock that expires before a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [activityId] Filter by the id of the activity that an external task is created for.
         * @param {string} [activityIdIn] Filter by the comma-separated list of ids of the activities that an external task is created for.
         * @param {string} [executionId] Filter by the id of the execution that an external task belongs to.
         * @param {string} [processInstanceId] Filter by the id of the process instance that an external task belongs to.
         * @param {string} [processInstanceIdIn] Filter by a comma-separated list of process instance ids that an external task may belong to.
         * @param {string} [processDefinitionId] Filter by the id of the process definition that an external task belongs to.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. An external task must have one of the given tenant ids.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {number} [priorityHigherThanOrEquals] Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {number} [priorityLowerThanOrEquals] Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {'id' | 'lockExpirationTime' | 'processInstanceId' | 'processDefinitionId' | 'processDefinitionKey' | 'taskPriority' | 'tenantId'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExternalTasks(externalTaskId, externalTaskIdIn, topicName, workerId, locked, notLocked, withRetriesLeft, noRetriesLeft, lockExpirationAfter, lockExpirationBefore, activityId, activityIdIn, executionId, processInstanceId, processInstanceIdIn, processDefinitionId, tenantIdIn, active, suspended, priorityHigherThanOrEquals, priorityLowerThanOrEquals, sortBy, sortOrder, firstResult, maxResults, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExternalTasks(externalTaskId, externalTaskIdIn, topicName, workerId, locked, notLocked, withRetriesLeft, noRetriesLeft, lockExpirationAfter, lockExpirationBefore, activityId, activityIdIn, executionId, processInstanceId, processInstanceIdIn, processDefinitionId, tenantIdIn, active, suspended, priorityHigherThanOrEquals, priorityLowerThanOrEquals, sortBy, sortOrder, firstResult, maxResults, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Queries for the number of external tasks that fulfill given parameters. Takes the same parameters as the [Get External Tasks](https://docs.camunda.org/manual/7.13/reference/rest/external-task/get-query/) method.
         * @param {string} [externalTaskId] Filter by an external task\&#39;s id.
         * @param {string} [externalTaskIdIn] Filter by the comma-separated list of external task ids.
         * @param {string} [topicName] Filter by an external task topic.
         * @param {string} [workerId] Filter by the id of the worker that the task was most recently locked by.
         * @param {boolean} [locked] Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [notLocked] Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [withRetriesLeft] Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [noRetriesLeft] Only include external tasks that have 0 retries. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {string} [lockExpirationAfter] Restrict to external tasks that have a lock that expires after a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [lockExpirationBefore] Restrict to external tasks that have a lock that expires before a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [activityId] Filter by the id of the activity that an external task is created for.
         * @param {string} [activityIdIn] Filter by the comma-separated list of ids of the activities that an external task is created for.
         * @param {string} [executionId] Filter by the id of the execution that an external task belongs to.
         * @param {string} [processInstanceId] Filter by the id of the process instance that an external task belongs to.
         * @param {string} [processInstanceIdIn] Filter by a comma-separated list of process instance ids that an external task may belong to.
         * @param {string} [processDefinitionId] Filter by the id of the process definition that an external task belongs to.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. An external task must have one of the given tenant ids.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {number} [priorityHigherThanOrEquals] Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {number} [priorityLowerThanOrEquals] Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExternalTasksCount(externalTaskId, externalTaskIdIn, topicName, workerId, locked, notLocked, withRetriesLeft, noRetriesLeft, lockExpirationAfter, lockExpirationBefore, activityId, activityIdIn, executionId, processInstanceId, processInstanceIdIn, processDefinitionId, tenantIdIn, active, suspended, priorityHigherThanOrEquals, priorityLowerThanOrEquals, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExternalTasksCount(externalTaskId, externalTaskIdIn, topicName, workerId, locked, notLocked, withRetriesLeft, noRetriesLeft, lockExpirationAfter, lockExpirationBefore, activityId, activityIdIn, executionId, processInstanceId, processInstanceIdIn, processDefinitionId, tenantIdIn, active, suspended, priorityHigherThanOrEquals, priorityLowerThanOrEquals, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Queries for distinct topic names of external tasks that fulfill given parameters. Query can be restricted to only tasks with retries left, tasks that are locked, or tasks that are unlocked. The parameters withLockedTasks and withUnlockedTasks are exclusive. Setting them both to true will return an empty list. Providing no parameters will return a list of all distinct topic names with external tasks.
         * @param {boolean} [withLockedTasks] Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [withUnlockedTasks] Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [withRetriesLeft] Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopicNames(withLockedTasks, withUnlockedTasks, withRetriesLeft, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopicNames(withLockedTasks, withUnlockedTasks, withRetriesLeft, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Reports a business error in the context of a running external task by id. The error code must be specified to identify the BPMN error handler.
         * @param {string} id The id of the external task in which context a BPMN error is reported.
         * @param {ExternalTaskBpmnError} [externalTaskBpmnError]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleExternalTaskBpmnError(id, externalTaskBpmnError, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleExternalTaskBpmnError(id, externalTaskBpmnError, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Reports a failure to execute an external task by id. A number of retries and a timeout until the task can be retried can be specified. If retries are set to 0, an incident for this task is created.
         * @param {string} id The id of the external task to report a failure for.
         * @param {ExternalTaskFailureDto} [externalTaskFailureDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleFailure(id, externalTaskFailureDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleFailure(id, externalTaskFailureDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Queries for external tasks that fulfill given parameters in the form of a JSON object.  This method is slightly more powerful than the [Get External Tasks](https://docs.camunda.org/manual/7.13/reference/rest/external-task/get-query/) method because it allows to specify a hierarchical result sorting.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {ExternalTaskQueryDto} [externalTaskQueryDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryExternalTasks(firstResult, maxResults, externalTaskQueryDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryExternalTasks(firstResult, maxResults, externalTaskQueryDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Queries for the number of external tasks that fulfill given parameters. This method takes the same message body as the [Get External Tasks (POST)](https://docs.camunda.org/manual/7.13/reference/rest/external-task/post-query/) method.
         * @param {ExternalTaskQueryDto} [externalTaskQueryDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryExternalTasksCount(externalTaskQueryDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryExternalTasksCount(externalTaskQueryDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Sets the priority of an existing external task by id. The default value of a priority is 0.
         * @param {string} id The id of the external task to set the priority for.
         * @param {PriorityDto} [priorityDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setExternalTaskResourcePriority(id, priorityDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setExternalTaskResourcePriority(id, priorityDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Sets the number of retries left to execute an external task by id. If retries are set to 0, an  incident is created.
         * @param {string} id The id of the external task to set the number of retries for.
         * @param {RetriesDto} [retriesDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setExternalTaskResourceRetries(id, retriesDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setExternalTaskResourceRetries(id, retriesDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Sets the number of retries left to execute external tasks by id synchronously. If retries are set to 0,  an incident is created.
         * @param {SetRetriesForExternalTasksDto} [setRetriesForExternalTasksDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setExternalTaskRetries(setRetriesForExternalTasksDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setExternalTaskRetries(setRetriesForExternalTasksDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Sets the number of retries left to execute external tasks by id asynchronously. If retries are set to 0, an incident is created.
         * @param {SetRetriesForExternalTasksDto} [setRetriesForExternalTasksDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setExternalTaskRetriesAsyncOperation(setRetriesForExternalTasksDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setExternalTaskRetriesAsyncOperation(setRetriesForExternalTasksDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Unlocks an external task by id. Clears the task\'s lock expiration time and worker id.
         * @param {string} id The id of the external task to unlock.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlock(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlock(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.ExternalTaskApiFp = ExternalTaskApiFp;
/**
 * ExternalTaskApi - factory interface
 * @export
 */
const ExternalTaskApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ExternalTaskApiFp)(configuration);
    return {
        /**
         * Completes an external task by id and updates process variables.
         * @param {string} id The id of the task to complete.
         * @param {CompleteExternalTaskDto} [completeExternalTaskDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeExternalTaskResource(id, completeExternalTaskDto, options) {
            return localVarFp.completeExternalTaskResource(id, completeExternalTaskDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Extends the timeout of the lock by a given amount of time.
         * @param {string} id The id of the external task.
         * @param {ExtendLockOnExternalTaskDto} [extendLockOnExternalTaskDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extendLock(id, extendLockOnExternalTaskDto, options) {
            return localVarFp.extendLock(id, extendLockOnExternalTaskDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches and locks a specific number of external tasks for execution by a worker. Query can be restricted to specific task topics and for each task topic an individual lock time can be provided.
         * @param {FetchExternalTasksDto} [fetchExternalTasksDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAndLock(fetchExternalTasksDto, options) {
            return localVarFp.fetchAndLock(fetchExternalTasksDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves an external task by id, corresponding to the `ExternalTask` interface in the engine.
         * @param {string} id The id of the external task to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalTask(id, options) {
            return localVarFp.getExternalTask(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the error details in the context of a running external task by id.
         * @param {string} id The id of the external task for which the error details should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalTaskErrorDetails(id, options) {
            return localVarFp.getExternalTaskErrorDetails(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for the external tasks that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of executions. The size of the result set can be retrieved by using the [Get External Task Count](https://docs.camunda.org/manual/7.13/reference/rest/external-task/get-query-count/) method.
         * @param {string} [externalTaskId] Filter by an external task\&#39;s id.
         * @param {string} [externalTaskIdIn] Filter by the comma-separated list of external task ids.
         * @param {string} [topicName] Filter by an external task topic.
         * @param {string} [workerId] Filter by the id of the worker that the task was most recently locked by.
         * @param {boolean} [locked] Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [notLocked] Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [withRetriesLeft] Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [noRetriesLeft] Only include external tasks that have 0 retries. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {string} [lockExpirationAfter] Restrict to external tasks that have a lock that expires after a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [lockExpirationBefore] Restrict to external tasks that have a lock that expires before a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [activityId] Filter by the id of the activity that an external task is created for.
         * @param {string} [activityIdIn] Filter by the comma-separated list of ids of the activities that an external task is created for.
         * @param {string} [executionId] Filter by the id of the execution that an external task belongs to.
         * @param {string} [processInstanceId] Filter by the id of the process instance that an external task belongs to.
         * @param {string} [processInstanceIdIn] Filter by a comma-separated list of process instance ids that an external task may belong to.
         * @param {string} [processDefinitionId] Filter by the id of the process definition that an external task belongs to.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. An external task must have one of the given tenant ids.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {number} [priorityHigherThanOrEquals] Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {number} [priorityLowerThanOrEquals] Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {'id' | 'lockExpirationTime' | 'processInstanceId' | 'processDefinitionId' | 'processDefinitionKey' | 'taskPriority' | 'tenantId'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalTasks(externalTaskId, externalTaskIdIn, topicName, workerId, locked, notLocked, withRetriesLeft, noRetriesLeft, lockExpirationAfter, lockExpirationBefore, activityId, activityIdIn, executionId, processInstanceId, processInstanceIdIn, processDefinitionId, tenantIdIn, active, suspended, priorityHigherThanOrEquals, priorityLowerThanOrEquals, sortBy, sortOrder, firstResult, maxResults, options) {
            return localVarFp.getExternalTasks(externalTaskId, externalTaskIdIn, topicName, workerId, locked, notLocked, withRetriesLeft, noRetriesLeft, lockExpirationAfter, lockExpirationBefore, activityId, activityIdIn, executionId, processInstanceId, processInstanceIdIn, processDefinitionId, tenantIdIn, active, suspended, priorityHigherThanOrEquals, priorityLowerThanOrEquals, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for the number of external tasks that fulfill given parameters. Takes the same parameters as the [Get External Tasks](https://docs.camunda.org/manual/7.13/reference/rest/external-task/get-query/) method.
         * @param {string} [externalTaskId] Filter by an external task\&#39;s id.
         * @param {string} [externalTaskIdIn] Filter by the comma-separated list of external task ids.
         * @param {string} [topicName] Filter by an external task topic.
         * @param {string} [workerId] Filter by the id of the worker that the task was most recently locked by.
         * @param {boolean} [locked] Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [notLocked] Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [withRetriesLeft] Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [noRetriesLeft] Only include external tasks that have 0 retries. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {string} [lockExpirationAfter] Restrict to external tasks that have a lock that expires after a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [lockExpirationBefore] Restrict to external tasks that have a lock that expires before a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [activityId] Filter by the id of the activity that an external task is created for.
         * @param {string} [activityIdIn] Filter by the comma-separated list of ids of the activities that an external task is created for.
         * @param {string} [executionId] Filter by the id of the execution that an external task belongs to.
         * @param {string} [processInstanceId] Filter by the id of the process instance that an external task belongs to.
         * @param {string} [processInstanceIdIn] Filter by a comma-separated list of process instance ids that an external task may belong to.
         * @param {string} [processDefinitionId] Filter by the id of the process definition that an external task belongs to.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. An external task must have one of the given tenant ids.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {number} [priorityHigherThanOrEquals] Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {number} [priorityLowerThanOrEquals] Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalTasksCount(externalTaskId, externalTaskIdIn, topicName, workerId, locked, notLocked, withRetriesLeft, noRetriesLeft, lockExpirationAfter, lockExpirationBefore, activityId, activityIdIn, executionId, processInstanceId, processInstanceIdIn, processDefinitionId, tenantIdIn, active, suspended, priorityHigherThanOrEquals, priorityLowerThanOrEquals, options) {
            return localVarFp.getExternalTasksCount(externalTaskId, externalTaskIdIn, topicName, workerId, locked, notLocked, withRetriesLeft, noRetriesLeft, lockExpirationAfter, lockExpirationBefore, activityId, activityIdIn, executionId, processInstanceId, processInstanceIdIn, processDefinitionId, tenantIdIn, active, suspended, priorityHigherThanOrEquals, priorityLowerThanOrEquals, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for distinct topic names of external tasks that fulfill given parameters. Query can be restricted to only tasks with retries left, tasks that are locked, or tasks that are unlocked. The parameters withLockedTasks and withUnlockedTasks are exclusive. Setting them both to true will return an empty list. Providing no parameters will return a list of all distinct topic names with external tasks.
         * @param {boolean} [withLockedTasks] Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [withUnlockedTasks] Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [withRetriesLeft] Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicNames(withLockedTasks, withUnlockedTasks, withRetriesLeft, options) {
            return localVarFp.getTopicNames(withLockedTasks, withUnlockedTasks, withRetriesLeft, options).then((request) => request(axios, basePath));
        },
        /**
         * Reports a business error in the context of a running external task by id. The error code must be specified to identify the BPMN error handler.
         * @param {string} id The id of the external task in which context a BPMN error is reported.
         * @param {ExternalTaskBpmnError} [externalTaskBpmnError]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleExternalTaskBpmnError(id, externalTaskBpmnError, options) {
            return localVarFp.handleExternalTaskBpmnError(id, externalTaskBpmnError, options).then((request) => request(axios, basePath));
        },
        /**
         * Reports a failure to execute an external task by id. A number of retries and a timeout until the task can be retried can be specified. If retries are set to 0, an incident for this task is created.
         * @param {string} id The id of the external task to report a failure for.
         * @param {ExternalTaskFailureDto} [externalTaskFailureDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleFailure(id, externalTaskFailureDto, options) {
            return localVarFp.handleFailure(id, externalTaskFailureDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for external tasks that fulfill given parameters in the form of a JSON object.  This method is slightly more powerful than the [Get External Tasks](https://docs.camunda.org/manual/7.13/reference/rest/external-task/get-query/) method because it allows to specify a hierarchical result sorting.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {ExternalTaskQueryDto} [externalTaskQueryDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryExternalTasks(firstResult, maxResults, externalTaskQueryDto, options) {
            return localVarFp.queryExternalTasks(firstResult, maxResults, externalTaskQueryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for the number of external tasks that fulfill given parameters. This method takes the same message body as the [Get External Tasks (POST)](https://docs.camunda.org/manual/7.13/reference/rest/external-task/post-query/) method.
         * @param {ExternalTaskQueryDto} [externalTaskQueryDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryExternalTasksCount(externalTaskQueryDto, options) {
            return localVarFp.queryExternalTasksCount(externalTaskQueryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the priority of an existing external task by id. The default value of a priority is 0.
         * @param {string} id The id of the external task to set the priority for.
         * @param {PriorityDto} [priorityDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalTaskResourcePriority(id, priorityDto, options) {
            return localVarFp.setExternalTaskResourcePriority(id, priorityDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the number of retries left to execute an external task by id. If retries are set to 0, an  incident is created.
         * @param {string} id The id of the external task to set the number of retries for.
         * @param {RetriesDto} [retriesDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalTaskResourceRetries(id, retriesDto, options) {
            return localVarFp.setExternalTaskResourceRetries(id, retriesDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the number of retries left to execute external tasks by id synchronously. If retries are set to 0,  an incident is created.
         * @param {SetRetriesForExternalTasksDto} [setRetriesForExternalTasksDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalTaskRetries(setRetriesForExternalTasksDto, options) {
            return localVarFp.setExternalTaskRetries(setRetriesForExternalTasksDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the number of retries left to execute external tasks by id asynchronously. If retries are set to 0, an incident is created.
         * @param {SetRetriesForExternalTasksDto} [setRetriesForExternalTasksDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalTaskRetriesAsyncOperation(setRetriesForExternalTasksDto, options) {
            return localVarFp.setExternalTaskRetriesAsyncOperation(setRetriesForExternalTasksDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Unlocks an external task by id. Clears the task\'s lock expiration time and worker id.
         * @param {string} id The id of the external task to unlock.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlock(id, options) {
            return localVarFp.unlock(id, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ExternalTaskApiFactory = ExternalTaskApiFactory;
/**
 * ExternalTaskApi - object-oriented interface
 * @export
 * @class ExternalTaskApi
 * @extends {BaseAPI}
 */
class ExternalTaskApi extends base_1.BaseAPI {
    /**
     * Completes an external task by id and updates process variables.
     * @param {string} id The id of the task to complete.
     * @param {CompleteExternalTaskDto} [completeExternalTaskDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    completeExternalTaskResource(id, completeExternalTaskDto, options) {
        return (0, exports.ExternalTaskApiFp)(this.configuration).completeExternalTaskResource(id, completeExternalTaskDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Extends the timeout of the lock by a given amount of time.
     * @param {string} id The id of the external task.
     * @param {ExtendLockOnExternalTaskDto} [extendLockOnExternalTaskDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    extendLock(id, extendLockOnExternalTaskDto, options) {
        return (0, exports.ExternalTaskApiFp)(this.configuration).extendLock(id, extendLockOnExternalTaskDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches and locks a specific number of external tasks for execution by a worker. Query can be restricted to specific task topics and for each task topic an individual lock time can be provided.
     * @param {FetchExternalTasksDto} [fetchExternalTasksDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    fetchAndLock(fetchExternalTasksDto, options) {
        return (0, exports.ExternalTaskApiFp)(this.configuration).fetchAndLock(fetchExternalTasksDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves an external task by id, corresponding to the `ExternalTask` interface in the engine.
     * @param {string} id The id of the external task to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    getExternalTask(id, options) {
        return (0, exports.ExternalTaskApiFp)(this.configuration).getExternalTask(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the error details in the context of a running external task by id.
     * @param {string} id The id of the external task for which the error details should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    getExternalTaskErrorDetails(id, options) {
        return (0, exports.ExternalTaskApiFp)(this.configuration).getExternalTaskErrorDetails(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for the external tasks that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of executions. The size of the result set can be retrieved by using the [Get External Task Count](https://docs.camunda.org/manual/7.13/reference/rest/external-task/get-query-count/) method.
     * @param {string} [externalTaskId] Filter by an external task\&#39;s id.
     * @param {string} [externalTaskIdIn] Filter by the comma-separated list of external task ids.
     * @param {string} [topicName] Filter by an external task topic.
     * @param {string} [workerId] Filter by the id of the worker that the task was most recently locked by.
     * @param {boolean} [locked] Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {boolean} [notLocked] Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {boolean} [withRetriesLeft] Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {boolean} [noRetriesLeft] Only include external tasks that have 0 retries. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {string} [lockExpirationAfter] Restrict to external tasks that have a lock that expires after a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {string} [lockExpirationBefore] Restrict to external tasks that have a lock that expires before a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {string} [activityId] Filter by the id of the activity that an external task is created for.
     * @param {string} [activityIdIn] Filter by the comma-separated list of ids of the activities that an external task is created for.
     * @param {string} [executionId] Filter by the id of the execution that an external task belongs to.
     * @param {string} [processInstanceId] Filter by the id of the process instance that an external task belongs to.
     * @param {string} [processInstanceIdIn] Filter by a comma-separated list of process instance ids that an external task may belong to.
     * @param {string} [processDefinitionId] Filter by the id of the process definition that an external task belongs to.
     * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. An external task must have one of the given tenant ids.
     * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {number} [priorityHigherThanOrEquals] Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
     * @param {number} [priorityLowerThanOrEquals] Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
     * @param {'id' | 'lockExpirationTime' | 'processInstanceId' | 'processDefinitionId' | 'processDefinitionKey' | 'taskPriority' | 'tenantId'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    getExternalTasks(externalTaskId, externalTaskIdIn, topicName, workerId, locked, notLocked, withRetriesLeft, noRetriesLeft, lockExpirationAfter, lockExpirationBefore, activityId, activityIdIn, executionId, processInstanceId, processInstanceIdIn, processDefinitionId, tenantIdIn, active, suspended, priorityHigherThanOrEquals, priorityLowerThanOrEquals, sortBy, sortOrder, firstResult, maxResults, options) {
        return (0, exports.ExternalTaskApiFp)(this.configuration).getExternalTasks(externalTaskId, externalTaskIdIn, topicName, workerId, locked, notLocked, withRetriesLeft, noRetriesLeft, lockExpirationAfter, lockExpirationBefore, activityId, activityIdIn, executionId, processInstanceId, processInstanceIdIn, processDefinitionId, tenantIdIn, active, suspended, priorityHigherThanOrEquals, priorityLowerThanOrEquals, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for the number of external tasks that fulfill given parameters. Takes the same parameters as the [Get External Tasks](https://docs.camunda.org/manual/7.13/reference/rest/external-task/get-query/) method.
     * @param {string} [externalTaskId] Filter by an external task\&#39;s id.
     * @param {string} [externalTaskIdIn] Filter by the comma-separated list of external task ids.
     * @param {string} [topicName] Filter by an external task topic.
     * @param {string} [workerId] Filter by the id of the worker that the task was most recently locked by.
     * @param {boolean} [locked] Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {boolean} [notLocked] Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {boolean} [withRetriesLeft] Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {boolean} [noRetriesLeft] Only include external tasks that have 0 retries. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {string} [lockExpirationAfter] Restrict to external tasks that have a lock that expires after a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {string} [lockExpirationBefore] Restrict to external tasks that have a lock that expires before a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {string} [activityId] Filter by the id of the activity that an external task is created for.
     * @param {string} [activityIdIn] Filter by the comma-separated list of ids of the activities that an external task is created for.
     * @param {string} [executionId] Filter by the id of the execution that an external task belongs to.
     * @param {string} [processInstanceId] Filter by the id of the process instance that an external task belongs to.
     * @param {string} [processInstanceIdIn] Filter by a comma-separated list of process instance ids that an external task may belong to.
     * @param {string} [processDefinitionId] Filter by the id of the process definition that an external task belongs to.
     * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. An external task must have one of the given tenant ids.
     * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {number} [priorityHigherThanOrEquals] Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
     * @param {number} [priorityLowerThanOrEquals] Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    getExternalTasksCount(externalTaskId, externalTaskIdIn, topicName, workerId, locked, notLocked, withRetriesLeft, noRetriesLeft, lockExpirationAfter, lockExpirationBefore, activityId, activityIdIn, executionId, processInstanceId, processInstanceIdIn, processDefinitionId, tenantIdIn, active, suspended, priorityHigherThanOrEquals, priorityLowerThanOrEquals, options) {
        return (0, exports.ExternalTaskApiFp)(this.configuration).getExternalTasksCount(externalTaskId, externalTaskIdIn, topicName, workerId, locked, notLocked, withRetriesLeft, noRetriesLeft, lockExpirationAfter, lockExpirationBefore, activityId, activityIdIn, executionId, processInstanceId, processInstanceIdIn, processDefinitionId, tenantIdIn, active, suspended, priorityHigherThanOrEquals, priorityLowerThanOrEquals, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for distinct topic names of external tasks that fulfill given parameters. Query can be restricted to only tasks with retries left, tasks that are locked, or tasks that are unlocked. The parameters withLockedTasks and withUnlockedTasks are exclusive. Setting them both to true will return an empty list. Providing no parameters will return a list of all distinct topic names with external tasks.
     * @param {boolean} [withLockedTasks] Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {boolean} [withUnlockedTasks] Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {boolean} [withRetriesLeft] Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    getTopicNames(withLockedTasks, withUnlockedTasks, withRetriesLeft, options) {
        return (0, exports.ExternalTaskApiFp)(this.configuration).getTopicNames(withLockedTasks, withUnlockedTasks, withRetriesLeft, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Reports a business error in the context of a running external task by id. The error code must be specified to identify the BPMN error handler.
     * @param {string} id The id of the external task in which context a BPMN error is reported.
     * @param {ExternalTaskBpmnError} [externalTaskBpmnError]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    handleExternalTaskBpmnError(id, externalTaskBpmnError, options) {
        return (0, exports.ExternalTaskApiFp)(this.configuration).handleExternalTaskBpmnError(id, externalTaskBpmnError, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Reports a failure to execute an external task by id. A number of retries and a timeout until the task can be retried can be specified. If retries are set to 0, an incident for this task is created.
     * @param {string} id The id of the external task to report a failure for.
     * @param {ExternalTaskFailureDto} [externalTaskFailureDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    handleFailure(id, externalTaskFailureDto, options) {
        return (0, exports.ExternalTaskApiFp)(this.configuration).handleFailure(id, externalTaskFailureDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for external tasks that fulfill given parameters in the form of a JSON object.  This method is slightly more powerful than the [Get External Tasks](https://docs.camunda.org/manual/7.13/reference/rest/external-task/get-query/) method because it allows to specify a hierarchical result sorting.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {ExternalTaskQueryDto} [externalTaskQueryDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    queryExternalTasks(firstResult, maxResults, externalTaskQueryDto, options) {
        return (0, exports.ExternalTaskApiFp)(this.configuration).queryExternalTasks(firstResult, maxResults, externalTaskQueryDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for the number of external tasks that fulfill given parameters. This method takes the same message body as the [Get External Tasks (POST)](https://docs.camunda.org/manual/7.13/reference/rest/external-task/post-query/) method.
     * @param {ExternalTaskQueryDto} [externalTaskQueryDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    queryExternalTasksCount(externalTaskQueryDto, options) {
        return (0, exports.ExternalTaskApiFp)(this.configuration).queryExternalTasksCount(externalTaskQueryDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets the priority of an existing external task by id. The default value of a priority is 0.
     * @param {string} id The id of the external task to set the priority for.
     * @param {PriorityDto} [priorityDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    setExternalTaskResourcePriority(id, priorityDto, options) {
        return (0, exports.ExternalTaskApiFp)(this.configuration).setExternalTaskResourcePriority(id, priorityDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets the number of retries left to execute an external task by id. If retries are set to 0, an  incident is created.
     * @param {string} id The id of the external task to set the number of retries for.
     * @param {RetriesDto} [retriesDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    setExternalTaskResourceRetries(id, retriesDto, options) {
        return (0, exports.ExternalTaskApiFp)(this.configuration).setExternalTaskResourceRetries(id, retriesDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets the number of retries left to execute external tasks by id synchronously. If retries are set to 0,  an incident is created.
     * @param {SetRetriesForExternalTasksDto} [setRetriesForExternalTasksDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    setExternalTaskRetries(setRetriesForExternalTasksDto, options) {
        return (0, exports.ExternalTaskApiFp)(this.configuration).setExternalTaskRetries(setRetriesForExternalTasksDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets the number of retries left to execute external tasks by id asynchronously. If retries are set to 0, an incident is created.
     * @param {SetRetriesForExternalTasksDto} [setRetriesForExternalTasksDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    setExternalTaskRetriesAsyncOperation(setRetriesForExternalTasksDto, options) {
        return (0, exports.ExternalTaskApiFp)(this.configuration).setExternalTaskRetriesAsyncOperation(setRetriesForExternalTasksDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Unlocks an external task by id. Clears the task\'s lock expiration time and worker id.
     * @param {string} id The id of the external task to unlock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    unlock(id, options) {
        return (0, exports.ExternalTaskApiFp)(this.configuration).unlock(id, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ExternalTaskApi = ExternalTaskApi;
/**
 * MessageApi - axios parameter creator
 * @export
 */
const MessageApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Correlates a message to the process engine to either trigger a message start event or an intermediate message  catching event. Internally this maps to the engine\'s message correlation builder methods `MessageCorrelationBuilder#correlateWithResult()` and `MessageCorrelationBuilder#correlateAllWithResult()`. For more information about the correlation behavior, see the [Message Events](https://docs.camunda.org/manual/7.13/bpmn20/events/message-events/) section of the [BPMN 2.0 Implementation Reference](https://docs.camunda.org/manual/7.13/reference/bpmn20/).
         * @param {CorrelationMessageDto} [correlationMessageDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliverMessage: async (correlationMessageDto, options = {}) => {
            const localVarPath = `/message`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(correlationMessageDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.MessageApiAxiosParamCreator = MessageApiAxiosParamCreator;
/**
 * MessageApi - functional programming interface
 * @export
 */
const MessageApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.MessageApiAxiosParamCreator)(configuration);
    return {
        /**
         * Correlates a message to the process engine to either trigger a message start event or an intermediate message  catching event. Internally this maps to the engine\'s message correlation builder methods `MessageCorrelationBuilder#correlateWithResult()` and `MessageCorrelationBuilder#correlateAllWithResult()`. For more information about the correlation behavior, see the [Message Events](https://docs.camunda.org/manual/7.13/bpmn20/events/message-events/) section of the [BPMN 2.0 Implementation Reference](https://docs.camunda.org/manual/7.13/reference/bpmn20/).
         * @param {CorrelationMessageDto} [correlationMessageDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deliverMessage(correlationMessageDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deliverMessage(correlationMessageDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.MessageApiFp = MessageApiFp;
/**
 * MessageApi - factory interface
 * @export
 */
const MessageApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.MessageApiFp)(configuration);
    return {
        /**
         * Correlates a message to the process engine to either trigger a message start event or an intermediate message  catching event. Internally this maps to the engine\'s message correlation builder methods `MessageCorrelationBuilder#correlateWithResult()` and `MessageCorrelationBuilder#correlateAllWithResult()`. For more information about the correlation behavior, see the [Message Events](https://docs.camunda.org/manual/7.13/bpmn20/events/message-events/) section of the [BPMN 2.0 Implementation Reference](https://docs.camunda.org/manual/7.13/reference/bpmn20/).
         * @param {CorrelationMessageDto} [correlationMessageDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliverMessage(correlationMessageDto, options) {
            return localVarFp.deliverMessage(correlationMessageDto, options).then((request) => request(axios, basePath));
        },
    };
};
exports.MessageApiFactory = MessageApiFactory;
/**
 * MessageApi - object-oriented interface
 * @export
 * @class MessageApi
 * @extends {BaseAPI}
 */
class MessageApi extends base_1.BaseAPI {
    /**
     * Correlates a message to the process engine to either trigger a message start event or an intermediate message  catching event. Internally this maps to the engine\'s message correlation builder methods `MessageCorrelationBuilder#correlateWithResult()` and `MessageCorrelationBuilder#correlateAllWithResult()`. For more information about the correlation behavior, see the [Message Events](https://docs.camunda.org/manual/7.13/bpmn20/events/message-events/) section of the [BPMN 2.0 Implementation Reference](https://docs.camunda.org/manual/7.13/reference/bpmn20/).
     * @param {CorrelationMessageDto} [correlationMessageDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    deliverMessage(correlationMessageDto, options) {
        return (0, exports.MessageApiFp)(this.configuration).deliverMessage(correlationMessageDto, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.MessageApi = MessageApi;
/**
 * MetricsApi - axios parameter creator
 * @export
 */
const MetricsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves the `sum` (count) for a given metric.
         * @param {'activity-instance-start' | 'activity-instance-end' | 'job-acquisition-attempt' | 'job-acquired-success' | 'job-acquired-failure' | 'job-execution-rejected' | 'job-successful' | 'job-failed' | 'job-locked-exclusive' | 'executed-decision-elements' | 'history-cleanup-removed-process-instances' | 'history-cleanup-removed-case-instances' | 'history-cleanup-removed-decision-instances' | 'history-cleanup-removed-batch-operations'} metricsName The name of the metric.
         * @param {string} [startDate] The start date (inclusive).
         * @param {string} [endDate] The end date (exclusive).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics: async (metricsName, startDate, endDate, options = {}) => {
            // verify required parameter 'metricsName' is not null or undefined
            (0, common_1.assertParamExists)('getMetrics', 'metricsName', metricsName);
            const localVarPath = `/metrics/{metrics-name}/sum`
                .replace(`{${"metrics-name"}}`, encodeURIComponent(String(metricsName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate instanceof Date) ?
                    startDate.toISOString() :
                    startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate instanceof Date) ?
                    endDate.toISOString() :
                    endDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of metrics, aggregated for a given interval.
         * @param {'activity-instance-start' | 'activity-instance-end' | 'job-acquisition-attempt' | 'job-acquired-success' | 'job-acquired-failure' | 'job-execution-rejected' | 'job-successful' | 'job-failed' | 'job-locked-exclusive' | 'executed-decision-elements' | 'history-cleanup-removed-process-instances' | 'history-cleanup-removed-case-instances' | 'history-cleanup-removed-decision-instances' | 'history-cleanup-removed-batch-operations'} [name] The name of the metric.
         * @param {string} [reporter] The name of the reporter (host), on which the metrics was logged. This will have value provided by the [hostname configuration property](https://docs.camunda.org/manual/7.13/reference/deployment-descriptors/tags/process-engine/#hostname).
         * @param {string} [startDate] The start date (inclusive).
         * @param {string} [endDate] The end date (exclusive).
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {string} [interval] The interval for which the metrics should be aggregated. Time unit is seconds. Default: The interval is set to 15 minutes (900 seconds).
         * @param {string} [aggregateByReporter] Aggregate metrics by reporter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interval: async (name, reporter, startDate, endDate, firstResult, maxResults, interval, aggregateByReporter, options = {}) => {
            const localVarPath = `/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (reporter !== undefined) {
                localVarQueryParameter['reporter'] = reporter;
            }
            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate instanceof Date) ?
                    startDate.toISOString() :
                    startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate instanceof Date) ?
                    endDate.toISOString() :
                    endDate;
            }
            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }
            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }
            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }
            if (aggregateByReporter !== undefined) {
                localVarQueryParameter['aggregateByReporter'] = aggregateByReporter;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.MetricsApiAxiosParamCreator = MetricsApiAxiosParamCreator;
/**
 * MetricsApi - functional programming interface
 * @export
 */
const MetricsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.MetricsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieves the `sum` (count) for a given metric.
         * @param {'activity-instance-start' | 'activity-instance-end' | 'job-acquisition-attempt' | 'job-acquired-success' | 'job-acquired-failure' | 'job-execution-rejected' | 'job-successful' | 'job-failed' | 'job-locked-exclusive' | 'executed-decision-elements' | 'history-cleanup-removed-process-instances' | 'history-cleanup-removed-case-instances' | 'history-cleanup-removed-decision-instances' | 'history-cleanup-removed-batch-operations'} metricsName The name of the metric.
         * @param {string} [startDate] The start date (inclusive).
         * @param {string} [endDate] The end date (exclusive).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetrics(metricsName, startDate, endDate, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetrics(metricsName, startDate, endDate, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of metrics, aggregated for a given interval.
         * @param {'activity-instance-start' | 'activity-instance-end' | 'job-acquisition-attempt' | 'job-acquired-success' | 'job-acquired-failure' | 'job-execution-rejected' | 'job-successful' | 'job-failed' | 'job-locked-exclusive' | 'executed-decision-elements' | 'history-cleanup-removed-process-instances' | 'history-cleanup-removed-case-instances' | 'history-cleanup-removed-decision-instances' | 'history-cleanup-removed-batch-operations'} [name] The name of the metric.
         * @param {string} [reporter] The name of the reporter (host), on which the metrics was logged. This will have value provided by the [hostname configuration property](https://docs.camunda.org/manual/7.13/reference/deployment-descriptors/tags/process-engine/#hostname).
         * @param {string} [startDate] The start date (inclusive).
         * @param {string} [endDate] The end date (exclusive).
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {string} [interval] The interval for which the metrics should be aggregated. Time unit is seconds. Default: The interval is set to 15 minutes (900 seconds).
         * @param {string} [aggregateByReporter] Aggregate metrics by reporter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async interval(name, reporter, startDate, endDate, firstResult, maxResults, interval, aggregateByReporter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.interval(name, reporter, startDate, endDate, firstResult, maxResults, interval, aggregateByReporter, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.MetricsApiFp = MetricsApiFp;
/**
 * MetricsApi - factory interface
 * @export
 */
const MetricsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.MetricsApiFp)(configuration);
    return {
        /**
         * Retrieves the `sum` (count) for a given metric.
         * @param {'activity-instance-start' | 'activity-instance-end' | 'job-acquisition-attempt' | 'job-acquired-success' | 'job-acquired-failure' | 'job-execution-rejected' | 'job-successful' | 'job-failed' | 'job-locked-exclusive' | 'executed-decision-elements' | 'history-cleanup-removed-process-instances' | 'history-cleanup-removed-case-instances' | 'history-cleanup-removed-decision-instances' | 'history-cleanup-removed-batch-operations'} metricsName The name of the metric.
         * @param {string} [startDate] The start date (inclusive).
         * @param {string} [endDate] The end date (exclusive).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics(metricsName, startDate, endDate, options) {
            return localVarFp.getMetrics(metricsName, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of metrics, aggregated for a given interval.
         * @param {'activity-instance-start' | 'activity-instance-end' | 'job-acquisition-attempt' | 'job-acquired-success' | 'job-acquired-failure' | 'job-execution-rejected' | 'job-successful' | 'job-failed' | 'job-locked-exclusive' | 'executed-decision-elements' | 'history-cleanup-removed-process-instances' | 'history-cleanup-removed-case-instances' | 'history-cleanup-removed-decision-instances' | 'history-cleanup-removed-batch-operations'} [name] The name of the metric.
         * @param {string} [reporter] The name of the reporter (host), on which the metrics was logged. This will have value provided by the [hostname configuration property](https://docs.camunda.org/manual/7.13/reference/deployment-descriptors/tags/process-engine/#hostname).
         * @param {string} [startDate] The start date (inclusive).
         * @param {string} [endDate] The end date (exclusive).
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {string} [interval] The interval for which the metrics should be aggregated. Time unit is seconds. Default: The interval is set to 15 minutes (900 seconds).
         * @param {string} [aggregateByReporter] Aggregate metrics by reporter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interval(name, reporter, startDate, endDate, firstResult, maxResults, interval, aggregateByReporter, options) {
            return localVarFp.interval(name, reporter, startDate, endDate, firstResult, maxResults, interval, aggregateByReporter, options).then((request) => request(axios, basePath));
        },
    };
};
exports.MetricsApiFactory = MetricsApiFactory;
/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
class MetricsApi extends base_1.BaseAPI {
    /**
     * Retrieves the `sum` (count) for a given metric.
     * @param {'activity-instance-start' | 'activity-instance-end' | 'job-acquisition-attempt' | 'job-acquired-success' | 'job-acquired-failure' | 'job-execution-rejected' | 'job-successful' | 'job-failed' | 'job-locked-exclusive' | 'executed-decision-elements' | 'history-cleanup-removed-process-instances' | 'history-cleanup-removed-case-instances' | 'history-cleanup-removed-decision-instances' | 'history-cleanup-removed-batch-operations'} metricsName The name of the metric.
     * @param {string} [startDate] The start date (inclusive).
     * @param {string} [endDate] The end date (exclusive).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    getMetrics(metricsName, startDate, endDate, options) {
        return (0, exports.MetricsApiFp)(this.configuration).getMetrics(metricsName, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a list of metrics, aggregated for a given interval.
     * @param {'activity-instance-start' | 'activity-instance-end' | 'job-acquisition-attempt' | 'job-acquired-success' | 'job-acquired-failure' | 'job-execution-rejected' | 'job-successful' | 'job-failed' | 'job-locked-exclusive' | 'executed-decision-elements' | 'history-cleanup-removed-process-instances' | 'history-cleanup-removed-case-instances' | 'history-cleanup-removed-decision-instances' | 'history-cleanup-removed-batch-operations'} [name] The name of the metric.
     * @param {string} [reporter] The name of the reporter (host), on which the metrics was logged. This will have value provided by the [hostname configuration property](https://docs.camunda.org/manual/7.13/reference/deployment-descriptors/tags/process-engine/#hostname).
     * @param {string} [startDate] The start date (inclusive).
     * @param {string} [endDate] The end date (exclusive).
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {string} [interval] The interval for which the metrics should be aggregated. Time unit is seconds. Default: The interval is set to 15 minutes (900 seconds).
     * @param {string} [aggregateByReporter] Aggregate metrics by reporter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    interval(name, reporter, startDate, endDate, firstResult, maxResults, interval, aggregateByReporter, options) {
        return (0, exports.MetricsApiFp)(this.configuration).interval(name, reporter, startDate, endDate, firstResult, maxResults, interval, aggregateByReporter, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.MetricsApi = MetricsApi;
/**
 * ProcessDefinitionApi - axios parameter creator
 * @export
 */
const ProcessDefinitionApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Deletes a running process instance by id.
         * @summary Delete
         * @param {string} id The id of the process definition to be deleted.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessDefinition: async (id, cascade, skipCustomListeners, skipIoMappings, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteProcessDefinition', 'id', id);
            const localVarPath = `/process-definition/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (cascade !== undefined) {
                localVarQueryParameter['cascade'] = cascade;
            }
            if (skipCustomListeners !== undefined) {
                localVarQueryParameter['skipCustomListeners'] = skipCustomListeners;
            }
            if (skipIoMappings !== undefined) {
                localVarQueryParameter['skipIoMappings'] = skipIoMappings;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes process definitions by a given key which belong to no tenant id.
         * @summary Delete By Key
         * @param {string} key The key of the process definitions to be deleted.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessDefinitionsByKey: async (key, cascade, skipCustomListeners, skipIoMappings, options = {}) => {
            // verify required parameter 'key' is not null or undefined
            (0, common_1.assertParamExists)('deleteProcessDefinitionsByKey', 'key', key);
            const localVarPath = `/process-definition/key/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (cascade !== undefined) {
                localVarQueryParameter['cascade'] = cascade;
            }
            if (skipCustomListeners !== undefined) {
                localVarQueryParameter['skipCustomListeners'] = skipCustomListeners;
            }
            if (skipIoMappings !== undefined) {
                localVarQueryParameter['skipIoMappings'] = skipIoMappings;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes process definitions by a given key and which belong to a tenant id.
         * @summary Delete By Key
         * @param {string} key The key of the process definitions to be deleted.
         * @param {string} tenantId The id of the tenant the process definitions belong to.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessDefinitionsByKeyAndTenantId: async (key, tenantId, cascade, skipCustomListeners, skipIoMappings, options = {}) => {
            // verify required parameter 'key' is not null or undefined
            (0, common_1.assertParamExists)('deleteProcessDefinitionsByKeyAndTenantId', 'key', key);
            // verify required parameter 'tenantId' is not null or undefined
            (0, common_1.assertParamExists)('deleteProcessDefinitionsByKeyAndTenantId', 'tenantId', tenantId);
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (cascade !== undefined) {
                localVarQueryParameter['cascade'] = cascade;
            }
            if (skipCustomListeners !== undefined) {
                localVarQueryParameter['skipCustomListeners'] = skipCustomListeners;
            }
            if (skipIoMappings !== undefined) {
                localVarQueryParameter['skipIoMappings'] = skipIoMappings;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves runtime statistics of a given process definition, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Activity Instance Statistics
         * @param {string} id The id of the process definition.
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityStatistics: async (id, failedJobs, incidents, incidentsForType, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getActivityStatistics', 'id', id);
            const localVarPath = `/process-definition/{id}/statistics`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (failedJobs !== undefined) {
                localVarQueryParameter['failedJobs'] = failedJobs;
            }
            if (incidents !== undefined) {
                localVarQueryParameter['incidents'] = incidents;
            }
            if (incidentsForType !== undefined) {
                localVarQueryParameter['incidentsForType'] = incidentsForType;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves runtime statistics of the latest version of the given process definition which belongs to no tenant, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Activity Instance Statistics
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityStatisticsByProcessDefinitionKey: async (key, failedJobs, incidents, incidentsForType, options = {}) => {
            // verify required parameter 'key' is not null or undefined
            (0, common_1.assertParamExists)('getActivityStatisticsByProcessDefinitionKey', 'key', key);
            const localVarPath = `/process-definition/key/{key}/statistics`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (failedJobs !== undefined) {
                localVarQueryParameter['failedJobs'] = failedJobs;
            }
            if (incidents !== undefined) {
                localVarQueryParameter['incidents'] = incidents;
            }
            if (incidentsForType !== undefined) {
                localVarQueryParameter['incidentsForType'] = incidentsForType;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves runtime statistics of the latest version of the given process definition for a tenant, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Activity Instance Statistics
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityStatisticsByProcessDefinitionKeyAndTenantId: async (key, tenantId, failedJobs, incidents, incidentsForType, options = {}) => {
            // verify required parameter 'key' is not null or undefined
            (0, common_1.assertParamExists)('getActivityStatisticsByProcessDefinitionKeyAndTenantId', 'key', key);
            // verify required parameter 'tenantId' is not null or undefined
            (0, common_1.assertParamExists)('getActivityStatisticsByProcessDefinitionKeyAndTenantId', 'tenantId', tenantId);
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}/statistics`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (failedJobs !== undefined) {
                localVarQueryParameter['failedJobs'] = failedJobs;
            }
            if (incidents !== undefined) {
                localVarQueryParameter['incidents'] = incidents;
            }
            if (incidentsForType !== undefined) {
                localVarQueryParameter['incidentsForType'] = incidentsForType;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Start Form
         * @param {string} id The id of the process definition to get the deployed start form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedStartForm: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getDeployedStartForm', 'id', id);
            const localVarPath = `/process-definition/{id}/deployed-start-form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedStartFormByKey: async (key, options = {}) => {
            // verify required parameter 'key' is not null or undefined
            (0, common_1.assertParamExists)('getDeployedStartFormByKey', 'key', key);
            const localVarPath = `/process-definition/key/{key}/deployed-start-form`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definitions belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedStartFormByKeyAndTenantId: async (key, tenantId, options = {}) => {
            // verify required parameter 'key' is not null or undefined
            (0, common_1.assertParamExists)('getDeployedStartFormByKeyAndTenantId', 'key', key);
            // verify required parameter 'tenantId' is not null or undefined
            (0, common_1.assertParamExists)('getDeployedStartFormByKeyAndTenantId', 'tenantId', tenantId);
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}/deployed-start-form`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the latest version of the process definition for tenant according to the `ProcessDefinition` interface in the engine.
         * @summary Get
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestProcessDefinitionByTenantId: async (key, tenantId, options = {}) => {
            // verify required parameter 'key' is not null or undefined
            (0, common_1.assertParamExists)('getLatestProcessDefinitionByTenantId', 'key', key);
            // verify required parameter 'tenantId' is not null or undefined
            (0, common_1.assertParamExists)('getLatestProcessDefinitionByTenantId', 'tenantId', tenantId);
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a process definition according to the `ProcessDefinition` interface in the engine.
         * @summary Get
         * @param {string} id The id of the process definition to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinition: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getProcessDefinition', 'id', id);
            const localVarPath = `/process-definition/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the BPMN 2.0 XML of a process definition.
         * @summary Get XML
         * @param {string} id The id of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionBpmn20Xml: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getProcessDefinitionBpmn20Xml', 'id', id);
            const localVarPath = `/process-definition/{id}/xml`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves latest version the BPMN 2.0 XML of a process definition.
         * @summary Get XML
         * @param {string} key The key of the process definition (the latest version thereof) whose XML should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionBpmn20XmlByKey: async (key, options = {}) => {
            // verify required parameter 'key' is not null or undefined
            (0, common_1.assertParamExists)('getProcessDefinitionBpmn20XmlByKey', 'key', key);
            const localVarPath = `/process-definition/key/{key}/xml`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves latest version the BPMN 2.0 XML of a process definition. Returns the XML for the latest version of the process definition for tenant.
         * @summary Get XML
         * @param {string} key The key of the process definition (the latest version thereof) whose XML should be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionBpmn20XmlByKeyAndTenantId: async (key, tenantId, options = {}) => {
            // verify required parameter 'key' is not null or undefined
            (0, common_1.assertParamExists)('getProcessDefinitionBpmn20XmlByKeyAndTenantId', 'key', key);
            // verify required parameter 'tenantId' is not null or undefined
            (0, common_1.assertParamExists)('getProcessDefinitionBpmn20XmlByKeyAndTenantId', 'tenantId', tenantId);
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}/xml`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the latest version of the process definition which belongs to no tenant according to the `ProcessDefinition` interface in the engine.
         * @summary Get
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionByKey: async (key, options = {}) => {
            // verify required parameter 'key' is not null or undefined
            (0, common_1.assertParamExists)('getProcessDefinitionByKey', 'key', key);
            const localVarPath = `/process-definition/key/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the diagram of a process definition.  If the process definition\'s deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
         * @summary Get Diagram
         * @param {string} id The id of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionDiagram: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getProcessDefinitionDiagram', 'id', id);
            const localVarPath = `/process-definition/{id}/diagram`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the diagram for the latest version of the process definition which belongs to no tenant.  If the process definition\'s deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
         * @summary Get Diagram
         * @param {string} key The key of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionDiagramByKey: async (key, options = {}) => {
            // verify required parameter 'key' is not null or undefined
            (0, common_1.assertParamExists)('getProcessDefinitionDiagramByKey', 'key', key);
            const localVarPath = `/process-definition/key/{key}/diagram`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the diagram for the latest version of the process definition for tenant.  If the process definition\'s deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
         * @summary Get Diagram
         * @param {string} key The key of the process definition.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionDiagramByKeyAndTenantId: async (key, tenantId, options = {}) => {
            // verify required parameter 'key' is not null or undefined
            (0, common_1.assertParamExists)('getProcessDefinitionDiagramByKeyAndTenantId', 'key', key);
            // verify required parameter 'tenantId' is not null or undefined
            (0, common_1.assertParamExists)('getProcessDefinitionDiagramByKeyAndTenantId', 'tenantId', tenantId);
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}/diagram`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves runtime statistics of the process engine, grouped by process definitions. These statistics include the number of running process instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Process Instance Statistics
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {boolean} [rootIncidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of root incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60; or &#x60;incidents&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionStatistics: async (failedJobs, incidents, incidentsForType, rootIncidents, options = {}) => {
            const localVarPath = `/process-definition/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (failedJobs !== undefined) {
                localVarQueryParameter['failedJobs'] = failedJobs;
            }
            if (incidents !== undefined) {
                localVarQueryParameter['incidents'] = incidents;
            }
            if (incidentsForType !== undefined) {
                localVarQueryParameter['incidentsForType'] = incidentsForType;
            }
            if (rootIncidents !== undefined) {
                localVarQueryParameter['rootIncidents'] = rootIncidents;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for process definitions that fulfill given parameters. Parameters may be the properties of  process definitions, such as the name, key or version. The size of the result set can be retrieved by using the [Get Definition Count](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/get-query-count/) method.
         * @summary Get List
         * @param {string} [processDefinitionId] Filter by process definition id.
         * @param {string} [processDefinitionIdIn] Filter by a comma-separated list of process definition ids.
         * @param {string} [name] Filter by process definition name.
         * @param {string} [nameLike] Filter by process definition names that the parameter is a substring of.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {string} [deployedAfter] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [deployedAt] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [key] Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match.
         * @param {string} [keysIn] Filter by a comma-separated list of process definition keys.
         * @param {string} [keyLike] Filter by process definition keys that the parameter is a substring of.
         * @param {string} [category] Filter by process definition category. Exact match.
         * @param {string} [categoryLike] Filter by process definition categories that the parameter is a substring of.
         * @param {number} [version] Filter by process definition version.
         * @param {boolean} [latestVersion] Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [resourceName] Filter by the name of the process definition resource. Exact match.
         * @param {string} [resourceNameLike] Filter by names of those process definition resources that the parameter is a substring of.
         * @param {string} [startableBy] Filter by a user name who is allowed to start the process.
         * @param {boolean} [active] Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior.
         * @param {boolean} [includeProcessDefinitionsWithoutTenantId] Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [versionTag] Filter by the version tag.
         * @param {string} [versionTagLike] Filter by the version tag that the parameter is a substring of.
         * @param {boolean} [withoutVersionTag] Only include process definitions without a &#x60;versionTag&#x60;.
         * @param {boolean} [startableInTasklist] Filter by process definitions which are startable in Tasklist..
         * @param {boolean} [notStartableInTasklist] Filter by process definitions which are not startable in Tasklist.
         * @param {boolean} [startablePermissionCheck] Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn\&#39;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level
         * @param {'category' | 'key' | 'id' | 'name' | 'version' | 'deploymentId' | 'deployTime' | 'tenantId ' | 'versionTag'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitions: async (processDefinitionId, processDefinitionIdIn, name, nameLike, deploymentId, deployedAfter, deployedAt, key, keysIn, keyLike, category, categoryLike, version, latestVersion, resourceName, resourceNameLike, startableBy, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, includeProcessDefinitionsWithoutTenantId, versionTag, versionTagLike, withoutVersionTag, startableInTasklist, notStartableInTasklist, startablePermissionCheck, sortBy, sortOrder, firstResult, maxResults, options = {}) => {
            const localVarPath = `/process-definition`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (processDefinitionId !== undefined) {
                localVarQueryParameter['processDefinitionId'] = processDefinitionId;
            }
            if (processDefinitionIdIn !== undefined) {
                localVarQueryParameter['processDefinitionIdIn'] = processDefinitionIdIn;
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (nameLike !== undefined) {
                localVarQueryParameter['nameLike'] = nameLike;
            }
            if (deploymentId !== undefined) {
                localVarQueryParameter['deploymentId'] = deploymentId;
            }
            if (deployedAfter !== undefined) {
                localVarQueryParameter['deployedAfter'] = (deployedAfter instanceof Date) ?
                    deployedAfter.toISOString() :
                    deployedAfter;
            }
            if (deployedAt !== undefined) {
                localVarQueryParameter['deployedAt'] = (deployedAt instanceof Date) ?
                    deployedAt.toISOString() :
                    deployedAt;
            }
            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }
            if (keysIn !== undefined) {
                localVarQueryParameter['keysIn'] = keysIn;
            }
            if (keyLike !== undefined) {
                localVarQueryParameter['keyLike'] = keyLike;
            }
            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }
            if (categoryLike !== undefined) {
                localVarQueryParameter['categoryLike'] = categoryLike;
            }
            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }
            if (latestVersion !== undefined) {
                localVarQueryParameter['latestVersion'] = latestVersion;
            }
            if (resourceName !== undefined) {
                localVarQueryParameter['resourceName'] = resourceName;
            }
            if (resourceNameLike !== undefined) {
                localVarQueryParameter['resourceNameLike'] = resourceNameLike;
            }
            if (startableBy !== undefined) {
                localVarQueryParameter['startableBy'] = startableBy;
            }
            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }
            if (suspended !== undefined) {
                localVarQueryParameter['suspended'] = suspended;
            }
            if (incidentId !== undefined) {
                localVarQueryParameter['incidentId'] = incidentId;
            }
            if (incidentType !== undefined) {
                localVarQueryParameter['incidentType'] = incidentType;
            }
            if (incidentMessage !== undefined) {
                localVarQueryParameter['incidentMessage'] = incidentMessage;
            }
            if (incidentMessageLike !== undefined) {
                localVarQueryParameter['incidentMessageLike'] = incidentMessageLike;
            }
            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }
            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }
            if (includeProcessDefinitionsWithoutTenantId !== undefined) {
                localVarQueryParameter['includeProcessDefinitionsWithoutTenantId'] = includeProcessDefinitionsWithoutTenantId;
            }
            if (versionTag !== undefined) {
                localVarQueryParameter['versionTag'] = versionTag;
            }
            if (versionTagLike !== undefined) {
                localVarQueryParameter['versionTagLike'] = versionTagLike;
            }
            if (withoutVersionTag !== undefined) {
                localVarQueryParameter['withoutVersionTag'] = withoutVersionTag;
            }
            if (startableInTasklist !== undefined) {
                localVarQueryParameter['startableInTasklist'] = startableInTasklist;
            }
            if (notStartableInTasklist !== undefined) {
                localVarQueryParameter['notStartableInTasklist'] = notStartableInTasklist;
            }
            if (startablePermissionCheck !== undefined) {
                localVarQueryParameter['startablePermissionCheck'] = startablePermissionCheck;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }
            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }
            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requests the number of process definitions that fulfill the query criteria. Takes the same filtering parameters as the [Get Definitions](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/get-query/) method.
         * @summary Get List Count
         * @param {string} [processDefinitionId] Filter by process definition id.
         * @param {string} [processDefinitionIdIn] Filter by a comma-separated list of process definition ids.
         * @param {string} [name] Filter by process definition name.
         * @param {string} [nameLike] Filter by process definition names that the parameter is a substring of.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {string} [deployedAfter] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [deployedAt] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [key] Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match.
         * @param {string} [keysIn] Filter by a comma-separated list of process definition keys.
         * @param {string} [keyLike] Filter by process definition keys that the parameter is a substring of.
         * @param {string} [category] Filter by process definition category. Exact match.
         * @param {string} [categoryLike] Filter by process definition categories that the parameter is a substring of.
         * @param {number} [version] Filter by process definition version.
         * @param {boolean} [latestVersion] Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [resourceName] Filter by the name of the process definition resource. Exact match.
         * @param {string} [resourceNameLike] Filter by names of those process definition resources that the parameter is a substring of.
         * @param {string} [startableBy] Filter by a user name who is allowed to start the process.
         * @param {boolean} [active] Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior.
         * @param {boolean} [includeProcessDefinitionsWithoutTenantId] Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [versionTag] Filter by the version tag.
         * @param {string} [versionTagLike] Filter by the version tag that the parameter is a substring of.
         * @param {boolean} [withoutVersionTag] Only include process definitions without a &#x60;versionTag&#x60;.
         * @param {boolean} [startableInTasklist] Filter by process definitions which are startable in Tasklist..
         * @param {boolean} [notStartableInTasklist] Filter by process definitions which are not startable in Tasklist.
         * @param {boolean} [startablePermissionCheck] Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn\&#39;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionsCount: async (processDefinitionId, processDefinitionIdIn, name, nameLike, deploymentId, deployedAfter, deployedAt, key, keysIn, keyLike, category, categoryLike, version, latestVersion, resourceName, resourceNameLike, startableBy, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, includeProcessDefinitionsWithoutTenantId, versionTag, versionTagLike, withoutVersionTag, startableInTasklist, notStartableInTasklist, startablePermissionCheck, options = {}) => {
            const localVarPath = `/process-definition/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (processDefinitionId !== undefined) {
                localVarQueryParameter['processDefinitionId'] = processDefinitionId;
            }
            if (processDefinitionIdIn !== undefined) {
                localVarQueryParameter['processDefinitionIdIn'] = processDefinitionIdIn;
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (nameLike !== undefined) {
                localVarQueryParameter['nameLike'] = nameLike;
            }
            if (deploymentId !== undefined) {
                localVarQueryParameter['deploymentId'] = deploymentId;
            }
            if (deployedAfter !== undefined) {
                localVarQueryParameter['deployedAfter'] = (deployedAfter instanceof Date) ?
                    deployedAfter.toISOString() :
                    deployedAfter;
            }
            if (deployedAt !== undefined) {
                localVarQueryParameter['deployedAt'] = (deployedAt instanceof Date) ?
                    deployedAt.toISOString() :
                    deployedAt;
            }
            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }
            if (keysIn !== undefined) {
                localVarQueryParameter['keysIn'] = keysIn;
            }
            if (keyLike !== undefined) {
                localVarQueryParameter['keyLike'] = keyLike;
            }
            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }
            if (categoryLike !== undefined) {
                localVarQueryParameter['categoryLike'] = categoryLike;
            }
            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }
            if (latestVersion !== undefined) {
                localVarQueryParameter['latestVersion'] = latestVersion;
            }
            if (resourceName !== undefined) {
                localVarQueryParameter['resourceName'] = resourceName;
            }
            if (resourceNameLike !== undefined) {
                localVarQueryParameter['resourceNameLike'] = resourceNameLike;
            }
            if (startableBy !== undefined) {
                localVarQueryParameter['startableBy'] = startableBy;
            }
            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }
            if (suspended !== undefined) {
                localVarQueryParameter['suspended'] = suspended;
            }
            if (incidentId !== undefined) {
                localVarQueryParameter['incidentId'] = incidentId;
            }
            if (incidentType !== undefined) {
                localVarQueryParameter['incidentType'] = incidentType;
            }
            if (incidentMessage !== undefined) {
                localVarQueryParameter['incidentMessage'] = incidentMessage;
            }
            if (incidentMessageLike !== undefined) {
                localVarQueryParameter['incidentMessageLike'] = incidentMessageLike;
            }
            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }
            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }
            if (includeProcessDefinitionsWithoutTenantId !== undefined) {
                localVarQueryParameter['includeProcessDefinitionsWithoutTenantId'] = includeProcessDefinitionsWithoutTenantId;
            }
            if (versionTag !== undefined) {
                localVarQueryParameter['versionTag'] = versionTag;
            }
            if (versionTagLike !== undefined) {
                localVarQueryParameter['versionTagLike'] = versionTagLike;
            }
            if (withoutVersionTag !== undefined) {
                localVarQueryParameter['withoutVersionTag'] = withoutVersionTag;
            }
            if (startableInTasklist !== undefined) {
                localVarQueryParameter['startableInTasklist'] = startableInTasklist;
            }
            if (notStartableInTasklist !== undefined) {
                localVarQueryParameter['notStartableInTasklist'] = notStartableInTasklist;
            }
            if (startablePermissionCheck !== undefined) {
                localVarQueryParameter['startablePermissionCheck'] = startablePermissionCheck;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the rendered form for a process definition. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Start Form
         * @param {string} id The id of the process definition to get the rendered start form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRenderedStartForm: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getRenderedStartForm', 'id', id);
            const localVarPath = `/process-definition/{id}/rendered-form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves  the rendered form for the latest version of the process definition which belongs to no tenant. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRenderedStartFormByKey: async (key, options = {}) => {
            // verify required parameter 'key' is not null or undefined
            (0, common_1.assertParamExists)('getRenderedStartFormByKey', 'key', key);
            const localVarPath = `/process-definition/key/{key}/rendered-form`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves  the rendered form for the latest version of the process definition for a tenant. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRenderedStartFormByKeyAndTenantId: async (key, tenantId, options = {}) => {
            // verify required parameter 'key' is not null or undefined
            (0, common_1.assertParamExists)('getRenderedStartFormByKeyAndTenantId', 'key', key);
            // verify required parameter 'tenantId' is not null or undefined
            (0, common_1.assertParamExists)('getRenderedStartFormByKeyAndTenantId', 'tenantId', tenantId);
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}/rendered-form`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the key of the start form for a process definition. The form key corresponds to the `FormData#formKey` property in the engine.
         * @summary Get Start Form Key
         * @param {string} id The id of the process definition to get the start form key for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartForm: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getStartForm', 'id', id);
            const localVarPath = `/process-definition/{id}/startForm`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the key of the start form for the latest version of the process definition which belongs to no tenant. The form key corresponds to the `FormData#formKey` property in the engine.
         * @summary Get Start Form Key
         * @param {string} key The key of the process definition (the latest version thereof) for which the form key is to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormByKey: async (key, options = {}) => {
            // verify required parameter 'key' is not null or undefined
            (0, common_1.assertParamExists)('getStartFormByKey', 'key', key);
            const localVarPath = `/process-definition/key/{key}/startForm`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the key of the start form for the latest version of the process definition for a tenant. The form key corresponds to the `FormData#formKey` property in the engine.
         * @summary Get Start Form Key
         * @param {string} key The key of the process definition (the latest version thereof) for which the form key is to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormByKeyAndTenantId: async (key, tenantId, options = {}) => {
            // verify required parameter 'key' is not null or undefined
            (0, common_1.assertParamExists)('getStartFormByKeyAndTenantId', 'key', key);
            // verify required parameter 'tenantId' is not null or undefined
            (0, common_1.assertParamExists)('getStartFormByKeyAndTenantId', 'tenantId', tenantId);
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}/startForm`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the start form variables for a process definition (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Start Form Variables
         * @param {string} id The id of the process definition to retrieve the variables for.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormVariables: async (id, variableNames, deserializeValues, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getStartFormVariables', 'id', id);
            const localVarPath = `/process-definition/{id}/form-variables`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (variableNames !== undefined) {
                localVarQueryParameter['variableNames'] = variableNames;
            }
            if (deserializeValues !== undefined) {
                localVarQueryParameter['deserializeValues'] = deserializeValues;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the start form variables for the latest process definition which belongs to no tenant (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Start Form Variables
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormVariablesByKey: async (key, variableNames, deserializeValues, options = {}) => {
            // verify required parameter 'key' is not null or undefined
            (0, common_1.assertParamExists)('getStartFormVariablesByKey', 'key', key);
            const localVarPath = `/process-definition/key/{key}/form-variables`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (variableNames !== undefined) {
                localVarQueryParameter['variableNames'] = variableNames;
            }
            if (deserializeValues !== undefined) {
                localVarQueryParameter['deserializeValues'] = deserializeValues;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the start form variables for the latest process definition for a tenant (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Start Form Variables
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormVariablesByKeyAndTenantId: async (key, tenantId, variableNames, deserializeValues, options = {}) => {
            // verify required parameter 'key' is not null or undefined
            (0, common_1.assertParamExists)('getStartFormVariablesByKeyAndTenantId', 'key', key);
            // verify required parameter 'tenantId' is not null or undefined
            (0, common_1.assertParamExists)('getStartFormVariablesByKeyAndTenantId', 'tenantId', tenantId);
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}/form-variables`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (variableNames !== undefined) {
                localVarQueryParameter['variableNames'] = variableNames;
            }
            if (deserializeValues !== undefined) {
                localVarQueryParameter['deserializeValues'] = deserializeValues;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restarts process instances that were canceled or terminated synchronously. Can also restart completed process instances. It will create a new instance using the original instance information. To execute the restart asynchronously, use the [Restart Process Instance Async](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/post-restart-process-instance-async/) method.  For more information about the difference between synchronous and asynchronous execution, please refer to the related section of the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-restart/#execution).
         * @summary Restart Process Instance
         * @param {string} id The id of the process definition of the process instances to restart.
         * @param {RestartProcessInstanceDto} [restartProcessInstanceDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartProcessInstance: async (id, restartProcessInstanceDto, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('restartProcessInstance', 'id', id);
            const localVarPath = `/process-definition/{id}/restart`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(restartProcessInstanceDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restarts process instances that were canceled or terminated asynchronously. Can also restart completed process instances. It will create a new instance using the original instance information. To execute the restart asynchronously, use the [Restart Process Instance](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/post-restart-process-instance-sync/) method.  For more information about the difference between synchronous and asynchronous execution, please refer to the related section of the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-restart/#execution).
         * @summary Restart Process Instance Async
         * @param {string} id The id of the process definition of the process instances to restart.
         * @param {RestartProcessInstanceDto} [restartProcessInstanceDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartProcessInstanceAsyncOperation: async (id, restartProcessInstanceDto, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('restartProcessInstanceAsyncOperation', 'id', id);
            const localVarPath = `/process-definition/{id}/restart-async`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(restartProcessInstanceDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Instantiates a given process definition. Process variables and business key may be supplied in the request body.
         * @summary Start Instance
         * @param {string} id The id of the process definition to be retrieved.
         * @param {StartProcessInstanceDto} [startProcessInstanceDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProcessInstance: async (id, startProcessInstanceDto, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('startProcessInstance', 'id', id);
            const localVarPath = `/process-definition/{id}/start`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(startProcessInstanceDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Instantiates a given process definition, starts the latest version of the process definition which belongs to no tenant. Process variables and business key may be supplied in the request body.
         * @summary Start Instance
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {StartProcessInstanceDto} [startProcessInstanceDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProcessInstanceByKey: async (key, startProcessInstanceDto, options = {}) => {
            // verify required parameter 'key' is not null or undefined
            (0, common_1.assertParamExists)('startProcessInstanceByKey', 'key', key);
            const localVarPath = `/process-definition/key/{key}/start`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(startProcessInstanceDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Instantiates a given process definition, starts the latest version of the process definition for tenant. Process variables and business key may be supplied in the request body.
         * @summary Start Instance
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {StartProcessInstanceDto} [startProcessInstanceDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProcessInstanceByKeyAndTenantId: async (key, tenantId, startProcessInstanceDto, options = {}) => {
            // verify required parameter 'key' is not null or undefined
            (0, common_1.assertParamExists)('startProcessInstanceByKeyAndTenantId', 'key', key);
            // verify required parameter 'tenantId' is not null or undefined
            (0, common_1.assertParamExists)('startProcessInstanceByKeyAndTenantId', 'tenantId', tenantId);
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}/start`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(startProcessInstanceDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts a process instance using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Submit Start Form
         * @param {string} id The id of the process definition to submit the form for.
         * @param {StartProcessInstanceFormDto} [startProcessInstanceFormDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitForm: async (id, startProcessInstanceFormDto, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('submitForm', 'id', id);
            const localVarPath = `/process-definition/{id}/submit-form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(startProcessInstanceFormDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts the latest version of the process definition which belongs to no tenant using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Submit Start Form
         * @param {string} key The key of the process definition to submit the form for.
         * @param {StartProcessInstanceFormDto} [startProcessInstanceFormDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitFormByKey: async (key, startProcessInstanceFormDto, options = {}) => {
            // verify required parameter 'key' is not null or undefined
            (0, common_1.assertParamExists)('submitFormByKey', 'key', key);
            const localVarPath = `/process-definition/key/{key}/submit-form`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(startProcessInstanceFormDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts the latest version of the process definition for a tenant using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Submit Start Form
         * @param {string} key The key of the process definition to submit the form for.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {StartProcessInstanceFormDto} [startProcessInstanceFormDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitFormByKeyAndTenantId: async (key, tenantId, startProcessInstanceFormDto, options = {}) => {
            // verify required parameter 'key' is not null or undefined
            (0, common_1.assertParamExists)('submitFormByKeyAndTenantId', 'key', key);
            // verify required parameter 'tenantId' is not null or undefined
            (0, common_1.assertParamExists)('submitFormByKeyAndTenantId', 'tenantId', tenantId);
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}/submit-form`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(startProcessInstanceFormDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates history time to live for process definition. The field is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
         * @summary Update History Time to Live
         * @param {string} id The id of the process definition to change history time to live.
         * @param {HistoryTimeToLiveDto} [historyTimeToLiveDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHistoryTimeToLiveByProcessDefinitionId: async (id, historyTimeToLiveDto, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateHistoryTimeToLiveByProcessDefinitionId', 'id', id);
            const localVarPath = `/process-definition/{id}/history-time-to-live`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(historyTimeToLiveDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates history time to live for the latest version of the process definition which belongs to no tenant. The field is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
         * @summary Update History Time to Live
         * @param {string} key The key of the process definition to change history time to live.
         * @param {HistoryTimeToLiveDto} [historyTimeToLiveDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHistoryTimeToLiveByProcessDefinitionKey: async (key, historyTimeToLiveDto, options = {}) => {
            // verify required parameter 'key' is not null or undefined
            (0, common_1.assertParamExists)('updateHistoryTimeToLiveByProcessDefinitionKey', 'key', key);
            const localVarPath = `/process-definition/key/{key}/history-time-to-live`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(historyTimeToLiveDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates history time to live for the latest version of the process definition for a tenant. The field is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
         * @summary Update History Time to Live
         * @param {string} key The key of the process definition to change history time to live.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {HistoryTimeToLiveDto} [historyTimeToLiveDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId: async (key, tenantId, historyTimeToLiveDto, options = {}) => {
            // verify required parameter 'key' is not null or undefined
            (0, common_1.assertParamExists)('updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId', 'key', key);
            // verify required parameter 'tenantId' is not null or undefined
            (0, common_1.assertParamExists)('updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId', 'tenantId', tenantId);
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}/history-time-to-live`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(historyTimeToLiveDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activates or suspends process definitions with the given process definition key.
         * @summary Activate/Suspend By Key
         * @param {ProcessDefinitionSuspensionStateDto} [processDefinitionSuspensionStateDto] **Note**: Unallowed property is &#x60;processDefinitionId&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessDefinitionSuspensionState: async (processDefinitionSuspensionStateDto, options = {}) => {
            const localVarPath = `/process-definition/suspended`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(processDefinitionSuspensionStateDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activates or suspends a given process definition by id.
         * @summary Activate/Suspend By Id
         * @param {string} id The id of the process definition to activate or suspend.
         * @param {ProcessDefinitionSuspensionStateDto} [processDefinitionSuspensionStateDto] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessDefinitionSuspensionStateById: async (id, processDefinitionSuspensionStateDto, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateProcessDefinitionSuspensionStateById', 'id', id);
            const localVarPath = `/process-definition/{id}/suspended`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(processDefinitionSuspensionStateDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activates or suspends a given process definition by latest version of process definition key which belongs to no tenant.
         * @summary Activate/Suspend by Id
         * @param {string} key The key of the process definition (the latest version thereof) to be activated/suspended.
         * @param {ProcessDefinitionSuspensionStateDto} [processDefinitionSuspensionStateDto] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessDefinitionSuspensionStateByKey: async (key, processDefinitionSuspensionStateDto, options = {}) => {
            // verify required parameter 'key' is not null or undefined
            (0, common_1.assertParamExists)('updateProcessDefinitionSuspensionStateByKey', 'key', key);
            const localVarPath = `/process-definition/key/{key}/suspended`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(processDefinitionSuspensionStateDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activates or suspends a given process definition by the latest version of the process definition for tenant.
         * @summary Activate/Suspend by Id
         * @param {string} key The key of the process definition (the latest version thereof) to be activated/suspended.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {ProcessDefinitionSuspensionStateDto} [processDefinitionSuspensionStateDto] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessDefinitionSuspensionStateByKeyAndTenantId: async (key, tenantId, processDefinitionSuspensionStateDto, options = {}) => {
            // verify required parameter 'key' is not null or undefined
            (0, common_1.assertParamExists)('updateProcessDefinitionSuspensionStateByKeyAndTenantId', 'key', key);
            // verify required parameter 'tenantId' is not null or undefined
            (0, common_1.assertParamExists)('updateProcessDefinitionSuspensionStateByKeyAndTenantId', 'tenantId', tenantId);
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}/suspended`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(processDefinitionSuspensionStateDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.ProcessDefinitionApiAxiosParamCreator = ProcessDefinitionApiAxiosParamCreator;
/**
 * ProcessDefinitionApi - functional programming interface
 * @export
 */
const ProcessDefinitionApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ProcessDefinitionApiAxiosParamCreator)(configuration);
    return {
        /**
         * Deletes a running process instance by id.
         * @summary Delete
         * @param {string} id The id of the process definition to be deleted.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProcessDefinition(id, cascade, skipCustomListeners, skipIoMappings, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProcessDefinition(id, cascade, skipCustomListeners, skipIoMappings, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Deletes process definitions by a given key which belong to no tenant id.
         * @summary Delete By Key
         * @param {string} key The key of the process definitions to be deleted.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProcessDefinitionsByKey(key, cascade, skipCustomListeners, skipIoMappings, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProcessDefinitionsByKey(key, cascade, skipCustomListeners, skipIoMappings, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Deletes process definitions by a given key and which belong to a tenant id.
         * @summary Delete By Key
         * @param {string} key The key of the process definitions to be deleted.
         * @param {string} tenantId The id of the tenant the process definitions belong to.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProcessDefinitionsByKeyAndTenantId(key, tenantId, cascade, skipCustomListeners, skipIoMappings, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProcessDefinitionsByKeyAndTenantId(key, tenantId, cascade, skipCustomListeners, skipIoMappings, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves runtime statistics of a given process definition, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Activity Instance Statistics
         * @param {string} id The id of the process definition.
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivityStatistics(id, failedJobs, incidents, incidentsForType, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivityStatistics(id, failedJobs, incidents, incidentsForType, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves runtime statistics of the latest version of the given process definition which belongs to no tenant, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Activity Instance Statistics
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivityStatisticsByProcessDefinitionKey(key, failedJobs, incidents, incidentsForType, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivityStatisticsByProcessDefinitionKey(key, failedJobs, incidents, incidentsForType, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves runtime statistics of the latest version of the given process definition for a tenant, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Activity Instance Statistics
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivityStatisticsByProcessDefinitionKeyAndTenantId(key, tenantId, failedJobs, incidents, incidentsForType, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivityStatisticsByProcessDefinitionKeyAndTenantId(key, tenantId, failedJobs, incidents, incidentsForType, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Start Form
         * @param {string} id The id of the process definition to get the deployed start form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeployedStartForm(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeployedStartForm(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeployedStartFormByKey(key, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeployedStartFormByKey(key, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definitions belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeployedStartFormByKeyAndTenantId(key, tenantId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeployedStartFormByKeyAndTenantId(key, tenantId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves the latest version of the process definition for tenant according to the `ProcessDefinition` interface in the engine.
         * @summary Get
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestProcessDefinitionByTenantId(key, tenantId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestProcessDefinitionByTenantId(key, tenantId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves a process definition according to the `ProcessDefinition` interface in the engine.
         * @summary Get
         * @param {string} id The id of the process definition to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinition(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessDefinition(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves the BPMN 2.0 XML of a process definition.
         * @summary Get XML
         * @param {string} id The id of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitionBpmn20Xml(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessDefinitionBpmn20Xml(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves latest version the BPMN 2.0 XML of a process definition.
         * @summary Get XML
         * @param {string} key The key of the process definition (the latest version thereof) whose XML should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitionBpmn20XmlByKey(key, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessDefinitionBpmn20XmlByKey(key, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves latest version the BPMN 2.0 XML of a process definition. Returns the XML for the latest version of the process definition for tenant.
         * @summary Get XML
         * @param {string} key The key of the process definition (the latest version thereof) whose XML should be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitionBpmn20XmlByKeyAndTenantId(key, tenantId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessDefinitionBpmn20XmlByKeyAndTenantId(key, tenantId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves the latest version of the process definition which belongs to no tenant according to the `ProcessDefinition` interface in the engine.
         * @summary Get
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitionByKey(key, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessDefinitionByKey(key, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves the diagram of a process definition.  If the process definition\'s deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
         * @summary Get Diagram
         * @param {string} id The id of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitionDiagram(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessDefinitionDiagram(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves the diagram for the latest version of the process definition which belongs to no tenant.  If the process definition\'s deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
         * @summary Get Diagram
         * @param {string} key The key of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitionDiagramByKey(key, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessDefinitionDiagramByKey(key, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves the diagram for the latest version of the process definition for tenant.  If the process definition\'s deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
         * @summary Get Diagram
         * @param {string} key The key of the process definition.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitionDiagramByKeyAndTenantId(key, tenantId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessDefinitionDiagramByKeyAndTenantId(key, tenantId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves runtime statistics of the process engine, grouped by process definitions. These statistics include the number of running process instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Process Instance Statistics
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {boolean} [rootIncidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of root incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60; or &#x60;incidents&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitionStatistics(failedJobs, incidents, incidentsForType, rootIncidents, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessDefinitionStatistics(failedJobs, incidents, incidentsForType, rootIncidents, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Queries for process definitions that fulfill given parameters. Parameters may be the properties of  process definitions, such as the name, key or version. The size of the result set can be retrieved by using the [Get Definition Count](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/get-query-count/) method.
         * @summary Get List
         * @param {string} [processDefinitionId] Filter by process definition id.
         * @param {string} [processDefinitionIdIn] Filter by a comma-separated list of process definition ids.
         * @param {string} [name] Filter by process definition name.
         * @param {string} [nameLike] Filter by process definition names that the parameter is a substring of.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {string} [deployedAfter] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [deployedAt] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [key] Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match.
         * @param {string} [keysIn] Filter by a comma-separated list of process definition keys.
         * @param {string} [keyLike] Filter by process definition keys that the parameter is a substring of.
         * @param {string} [category] Filter by process definition category. Exact match.
         * @param {string} [categoryLike] Filter by process definition categories that the parameter is a substring of.
         * @param {number} [version] Filter by process definition version.
         * @param {boolean} [latestVersion] Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [resourceName] Filter by the name of the process definition resource. Exact match.
         * @param {string} [resourceNameLike] Filter by names of those process definition resources that the parameter is a substring of.
         * @param {string} [startableBy] Filter by a user name who is allowed to start the process.
         * @param {boolean} [active] Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior.
         * @param {boolean} [includeProcessDefinitionsWithoutTenantId] Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [versionTag] Filter by the version tag.
         * @param {string} [versionTagLike] Filter by the version tag that the parameter is a substring of.
         * @param {boolean} [withoutVersionTag] Only include process definitions without a &#x60;versionTag&#x60;.
         * @param {boolean} [startableInTasklist] Filter by process definitions which are startable in Tasklist..
         * @param {boolean} [notStartableInTasklist] Filter by process definitions which are not startable in Tasklist.
         * @param {boolean} [startablePermissionCheck] Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn\&#39;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level
         * @param {'category' | 'key' | 'id' | 'name' | 'version' | 'deploymentId' | 'deployTime' | 'tenantId ' | 'versionTag'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitions(processDefinitionId, processDefinitionIdIn, name, nameLike, deploymentId, deployedAfter, deployedAt, key, keysIn, keyLike, category, categoryLike, version, latestVersion, resourceName, resourceNameLike, startableBy, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, includeProcessDefinitionsWithoutTenantId, versionTag, versionTagLike, withoutVersionTag, startableInTasklist, notStartableInTasklist, startablePermissionCheck, sortBy, sortOrder, firstResult, maxResults, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessDefinitions(processDefinitionId, processDefinitionIdIn, name, nameLike, deploymentId, deployedAfter, deployedAt, key, keysIn, keyLike, category, categoryLike, version, latestVersion, resourceName, resourceNameLike, startableBy, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, includeProcessDefinitionsWithoutTenantId, versionTag, versionTagLike, withoutVersionTag, startableInTasklist, notStartableInTasklist, startablePermissionCheck, sortBy, sortOrder, firstResult, maxResults, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Requests the number of process definitions that fulfill the query criteria. Takes the same filtering parameters as the [Get Definitions](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/get-query/) method.
         * @summary Get List Count
         * @param {string} [processDefinitionId] Filter by process definition id.
         * @param {string} [processDefinitionIdIn] Filter by a comma-separated list of process definition ids.
         * @param {string} [name] Filter by process definition name.
         * @param {string} [nameLike] Filter by process definition names that the parameter is a substring of.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {string} [deployedAfter] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [deployedAt] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [key] Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match.
         * @param {string} [keysIn] Filter by a comma-separated list of process definition keys.
         * @param {string} [keyLike] Filter by process definition keys that the parameter is a substring of.
         * @param {string} [category] Filter by process definition category. Exact match.
         * @param {string} [categoryLike] Filter by process definition categories that the parameter is a substring of.
         * @param {number} [version] Filter by process definition version.
         * @param {boolean} [latestVersion] Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [resourceName] Filter by the name of the process definition resource. Exact match.
         * @param {string} [resourceNameLike] Filter by names of those process definition resources that the parameter is a substring of.
         * @param {string} [startableBy] Filter by a user name who is allowed to start the process.
         * @param {boolean} [active] Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior.
         * @param {boolean} [includeProcessDefinitionsWithoutTenantId] Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [versionTag] Filter by the version tag.
         * @param {string} [versionTagLike] Filter by the version tag that the parameter is a substring of.
         * @param {boolean} [withoutVersionTag] Only include process definitions without a &#x60;versionTag&#x60;.
         * @param {boolean} [startableInTasklist] Filter by process definitions which are startable in Tasklist..
         * @param {boolean} [notStartableInTasklist] Filter by process definitions which are not startable in Tasklist.
         * @param {boolean} [startablePermissionCheck] Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn\&#39;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitionsCount(processDefinitionId, processDefinitionIdIn, name, nameLike, deploymentId, deployedAfter, deployedAt, key, keysIn, keyLike, category, categoryLike, version, latestVersion, resourceName, resourceNameLike, startableBy, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, includeProcessDefinitionsWithoutTenantId, versionTag, versionTagLike, withoutVersionTag, startableInTasklist, notStartableInTasklist, startablePermissionCheck, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessDefinitionsCount(processDefinitionId, processDefinitionIdIn, name, nameLike, deploymentId, deployedAfter, deployedAt, key, keysIn, keyLike, category, categoryLike, version, latestVersion, resourceName, resourceNameLike, startableBy, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, includeProcessDefinitionsWithoutTenantId, versionTag, versionTagLike, withoutVersionTag, startableInTasklist, notStartableInTasklist, startablePermissionCheck, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves the rendered form for a process definition. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Start Form
         * @param {string} id The id of the process definition to get the rendered start form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRenderedStartForm(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRenderedStartForm(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves  the rendered form for the latest version of the process definition which belongs to no tenant. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRenderedStartFormByKey(key, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRenderedStartFormByKey(key, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves  the rendered form for the latest version of the process definition for a tenant. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRenderedStartFormByKeyAndTenantId(key, tenantId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRenderedStartFormByKeyAndTenantId(key, tenantId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves the key of the start form for a process definition. The form key corresponds to the `FormData#formKey` property in the engine.
         * @summary Get Start Form Key
         * @param {string} id The id of the process definition to get the start form key for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStartForm(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStartForm(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves the key of the start form for the latest version of the process definition which belongs to no tenant. The form key corresponds to the `FormData#formKey` property in the engine.
         * @summary Get Start Form Key
         * @param {string} key The key of the process definition (the latest version thereof) for which the form key is to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStartFormByKey(key, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStartFormByKey(key, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves the key of the start form for the latest version of the process definition for a tenant. The form key corresponds to the `FormData#formKey` property in the engine.
         * @summary Get Start Form Key
         * @param {string} key The key of the process definition (the latest version thereof) for which the form key is to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStartFormByKeyAndTenantId(key, tenantId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStartFormByKeyAndTenantId(key, tenantId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves the start form variables for a process definition (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Start Form Variables
         * @param {string} id The id of the process definition to retrieve the variables for.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStartFormVariables(id, variableNames, deserializeValues, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStartFormVariables(id, variableNames, deserializeValues, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves the start form variables for the latest process definition which belongs to no tenant (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Start Form Variables
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStartFormVariablesByKey(key, variableNames, deserializeValues, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStartFormVariablesByKey(key, variableNames, deserializeValues, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves the start form variables for the latest process definition for a tenant (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Start Form Variables
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStartFormVariablesByKeyAndTenantId(key, tenantId, variableNames, deserializeValues, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStartFormVariablesByKeyAndTenantId(key, tenantId, variableNames, deserializeValues, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Restarts process instances that were canceled or terminated synchronously. Can also restart completed process instances. It will create a new instance using the original instance information. To execute the restart asynchronously, use the [Restart Process Instance Async](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/post-restart-process-instance-async/) method.  For more information about the difference between synchronous and asynchronous execution, please refer to the related section of the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-restart/#execution).
         * @summary Restart Process Instance
         * @param {string} id The id of the process definition of the process instances to restart.
         * @param {RestartProcessInstanceDto} [restartProcessInstanceDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restartProcessInstance(id, restartProcessInstanceDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restartProcessInstance(id, restartProcessInstanceDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Restarts process instances that were canceled or terminated asynchronously. Can also restart completed process instances. It will create a new instance using the original instance information. To execute the restart asynchronously, use the [Restart Process Instance](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/post-restart-process-instance-sync/) method.  For more information about the difference between synchronous and asynchronous execution, please refer to the related section of the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-restart/#execution).
         * @summary Restart Process Instance Async
         * @param {string} id The id of the process definition of the process instances to restart.
         * @param {RestartProcessInstanceDto} [restartProcessInstanceDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restartProcessInstanceAsyncOperation(id, restartProcessInstanceDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restartProcessInstanceAsyncOperation(id, restartProcessInstanceDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Instantiates a given process definition. Process variables and business key may be supplied in the request body.
         * @summary Start Instance
         * @param {string} id The id of the process definition to be retrieved.
         * @param {StartProcessInstanceDto} [startProcessInstanceDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startProcessInstance(id, startProcessInstanceDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startProcessInstance(id, startProcessInstanceDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Instantiates a given process definition, starts the latest version of the process definition which belongs to no tenant. Process variables and business key may be supplied in the request body.
         * @summary Start Instance
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {StartProcessInstanceDto} [startProcessInstanceDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startProcessInstanceByKey(key, startProcessInstanceDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startProcessInstanceByKey(key, startProcessInstanceDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Instantiates a given process definition, starts the latest version of the process definition for tenant. Process variables and business key may be supplied in the request body.
         * @summary Start Instance
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {StartProcessInstanceDto} [startProcessInstanceDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startProcessInstanceByKeyAndTenantId(key, tenantId, startProcessInstanceDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startProcessInstanceByKeyAndTenantId(key, tenantId, startProcessInstanceDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Starts a process instance using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Submit Start Form
         * @param {string} id The id of the process definition to submit the form for.
         * @param {StartProcessInstanceFormDto} [startProcessInstanceFormDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitForm(id, startProcessInstanceFormDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitForm(id, startProcessInstanceFormDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Starts the latest version of the process definition which belongs to no tenant using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Submit Start Form
         * @param {string} key The key of the process definition to submit the form for.
         * @param {StartProcessInstanceFormDto} [startProcessInstanceFormDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitFormByKey(key, startProcessInstanceFormDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitFormByKey(key, startProcessInstanceFormDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Starts the latest version of the process definition for a tenant using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Submit Start Form
         * @param {string} key The key of the process definition to submit the form for.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {StartProcessInstanceFormDto} [startProcessInstanceFormDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitFormByKeyAndTenantId(key, tenantId, startProcessInstanceFormDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitFormByKeyAndTenantId(key, tenantId, startProcessInstanceFormDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Updates history time to live for process definition. The field is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
         * @summary Update History Time to Live
         * @param {string} id The id of the process definition to change history time to live.
         * @param {HistoryTimeToLiveDto} [historyTimeToLiveDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateHistoryTimeToLiveByProcessDefinitionId(id, historyTimeToLiveDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateHistoryTimeToLiveByProcessDefinitionId(id, historyTimeToLiveDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Updates history time to live for the latest version of the process definition which belongs to no tenant. The field is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
         * @summary Update History Time to Live
         * @param {string} key The key of the process definition to change history time to live.
         * @param {HistoryTimeToLiveDto} [historyTimeToLiveDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateHistoryTimeToLiveByProcessDefinitionKey(key, historyTimeToLiveDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateHistoryTimeToLiveByProcessDefinitionKey(key, historyTimeToLiveDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Updates history time to live for the latest version of the process definition for a tenant. The field is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
         * @summary Update History Time to Live
         * @param {string} key The key of the process definition to change history time to live.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {HistoryTimeToLiveDto} [historyTimeToLiveDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId(key, tenantId, historyTimeToLiveDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId(key, tenantId, historyTimeToLiveDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Activates or suspends process definitions with the given process definition key.
         * @summary Activate/Suspend By Key
         * @param {ProcessDefinitionSuspensionStateDto} [processDefinitionSuspensionStateDto] **Note**: Unallowed property is &#x60;processDefinitionId&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProcessDefinitionSuspensionState(processDefinitionSuspensionStateDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProcessDefinitionSuspensionState(processDefinitionSuspensionStateDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Activates or suspends a given process definition by id.
         * @summary Activate/Suspend By Id
         * @param {string} id The id of the process definition to activate or suspend.
         * @param {ProcessDefinitionSuspensionStateDto} [processDefinitionSuspensionStateDto] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProcessDefinitionSuspensionStateById(id, processDefinitionSuspensionStateDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProcessDefinitionSuspensionStateById(id, processDefinitionSuspensionStateDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Activates or suspends a given process definition by latest version of process definition key which belongs to no tenant.
         * @summary Activate/Suspend by Id
         * @param {string} key The key of the process definition (the latest version thereof) to be activated/suspended.
         * @param {ProcessDefinitionSuspensionStateDto} [processDefinitionSuspensionStateDto] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProcessDefinitionSuspensionStateByKey(key, processDefinitionSuspensionStateDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProcessDefinitionSuspensionStateByKey(key, processDefinitionSuspensionStateDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Activates or suspends a given process definition by the latest version of the process definition for tenant.
         * @summary Activate/Suspend by Id
         * @param {string} key The key of the process definition (the latest version thereof) to be activated/suspended.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {ProcessDefinitionSuspensionStateDto} [processDefinitionSuspensionStateDto] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProcessDefinitionSuspensionStateByKeyAndTenantId(key, tenantId, processDefinitionSuspensionStateDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProcessDefinitionSuspensionStateByKeyAndTenantId(key, tenantId, processDefinitionSuspensionStateDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.ProcessDefinitionApiFp = ProcessDefinitionApiFp;
/**
 * ProcessDefinitionApi - factory interface
 * @export
 */
const ProcessDefinitionApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ProcessDefinitionApiFp)(configuration);
    return {
        /**
         * Deletes a running process instance by id.
         * @summary Delete
         * @param {string} id The id of the process definition to be deleted.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessDefinition(id, cascade, skipCustomListeners, skipIoMappings, options) {
            return localVarFp.deleteProcessDefinition(id, cascade, skipCustomListeners, skipIoMappings, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes process definitions by a given key which belong to no tenant id.
         * @summary Delete By Key
         * @param {string} key The key of the process definitions to be deleted.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessDefinitionsByKey(key, cascade, skipCustomListeners, skipIoMappings, options) {
            return localVarFp.deleteProcessDefinitionsByKey(key, cascade, skipCustomListeners, skipIoMappings, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes process definitions by a given key and which belong to a tenant id.
         * @summary Delete By Key
         * @param {string} key The key of the process definitions to be deleted.
         * @param {string} tenantId The id of the tenant the process definitions belong to.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessDefinitionsByKeyAndTenantId(key, tenantId, cascade, skipCustomListeners, skipIoMappings, options) {
            return localVarFp.deleteProcessDefinitionsByKeyAndTenantId(key, tenantId, cascade, skipCustomListeners, skipIoMappings, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves runtime statistics of a given process definition, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Activity Instance Statistics
         * @param {string} id The id of the process definition.
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityStatistics(id, failedJobs, incidents, incidentsForType, options) {
            return localVarFp.getActivityStatistics(id, failedJobs, incidents, incidentsForType, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves runtime statistics of the latest version of the given process definition which belongs to no tenant, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Activity Instance Statistics
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityStatisticsByProcessDefinitionKey(key, failedJobs, incidents, incidentsForType, options) {
            return localVarFp.getActivityStatisticsByProcessDefinitionKey(key, failedJobs, incidents, incidentsForType, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves runtime statistics of the latest version of the given process definition for a tenant, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Activity Instance Statistics
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityStatisticsByProcessDefinitionKeyAndTenantId(key, tenantId, failedJobs, incidents, incidentsForType, options) {
            return localVarFp.getActivityStatisticsByProcessDefinitionKeyAndTenantId(key, tenantId, failedJobs, incidents, incidentsForType, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Start Form
         * @param {string} id The id of the process definition to get the deployed start form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedStartForm(id, options) {
            return localVarFp.getDeployedStartForm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedStartFormByKey(key, options) {
            return localVarFp.getDeployedStartFormByKey(key, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definitions belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedStartFormByKeyAndTenantId(key, tenantId, options) {
            return localVarFp.getDeployedStartFormByKeyAndTenantId(key, tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the latest version of the process definition for tenant according to the `ProcessDefinition` interface in the engine.
         * @summary Get
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestProcessDefinitionByTenantId(key, tenantId, options) {
            return localVarFp.getLatestProcessDefinitionByTenantId(key, tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a process definition according to the `ProcessDefinition` interface in the engine.
         * @summary Get
         * @param {string} id The id of the process definition to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinition(id, options) {
            return localVarFp.getProcessDefinition(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the BPMN 2.0 XML of a process definition.
         * @summary Get XML
         * @param {string} id The id of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionBpmn20Xml(id, options) {
            return localVarFp.getProcessDefinitionBpmn20Xml(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves latest version the BPMN 2.0 XML of a process definition.
         * @summary Get XML
         * @param {string} key The key of the process definition (the latest version thereof) whose XML should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionBpmn20XmlByKey(key, options) {
            return localVarFp.getProcessDefinitionBpmn20XmlByKey(key, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves latest version the BPMN 2.0 XML of a process definition. Returns the XML for the latest version of the process definition for tenant.
         * @summary Get XML
         * @param {string} key The key of the process definition (the latest version thereof) whose XML should be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionBpmn20XmlByKeyAndTenantId(key, tenantId, options) {
            return localVarFp.getProcessDefinitionBpmn20XmlByKeyAndTenantId(key, tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the latest version of the process definition which belongs to no tenant according to the `ProcessDefinition` interface in the engine.
         * @summary Get
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionByKey(key, options) {
            return localVarFp.getProcessDefinitionByKey(key, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the diagram of a process definition.  If the process definition\'s deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
         * @summary Get Diagram
         * @param {string} id The id of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionDiagram(id, options) {
            return localVarFp.getProcessDefinitionDiagram(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the diagram for the latest version of the process definition which belongs to no tenant.  If the process definition\'s deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
         * @summary Get Diagram
         * @param {string} key The key of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionDiagramByKey(key, options) {
            return localVarFp.getProcessDefinitionDiagramByKey(key, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the diagram for the latest version of the process definition for tenant.  If the process definition\'s deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
         * @summary Get Diagram
         * @param {string} key The key of the process definition.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionDiagramByKeyAndTenantId(key, tenantId, options) {
            return localVarFp.getProcessDefinitionDiagramByKeyAndTenantId(key, tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves runtime statistics of the process engine, grouped by process definitions. These statistics include the number of running process instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Process Instance Statistics
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {boolean} [rootIncidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of root incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60; or &#x60;incidents&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionStatistics(failedJobs, incidents, incidentsForType, rootIncidents, options) {
            return localVarFp.getProcessDefinitionStatistics(failedJobs, incidents, incidentsForType, rootIncidents, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for process definitions that fulfill given parameters. Parameters may be the properties of  process definitions, such as the name, key or version. The size of the result set can be retrieved by using the [Get Definition Count](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/get-query-count/) method.
         * @summary Get List
         * @param {string} [processDefinitionId] Filter by process definition id.
         * @param {string} [processDefinitionIdIn] Filter by a comma-separated list of process definition ids.
         * @param {string} [name] Filter by process definition name.
         * @param {string} [nameLike] Filter by process definition names that the parameter is a substring of.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {string} [deployedAfter] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [deployedAt] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [key] Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match.
         * @param {string} [keysIn] Filter by a comma-separated list of process definition keys.
         * @param {string} [keyLike] Filter by process definition keys that the parameter is a substring of.
         * @param {string} [category] Filter by process definition category. Exact match.
         * @param {string} [categoryLike] Filter by process definition categories that the parameter is a substring of.
         * @param {number} [version] Filter by process definition version.
         * @param {boolean} [latestVersion] Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [resourceName] Filter by the name of the process definition resource. Exact match.
         * @param {string} [resourceNameLike] Filter by names of those process definition resources that the parameter is a substring of.
         * @param {string} [startableBy] Filter by a user name who is allowed to start the process.
         * @param {boolean} [active] Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior.
         * @param {boolean} [includeProcessDefinitionsWithoutTenantId] Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [versionTag] Filter by the version tag.
         * @param {string} [versionTagLike] Filter by the version tag that the parameter is a substring of.
         * @param {boolean} [withoutVersionTag] Only include process definitions without a &#x60;versionTag&#x60;.
         * @param {boolean} [startableInTasklist] Filter by process definitions which are startable in Tasklist..
         * @param {boolean} [notStartableInTasklist] Filter by process definitions which are not startable in Tasklist.
         * @param {boolean} [startablePermissionCheck] Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn\&#39;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level
         * @param {'category' | 'key' | 'id' | 'name' | 'version' | 'deploymentId' | 'deployTime' | 'tenantId ' | 'versionTag'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitions(processDefinitionId, processDefinitionIdIn, name, nameLike, deploymentId, deployedAfter, deployedAt, key, keysIn, keyLike, category, categoryLike, version, latestVersion, resourceName, resourceNameLike, startableBy, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, includeProcessDefinitionsWithoutTenantId, versionTag, versionTagLike, withoutVersionTag, startableInTasklist, notStartableInTasklist, startablePermissionCheck, sortBy, sortOrder, firstResult, maxResults, options) {
            return localVarFp.getProcessDefinitions(processDefinitionId, processDefinitionIdIn, name, nameLike, deploymentId, deployedAfter, deployedAt, key, keysIn, keyLike, category, categoryLike, version, latestVersion, resourceName, resourceNameLike, startableBy, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, includeProcessDefinitionsWithoutTenantId, versionTag, versionTagLike, withoutVersionTag, startableInTasklist, notStartableInTasklist, startablePermissionCheck, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(axios, basePath));
        },
        /**
         * Requests the number of process definitions that fulfill the query criteria. Takes the same filtering parameters as the [Get Definitions](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/get-query/) method.
         * @summary Get List Count
         * @param {string} [processDefinitionId] Filter by process definition id.
         * @param {string} [processDefinitionIdIn] Filter by a comma-separated list of process definition ids.
         * @param {string} [name] Filter by process definition name.
         * @param {string} [nameLike] Filter by process definition names that the parameter is a substring of.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {string} [deployedAfter] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [deployedAt] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [key] Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match.
         * @param {string} [keysIn] Filter by a comma-separated list of process definition keys.
         * @param {string} [keyLike] Filter by process definition keys that the parameter is a substring of.
         * @param {string} [category] Filter by process definition category. Exact match.
         * @param {string} [categoryLike] Filter by process definition categories that the parameter is a substring of.
         * @param {number} [version] Filter by process definition version.
         * @param {boolean} [latestVersion] Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [resourceName] Filter by the name of the process definition resource. Exact match.
         * @param {string} [resourceNameLike] Filter by names of those process definition resources that the parameter is a substring of.
         * @param {string} [startableBy] Filter by a user name who is allowed to start the process.
         * @param {boolean} [active] Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior.
         * @param {boolean} [includeProcessDefinitionsWithoutTenantId] Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [versionTag] Filter by the version tag.
         * @param {string} [versionTagLike] Filter by the version tag that the parameter is a substring of.
         * @param {boolean} [withoutVersionTag] Only include process definitions without a &#x60;versionTag&#x60;.
         * @param {boolean} [startableInTasklist] Filter by process definitions which are startable in Tasklist..
         * @param {boolean} [notStartableInTasklist] Filter by process definitions which are not startable in Tasklist.
         * @param {boolean} [startablePermissionCheck] Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn\&#39;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionsCount(processDefinitionId, processDefinitionIdIn, name, nameLike, deploymentId, deployedAfter, deployedAt, key, keysIn, keyLike, category, categoryLike, version, latestVersion, resourceName, resourceNameLike, startableBy, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, includeProcessDefinitionsWithoutTenantId, versionTag, versionTagLike, withoutVersionTag, startableInTasklist, notStartableInTasklist, startablePermissionCheck, options) {
            return localVarFp.getProcessDefinitionsCount(processDefinitionId, processDefinitionIdIn, name, nameLike, deploymentId, deployedAfter, deployedAt, key, keysIn, keyLike, category, categoryLike, version, latestVersion, resourceName, resourceNameLike, startableBy, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, includeProcessDefinitionsWithoutTenantId, versionTag, versionTagLike, withoutVersionTag, startableInTasklist, notStartableInTasklist, startablePermissionCheck, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the rendered form for a process definition. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Start Form
         * @param {string} id The id of the process definition to get the rendered start form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRenderedStartForm(id, options) {
            return localVarFp.getRenderedStartForm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves  the rendered form for the latest version of the process definition which belongs to no tenant. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRenderedStartFormByKey(key, options) {
            return localVarFp.getRenderedStartFormByKey(key, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves  the rendered form for the latest version of the process definition for a tenant. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRenderedStartFormByKeyAndTenantId(key, tenantId, options) {
            return localVarFp.getRenderedStartFormByKeyAndTenantId(key, tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the key of the start form for a process definition. The form key corresponds to the `FormData#formKey` property in the engine.
         * @summary Get Start Form Key
         * @param {string} id The id of the process definition to get the start form key for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartForm(id, options) {
            return localVarFp.getStartForm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the key of the start form for the latest version of the process definition which belongs to no tenant. The form key corresponds to the `FormData#formKey` property in the engine.
         * @summary Get Start Form Key
         * @param {string} key The key of the process definition (the latest version thereof) for which the form key is to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormByKey(key, options) {
            return localVarFp.getStartFormByKey(key, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the key of the start form for the latest version of the process definition for a tenant. The form key corresponds to the `FormData#formKey` property in the engine.
         * @summary Get Start Form Key
         * @param {string} key The key of the process definition (the latest version thereof) for which the form key is to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormByKeyAndTenantId(key, tenantId, options) {
            return localVarFp.getStartFormByKeyAndTenantId(key, tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the start form variables for a process definition (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Start Form Variables
         * @param {string} id The id of the process definition to retrieve the variables for.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormVariables(id, variableNames, deserializeValues, options) {
            return localVarFp.getStartFormVariables(id, variableNames, deserializeValues, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the start form variables for the latest process definition which belongs to no tenant (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Start Form Variables
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormVariablesByKey(key, variableNames, deserializeValues, options) {
            return localVarFp.getStartFormVariablesByKey(key, variableNames, deserializeValues, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the start form variables for the latest process definition for a tenant (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Start Form Variables
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormVariablesByKeyAndTenantId(key, tenantId, variableNames, deserializeValues, options) {
            return localVarFp.getStartFormVariablesByKeyAndTenantId(key, tenantId, variableNames, deserializeValues, options).then((request) => request(axios, basePath));
        },
        /**
         * Restarts process instances that were canceled or terminated synchronously. Can also restart completed process instances. It will create a new instance using the original instance information. To execute the restart asynchronously, use the [Restart Process Instance Async](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/post-restart-process-instance-async/) method.  For more information about the difference between synchronous and asynchronous execution, please refer to the related section of the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-restart/#execution).
         * @summary Restart Process Instance
         * @param {string} id The id of the process definition of the process instances to restart.
         * @param {RestartProcessInstanceDto} [restartProcessInstanceDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartProcessInstance(id, restartProcessInstanceDto, options) {
            return localVarFp.restartProcessInstance(id, restartProcessInstanceDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Restarts process instances that were canceled or terminated asynchronously. Can also restart completed process instances. It will create a new instance using the original instance information. To execute the restart asynchronously, use the [Restart Process Instance](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/post-restart-process-instance-sync/) method.  For more information about the difference between synchronous and asynchronous execution, please refer to the related section of the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-restart/#execution).
         * @summary Restart Process Instance Async
         * @param {string} id The id of the process definition of the process instances to restart.
         * @param {RestartProcessInstanceDto} [restartProcessInstanceDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartProcessInstanceAsyncOperation(id, restartProcessInstanceDto, options) {
            return localVarFp.restartProcessInstanceAsyncOperation(id, restartProcessInstanceDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Instantiates a given process definition. Process variables and business key may be supplied in the request body.
         * @summary Start Instance
         * @param {string} id The id of the process definition to be retrieved.
         * @param {StartProcessInstanceDto} [startProcessInstanceDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProcessInstance(id, startProcessInstanceDto, options) {
            return localVarFp.startProcessInstance(id, startProcessInstanceDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Instantiates a given process definition, starts the latest version of the process definition which belongs to no tenant. Process variables and business key may be supplied in the request body.
         * @summary Start Instance
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {StartProcessInstanceDto} [startProcessInstanceDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProcessInstanceByKey(key, startProcessInstanceDto, options) {
            return localVarFp.startProcessInstanceByKey(key, startProcessInstanceDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Instantiates a given process definition, starts the latest version of the process definition for tenant. Process variables and business key may be supplied in the request body.
         * @summary Start Instance
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {StartProcessInstanceDto} [startProcessInstanceDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProcessInstanceByKeyAndTenantId(key, tenantId, startProcessInstanceDto, options) {
            return localVarFp.startProcessInstanceByKeyAndTenantId(key, tenantId, startProcessInstanceDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Starts a process instance using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Submit Start Form
         * @param {string} id The id of the process definition to submit the form for.
         * @param {StartProcessInstanceFormDto} [startProcessInstanceFormDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitForm(id, startProcessInstanceFormDto, options) {
            return localVarFp.submitForm(id, startProcessInstanceFormDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Starts the latest version of the process definition which belongs to no tenant using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Submit Start Form
         * @param {string} key The key of the process definition to submit the form for.
         * @param {StartProcessInstanceFormDto} [startProcessInstanceFormDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitFormByKey(key, startProcessInstanceFormDto, options) {
            return localVarFp.submitFormByKey(key, startProcessInstanceFormDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Starts the latest version of the process definition for a tenant using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Submit Start Form
         * @param {string} key The key of the process definition to submit the form for.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {StartProcessInstanceFormDto} [startProcessInstanceFormDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitFormByKeyAndTenantId(key, tenantId, startProcessInstanceFormDto, options) {
            return localVarFp.submitFormByKeyAndTenantId(key, tenantId, startProcessInstanceFormDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates history time to live for process definition. The field is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
         * @summary Update History Time to Live
         * @param {string} id The id of the process definition to change history time to live.
         * @param {HistoryTimeToLiveDto} [historyTimeToLiveDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHistoryTimeToLiveByProcessDefinitionId(id, historyTimeToLiveDto, options) {
            return localVarFp.updateHistoryTimeToLiveByProcessDefinitionId(id, historyTimeToLiveDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates history time to live for the latest version of the process definition which belongs to no tenant. The field is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
         * @summary Update History Time to Live
         * @param {string} key The key of the process definition to change history time to live.
         * @param {HistoryTimeToLiveDto} [historyTimeToLiveDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHistoryTimeToLiveByProcessDefinitionKey(key, historyTimeToLiveDto, options) {
            return localVarFp.updateHistoryTimeToLiveByProcessDefinitionKey(key, historyTimeToLiveDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates history time to live for the latest version of the process definition for a tenant. The field is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
         * @summary Update History Time to Live
         * @param {string} key The key of the process definition to change history time to live.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {HistoryTimeToLiveDto} [historyTimeToLiveDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId(key, tenantId, historyTimeToLiveDto, options) {
            return localVarFp.updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId(key, tenantId, historyTimeToLiveDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Activates or suspends process definitions with the given process definition key.
         * @summary Activate/Suspend By Key
         * @param {ProcessDefinitionSuspensionStateDto} [processDefinitionSuspensionStateDto] **Note**: Unallowed property is &#x60;processDefinitionId&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessDefinitionSuspensionState(processDefinitionSuspensionStateDto, options) {
            return localVarFp.updateProcessDefinitionSuspensionState(processDefinitionSuspensionStateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Activates or suspends a given process definition by id.
         * @summary Activate/Suspend By Id
         * @param {string} id The id of the process definition to activate or suspend.
         * @param {ProcessDefinitionSuspensionStateDto} [processDefinitionSuspensionStateDto] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessDefinitionSuspensionStateById(id, processDefinitionSuspensionStateDto, options) {
            return localVarFp.updateProcessDefinitionSuspensionStateById(id, processDefinitionSuspensionStateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Activates or suspends a given process definition by latest version of process definition key which belongs to no tenant.
         * @summary Activate/Suspend by Id
         * @param {string} key The key of the process definition (the latest version thereof) to be activated/suspended.
         * @param {ProcessDefinitionSuspensionStateDto} [processDefinitionSuspensionStateDto] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessDefinitionSuspensionStateByKey(key, processDefinitionSuspensionStateDto, options) {
            return localVarFp.updateProcessDefinitionSuspensionStateByKey(key, processDefinitionSuspensionStateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Activates or suspends a given process definition by the latest version of the process definition for tenant.
         * @summary Activate/Suspend by Id
         * @param {string} key The key of the process definition (the latest version thereof) to be activated/suspended.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {ProcessDefinitionSuspensionStateDto} [processDefinitionSuspensionStateDto] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessDefinitionSuspensionStateByKeyAndTenantId(key, tenantId, processDefinitionSuspensionStateDto, options) {
            return localVarFp.updateProcessDefinitionSuspensionStateByKeyAndTenantId(key, tenantId, processDefinitionSuspensionStateDto, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ProcessDefinitionApiFactory = ProcessDefinitionApiFactory;
/**
 * ProcessDefinitionApi - object-oriented interface
 * @export
 * @class ProcessDefinitionApi
 * @extends {BaseAPI}
 */
class ProcessDefinitionApi extends base_1.BaseAPI {
    /**
     * Deletes a running process instance by id.
     * @summary Delete
     * @param {string} id The id of the process definition to be deleted.
     * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
     * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
     * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    deleteProcessDefinition(id, cascade, skipCustomListeners, skipIoMappings, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).deleteProcessDefinition(id, cascade, skipCustomListeners, skipIoMappings, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes process definitions by a given key which belong to no tenant id.
     * @summary Delete By Key
     * @param {string} key The key of the process definitions to be deleted.
     * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
     * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
     * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    deleteProcessDefinitionsByKey(key, cascade, skipCustomListeners, skipIoMappings, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).deleteProcessDefinitionsByKey(key, cascade, skipCustomListeners, skipIoMappings, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes process definitions by a given key and which belong to a tenant id.
     * @summary Delete By Key
     * @param {string} key The key of the process definitions to be deleted.
     * @param {string} tenantId The id of the tenant the process definitions belong to.
     * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
     * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
     * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    deleteProcessDefinitionsByKeyAndTenantId(key, tenantId, cascade, skipCustomListeners, skipIoMappings, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).deleteProcessDefinitionsByKeyAndTenantId(key, tenantId, cascade, skipCustomListeners, skipIoMappings, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves runtime statistics of a given process definition, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
     * @summary Get Activity Instance Statistics
     * @param {string} id The id of the process definition.
     * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
     * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
     * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    getActivityStatistics(id, failedJobs, incidents, incidentsForType, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).getActivityStatistics(id, failedJobs, incidents, incidentsForType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves runtime statistics of the latest version of the given process definition which belongs to no tenant, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
     * @summary Get Activity Instance Statistics
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
     * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
     * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    getActivityStatisticsByProcessDefinitionKey(key, failedJobs, incidents, incidentsForType, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).getActivityStatisticsByProcessDefinitionKey(key, failedJobs, incidents, incidentsForType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves runtime statistics of the latest version of the given process definition for a tenant, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
     * @summary Get Activity Instance Statistics
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
     * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
     * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    getActivityStatisticsByProcessDefinitionKeyAndTenantId(key, tenantId, failedJobs, incidents, incidentsForType, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).getActivityStatisticsByProcessDefinitionKeyAndTenantId(key, tenantId, failedJobs, incidents, incidentsForType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
     * @summary Get Deployed Start Form
     * @param {string} id The id of the process definition to get the deployed start form for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    getDeployedStartForm(id, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).getDeployedStartForm(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
     * @summary Get Deployed Start Form
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    getDeployedStartFormByKey(key, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).getDeployedStartFormByKey(key, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
     * @summary Get Deployed Start Form
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {string} tenantId The id of the tenant the process definitions belong to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    getDeployedStartFormByKeyAndTenantId(key, tenantId, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).getDeployedStartFormByKeyAndTenantId(key, tenantId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the latest version of the process definition for tenant according to the `ProcessDefinition` interface in the engine.
     * @summary Get
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    getLatestProcessDefinitionByTenantId(key, tenantId, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).getLatestProcessDefinitionByTenantId(key, tenantId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a process definition according to the `ProcessDefinition` interface in the engine.
     * @summary Get
     * @param {string} id The id of the process definition to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    getProcessDefinition(id, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).getProcessDefinition(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the BPMN 2.0 XML of a process definition.
     * @summary Get XML
     * @param {string} id The id of the process definition.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    getProcessDefinitionBpmn20Xml(id, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).getProcessDefinitionBpmn20Xml(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves latest version the BPMN 2.0 XML of a process definition.
     * @summary Get XML
     * @param {string} key The key of the process definition (the latest version thereof) whose XML should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    getProcessDefinitionBpmn20XmlByKey(key, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).getProcessDefinitionBpmn20XmlByKey(key, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves latest version the BPMN 2.0 XML of a process definition. Returns the XML for the latest version of the process definition for tenant.
     * @summary Get XML
     * @param {string} key The key of the process definition (the latest version thereof) whose XML should be retrieved.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    getProcessDefinitionBpmn20XmlByKeyAndTenantId(key, tenantId, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).getProcessDefinitionBpmn20XmlByKeyAndTenantId(key, tenantId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the latest version of the process definition which belongs to no tenant according to the `ProcessDefinition` interface in the engine.
     * @summary Get
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    getProcessDefinitionByKey(key, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).getProcessDefinitionByKey(key, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the diagram of a process definition.  If the process definition\'s deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
     * @summary Get Diagram
     * @param {string} id The id of the process definition.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    getProcessDefinitionDiagram(id, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).getProcessDefinitionDiagram(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the diagram for the latest version of the process definition which belongs to no tenant.  If the process definition\'s deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
     * @summary Get Diagram
     * @param {string} key The key of the process definition.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    getProcessDefinitionDiagramByKey(key, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).getProcessDefinitionDiagramByKey(key, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the diagram for the latest version of the process definition for tenant.  If the process definition\'s deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
     * @summary Get Diagram
     * @param {string} key The key of the process definition.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    getProcessDefinitionDiagramByKeyAndTenantId(key, tenantId, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).getProcessDefinitionDiagramByKeyAndTenantId(key, tenantId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves runtime statistics of the process engine, grouped by process definitions. These statistics include the number of running process instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
     * @summary Get Process Instance Statistics
     * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
     * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
     * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param {boolean} [rootIncidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of root incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60; or &#x60;incidents&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    getProcessDefinitionStatistics(failedJobs, incidents, incidentsForType, rootIncidents, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).getProcessDefinitionStatistics(failedJobs, incidents, incidentsForType, rootIncidents, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for process definitions that fulfill given parameters. Parameters may be the properties of  process definitions, such as the name, key or version. The size of the result set can be retrieved by using the [Get Definition Count](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/get-query-count/) method.
     * @summary Get List
     * @param {string} [processDefinitionId] Filter by process definition id.
     * @param {string} [processDefinitionIdIn] Filter by a comma-separated list of process definition ids.
     * @param {string} [name] Filter by process definition name.
     * @param {string} [nameLike] Filter by process definition names that the parameter is a substring of.
     * @param {string} [deploymentId] Filter by the deployment the id belongs to.
     * @param {string} [deployedAfter] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
     * @param {string} [deployedAt] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
     * @param {string} [key] Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match.
     * @param {string} [keysIn] Filter by a comma-separated list of process definition keys.
     * @param {string} [keyLike] Filter by process definition keys that the parameter is a substring of.
     * @param {string} [category] Filter by process definition category. Exact match.
     * @param {string} [categoryLike] Filter by process definition categories that the parameter is a substring of.
     * @param {number} [version] Filter by process definition version.
     * @param {boolean} [latestVersion] Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [resourceName] Filter by the name of the process definition resource. Exact match.
     * @param {string} [resourceNameLike] Filter by names of those process definition resources that the parameter is a substring of.
     * @param {string} [startableBy] Filter by a user name who is allowed to start the process.
     * @param {boolean} [active] Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [suspended] Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [incidentId] Filter by the incident id.
     * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param {string} [incidentMessage] Filter by the incident message. Exact match.
     * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
     * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids.
     * @param {boolean} [withoutTenantId] Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior.
     * @param {boolean} [includeProcessDefinitionsWithoutTenantId] Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [versionTag] Filter by the version tag.
     * @param {string} [versionTagLike] Filter by the version tag that the parameter is a substring of.
     * @param {boolean} [withoutVersionTag] Only include process definitions without a &#x60;versionTag&#x60;.
     * @param {boolean} [startableInTasklist] Filter by process definitions which are startable in Tasklist..
     * @param {boolean} [notStartableInTasklist] Filter by process definitions which are not startable in Tasklist.
     * @param {boolean} [startablePermissionCheck] Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn\&#39;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level
     * @param {'category' | 'key' | 'id' | 'name' | 'version' | 'deploymentId' | 'deployTime' | 'tenantId ' | 'versionTag'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    getProcessDefinitions(processDefinitionId, processDefinitionIdIn, name, nameLike, deploymentId, deployedAfter, deployedAt, key, keysIn, keyLike, category, categoryLike, version, latestVersion, resourceName, resourceNameLike, startableBy, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, includeProcessDefinitionsWithoutTenantId, versionTag, versionTagLike, withoutVersionTag, startableInTasklist, notStartableInTasklist, startablePermissionCheck, sortBy, sortOrder, firstResult, maxResults, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).getProcessDefinitions(processDefinitionId, processDefinitionIdIn, name, nameLike, deploymentId, deployedAfter, deployedAt, key, keysIn, keyLike, category, categoryLike, version, latestVersion, resourceName, resourceNameLike, startableBy, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, includeProcessDefinitionsWithoutTenantId, versionTag, versionTagLike, withoutVersionTag, startableInTasklist, notStartableInTasklist, startablePermissionCheck, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requests the number of process definitions that fulfill the query criteria. Takes the same filtering parameters as the [Get Definitions](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/get-query/) method.
     * @summary Get List Count
     * @param {string} [processDefinitionId] Filter by process definition id.
     * @param {string} [processDefinitionIdIn] Filter by a comma-separated list of process definition ids.
     * @param {string} [name] Filter by process definition name.
     * @param {string} [nameLike] Filter by process definition names that the parameter is a substring of.
     * @param {string} [deploymentId] Filter by the deployment the id belongs to.
     * @param {string} [deployedAfter] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
     * @param {string} [deployedAt] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
     * @param {string} [key] Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match.
     * @param {string} [keysIn] Filter by a comma-separated list of process definition keys.
     * @param {string} [keyLike] Filter by process definition keys that the parameter is a substring of.
     * @param {string} [category] Filter by process definition category. Exact match.
     * @param {string} [categoryLike] Filter by process definition categories that the parameter is a substring of.
     * @param {number} [version] Filter by process definition version.
     * @param {boolean} [latestVersion] Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [resourceName] Filter by the name of the process definition resource. Exact match.
     * @param {string} [resourceNameLike] Filter by names of those process definition resources that the parameter is a substring of.
     * @param {string} [startableBy] Filter by a user name who is allowed to start the process.
     * @param {boolean} [active] Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [suspended] Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [incidentId] Filter by the incident id.
     * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param {string} [incidentMessage] Filter by the incident message. Exact match.
     * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
     * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids.
     * @param {boolean} [withoutTenantId] Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior.
     * @param {boolean} [includeProcessDefinitionsWithoutTenantId] Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [versionTag] Filter by the version tag.
     * @param {string} [versionTagLike] Filter by the version tag that the parameter is a substring of.
     * @param {boolean} [withoutVersionTag] Only include process definitions without a &#x60;versionTag&#x60;.
     * @param {boolean} [startableInTasklist] Filter by process definitions which are startable in Tasklist..
     * @param {boolean} [notStartableInTasklist] Filter by process definitions which are not startable in Tasklist.
     * @param {boolean} [startablePermissionCheck] Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn\&#39;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    getProcessDefinitionsCount(processDefinitionId, processDefinitionIdIn, name, nameLike, deploymentId, deployedAfter, deployedAt, key, keysIn, keyLike, category, categoryLike, version, latestVersion, resourceName, resourceNameLike, startableBy, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, includeProcessDefinitionsWithoutTenantId, versionTag, versionTagLike, withoutVersionTag, startableInTasklist, notStartableInTasklist, startablePermissionCheck, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).getProcessDefinitionsCount(processDefinitionId, processDefinitionIdIn, name, nameLike, deploymentId, deployedAfter, deployedAt, key, keysIn, keyLike, category, categoryLike, version, latestVersion, resourceName, resourceNameLike, startableBy, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, includeProcessDefinitionsWithoutTenantId, versionTag, versionTagLike, withoutVersionTag, startableInTasklist, notStartableInTasklist, startablePermissionCheck, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the rendered form for a process definition. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
     * @summary Get Rendered Start Form
     * @param {string} id The id of the process definition to get the rendered start form for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    getRenderedStartForm(id, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).getRenderedStartForm(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves  the rendered form for the latest version of the process definition which belongs to no tenant. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
     * @summary Get Rendered Start Form
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    getRenderedStartFormByKey(key, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).getRenderedStartFormByKey(key, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves  the rendered form for the latest version of the process definition for a tenant. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
     * @summary Get Rendered Start Form
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    getRenderedStartFormByKeyAndTenantId(key, tenantId, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).getRenderedStartFormByKeyAndTenantId(key, tenantId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the key of the start form for a process definition. The form key corresponds to the `FormData#formKey` property in the engine.
     * @summary Get Start Form Key
     * @param {string} id The id of the process definition to get the start form key for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    getStartForm(id, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).getStartForm(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the key of the start form for the latest version of the process definition which belongs to no tenant. The form key corresponds to the `FormData#formKey` property in the engine.
     * @summary Get Start Form Key
     * @param {string} key The key of the process definition (the latest version thereof) for which the form key is to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    getStartFormByKey(key, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).getStartFormByKey(key, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the key of the start form for the latest version of the process definition for a tenant. The form key corresponds to the `FormData#formKey` property in the engine.
     * @summary Get Start Form Key
     * @param {string} key The key of the process definition (the latest version thereof) for which the form key is to be retrieved.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    getStartFormByKeyAndTenantId(key, tenantId, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).getStartFormByKeyAndTenantId(key, tenantId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the start form variables for a process definition (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
     * @summary Get Start Form Variables
     * @param {string} id The id of the process definition to retrieve the variables for.
     * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
     * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    getStartFormVariables(id, variableNames, deserializeValues, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).getStartFormVariables(id, variableNames, deserializeValues, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the start form variables for the latest process definition which belongs to no tenant (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
     * @summary Get Start Form Variables
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
     * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    getStartFormVariablesByKey(key, variableNames, deserializeValues, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).getStartFormVariablesByKey(key, variableNames, deserializeValues, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the start form variables for the latest process definition for a tenant (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
     * @summary Get Start Form Variables
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
     * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    getStartFormVariablesByKeyAndTenantId(key, tenantId, variableNames, deserializeValues, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).getStartFormVariablesByKeyAndTenantId(key, tenantId, variableNames, deserializeValues, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Restarts process instances that were canceled or terminated synchronously. Can also restart completed process instances. It will create a new instance using the original instance information. To execute the restart asynchronously, use the [Restart Process Instance Async](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/post-restart-process-instance-async/) method.  For more information about the difference between synchronous and asynchronous execution, please refer to the related section of the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-restart/#execution).
     * @summary Restart Process Instance
     * @param {string} id The id of the process definition of the process instances to restart.
     * @param {RestartProcessInstanceDto} [restartProcessInstanceDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    restartProcessInstance(id, restartProcessInstanceDto, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).restartProcessInstance(id, restartProcessInstanceDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Restarts process instances that were canceled or terminated asynchronously. Can also restart completed process instances. It will create a new instance using the original instance information. To execute the restart asynchronously, use the [Restart Process Instance](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/post-restart-process-instance-sync/) method.  For more information about the difference between synchronous and asynchronous execution, please refer to the related section of the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-restart/#execution).
     * @summary Restart Process Instance Async
     * @param {string} id The id of the process definition of the process instances to restart.
     * @param {RestartProcessInstanceDto} [restartProcessInstanceDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    restartProcessInstanceAsyncOperation(id, restartProcessInstanceDto, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).restartProcessInstanceAsyncOperation(id, restartProcessInstanceDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Instantiates a given process definition. Process variables and business key may be supplied in the request body.
     * @summary Start Instance
     * @param {string} id The id of the process definition to be retrieved.
     * @param {StartProcessInstanceDto} [startProcessInstanceDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    startProcessInstance(id, startProcessInstanceDto, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).startProcessInstance(id, startProcessInstanceDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Instantiates a given process definition, starts the latest version of the process definition which belongs to no tenant. Process variables and business key may be supplied in the request body.
     * @summary Start Instance
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {StartProcessInstanceDto} [startProcessInstanceDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    startProcessInstanceByKey(key, startProcessInstanceDto, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).startProcessInstanceByKey(key, startProcessInstanceDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Instantiates a given process definition, starts the latest version of the process definition for tenant. Process variables and business key may be supplied in the request body.
     * @summary Start Instance
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {StartProcessInstanceDto} [startProcessInstanceDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    startProcessInstanceByKeyAndTenantId(key, tenantId, startProcessInstanceDto, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).startProcessInstanceByKeyAndTenantId(key, tenantId, startProcessInstanceDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Starts a process instance using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
     * @summary Submit Start Form
     * @param {string} id The id of the process definition to submit the form for.
     * @param {StartProcessInstanceFormDto} [startProcessInstanceFormDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    submitForm(id, startProcessInstanceFormDto, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).submitForm(id, startProcessInstanceFormDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Starts the latest version of the process definition which belongs to no tenant using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
     * @summary Submit Start Form
     * @param {string} key The key of the process definition to submit the form for.
     * @param {StartProcessInstanceFormDto} [startProcessInstanceFormDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    submitFormByKey(key, startProcessInstanceFormDto, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).submitFormByKey(key, startProcessInstanceFormDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Starts the latest version of the process definition for a tenant using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
     * @summary Submit Start Form
     * @param {string} key The key of the process definition to submit the form for.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {StartProcessInstanceFormDto} [startProcessInstanceFormDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    submitFormByKeyAndTenantId(key, tenantId, startProcessInstanceFormDto, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).submitFormByKeyAndTenantId(key, tenantId, startProcessInstanceFormDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates history time to live for process definition. The field is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
     * @summary Update History Time to Live
     * @param {string} id The id of the process definition to change history time to live.
     * @param {HistoryTimeToLiveDto} [historyTimeToLiveDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    updateHistoryTimeToLiveByProcessDefinitionId(id, historyTimeToLiveDto, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).updateHistoryTimeToLiveByProcessDefinitionId(id, historyTimeToLiveDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates history time to live for the latest version of the process definition which belongs to no tenant. The field is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
     * @summary Update History Time to Live
     * @param {string} key The key of the process definition to change history time to live.
     * @param {HistoryTimeToLiveDto} [historyTimeToLiveDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    updateHistoryTimeToLiveByProcessDefinitionKey(key, historyTimeToLiveDto, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).updateHistoryTimeToLiveByProcessDefinitionKey(key, historyTimeToLiveDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates history time to live for the latest version of the process definition for a tenant. The field is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
     * @summary Update History Time to Live
     * @param {string} key The key of the process definition to change history time to live.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {HistoryTimeToLiveDto} [historyTimeToLiveDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId(key, tenantId, historyTimeToLiveDto, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId(key, tenantId, historyTimeToLiveDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Activates or suspends process definitions with the given process definition key.
     * @summary Activate/Suspend By Key
     * @param {ProcessDefinitionSuspensionStateDto} [processDefinitionSuspensionStateDto] **Note**: Unallowed property is &#x60;processDefinitionId&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    updateProcessDefinitionSuspensionState(processDefinitionSuspensionStateDto, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).updateProcessDefinitionSuspensionState(processDefinitionSuspensionStateDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Activates or suspends a given process definition by id.
     * @summary Activate/Suspend By Id
     * @param {string} id The id of the process definition to activate or suspend.
     * @param {ProcessDefinitionSuspensionStateDto} [processDefinitionSuspensionStateDto] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    updateProcessDefinitionSuspensionStateById(id, processDefinitionSuspensionStateDto, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).updateProcessDefinitionSuspensionStateById(id, processDefinitionSuspensionStateDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Activates or suspends a given process definition by latest version of process definition key which belongs to no tenant.
     * @summary Activate/Suspend by Id
     * @param {string} key The key of the process definition (the latest version thereof) to be activated/suspended.
     * @param {ProcessDefinitionSuspensionStateDto} [processDefinitionSuspensionStateDto] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    updateProcessDefinitionSuspensionStateByKey(key, processDefinitionSuspensionStateDto, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).updateProcessDefinitionSuspensionStateByKey(key, processDefinitionSuspensionStateDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Activates or suspends a given process definition by the latest version of the process definition for tenant.
     * @summary Activate/Suspend by Id
     * @param {string} key The key of the process definition (the latest version thereof) to be activated/suspended.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {ProcessDefinitionSuspensionStateDto} [processDefinitionSuspensionStateDto] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    updateProcessDefinitionSuspensionStateByKeyAndTenantId(key, tenantId, processDefinitionSuspensionStateDto, options) {
        return (0, exports.ProcessDefinitionApiFp)(this.configuration).updateProcessDefinitionSuspensionStateByKeyAndTenantId(key, tenantId, processDefinitionSuspensionStateDto, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ProcessDefinitionApi = ProcessDefinitionApi;
/**
 * ProcessInstanceApi - axios parameter creator
 * @export
 */
const ProcessInstanceApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Deletes a set of process instances asynchronously (batch) based on a historic process instance query.
         * @param {DeleteProcessInstancesDto} [deleteProcessInstancesDto] **Unallowed property**: &#x60;processInstanceQuery&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAsyncHistoricQueryBased: async (deleteProcessInstancesDto, options = {}) => {
            const localVarPath = `/process-instance/delete-historic-query-based`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(deleteProcessInstancesDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a running process instance by id.
         * @param {string} id The id of the process instance to be deleted.
         * @param {boolean} [skipCustomListeners] If set to true, the custom listeners will be skipped.
         * @param {boolean} [skipIoMappings] If set to true, the input/output mappings will be skipped.
         * @param {boolean} [skipSubprocesses] If set to true, subprocesses related to deleted processes will be skipped.
         * @param {boolean} [failIfNotExists] If set to false, the request will still be successful if the process id is not found.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessInstance: async (id, skipCustomListeners, skipIoMappings, skipSubprocesses, failIfNotExists, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteProcessInstance', 'id', id);
            const localVarPath = `/process-instance/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (skipCustomListeners !== undefined) {
                localVarQueryParameter['skipCustomListeners'] = skipCustomListeners;
            }
            if (skipIoMappings !== undefined) {
                localVarQueryParameter['skipIoMappings'] = skipIoMappings;
            }
            if (skipSubprocesses !== undefined) {
                localVarQueryParameter['skipSubprocesses'] = skipSubprocesses;
            }
            if (failIfNotExists !== undefined) {
                localVarQueryParameter['failIfNotExists'] = failIfNotExists;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a variable of a process instance by id.
         * @param {string} id The id of the process instance to delete the variable from.
         * @param {string} varName The name of the variable to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessInstanceVariable: async (id, varName, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteProcessInstanceVariable', 'id', id);
            // verify required parameter 'varName' is not null or undefined
            (0, common_1.assertParamExists)('deleteProcessInstanceVariable', 'varName', varName);
            const localVarPath = `/process-instance/{id}/variables/{varName}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes multiple process instances asynchronously (batch).
         * @param {DeleteProcessInstancesDto} [deleteProcessInstancesDto] **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessInstancesAsyncOperation: async (deleteProcessInstancesDto, options = {}) => {
            const localVarPath = `/process-instance/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(deleteProcessInstancesDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves an Activity Instance (Tree) for a given process instance by id.
         * @param {string} id The id of the process instance for which the activity instance should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityInstanceTree: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getActivityInstanceTree', 'id', id);
            const localVarPath = `/process-instance/{id}/activity-instances`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a variable of a given process instance by id.
         * @param {string} id The id of the process instance to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstanceVariable: async (id, varName, deserializeValue, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getProcessInstanceVariable', 'id', id);
            // verify required parameter 'varName' is not null or undefined
            (0, common_1.assertParamExists)('getProcessInstanceVariable', 'varName', varName);
            const localVarPath = `/process-instance/{id}/variables/{varName}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (deserializeValue !== undefined) {
                localVarQueryParameter['deserializeValue'] = deserializeValue;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the content of a Process Variable by the Process Instance id and the Process Variable name. Applicable for byte array or file Process Variables.
         * @param {string} id The id of the process instance to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstanceVariableBinary: async (id, varName, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getProcessInstanceVariableBinary', 'id', id);
            // verify required parameter 'varName' is not null or undefined
            (0, common_1.assertParamExists)('getProcessInstanceVariableBinary', 'varName', varName);
            const localVarPath = `/process-instance/{id}/variables/{varName}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all variables of a given process instance by id.
         * @param {string} id The id of the process instance to retrieve the variables from.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstanceVariables: async (id, deserializeValue, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getProcessInstanceVariables', 'id', id);
            const localVarPath = `/process-instance/{id}/variables`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (deserializeValue !== undefined) {
                localVarQueryParameter['deserializeValue'] = deserializeValue;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for process instances that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of process instances. The size of the result set can be retrieved by using the Get Instance Count method.
         * @param {'instanceId' | 'definitionKey' | 'definitionId' | 'tenantId' | 'businessKey'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {string} [processInstanceIds] Filter by a comma-separated list of process instance ids.
         * @param {string} [businessKey] Filter by process instance business key.
         * @param {string} [businessKeyLike] Filter by process instance business key that the parameter is a substring of.
         * @param {string} [caseInstanceId] Filter by case instance id.
         * @param {string} [processDefinitionId] Filter by the deployment the id belongs to.
         * @param {string} [processDefinitionKey] Filter by the key of the process definition the instances run on.
         * @param {string} [processDefinitionKeyIn] Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys.
         * @param {string} [processDefinitionKeyNotIn] Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {string} [superProcessInstance] Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id.
         * @param {string} [subProcessInstance] Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id.
         * @param {string} [superCaseInstance] Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.
         * @param {string} [subCaseInstance] Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id.
         * @param {boolean} [active] Only include active process instances. Value may only be true, as false is the default behavior.
         * @param {boolean} [suspended] Only include suspended process instances. Value may only be true, as false is the default behavior.
         * @param {boolean} [withIncident] Filter by presence of incidents. Selects only process instances that have an incident.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process instances which belong to no tenant.
         * @param {boolean} [processDefinitionWithoutTenantId] Only include process instances which process definition has no tenant id.
         * @param {string} [activityIdIn] Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids.
         * @param {boolean} [rootProcessInstances] Restrict the query to all process instances that are top level process instances.
         * @param {boolean} [leafProcessInstances] Restrict the query to all process instances that are leaf instances. (i.e. don\&#39;t have any sub instances).
         * @param {string} [variables] Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstances: async (sortBy, sortOrder, firstResult, maxResults, processInstanceIds, businessKey, businessKeyLike, caseInstanceId, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionKeyNotIn, deploymentId, superProcessInstance, subProcessInstance, superCaseInstance, subCaseInstance, active, suspended, withIncident, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, processDefinitionWithoutTenantId, activityIdIn, rootProcessInstances, leafProcessInstances, variables, variableNamesIgnoreCase, variableValuesIgnoreCase, options = {}) => {
            const localVarPath = `/process-instance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }
            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }
            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }
            if (processInstanceIds !== undefined) {
                localVarQueryParameter['processInstanceIds'] = processInstanceIds;
            }
            if (businessKey !== undefined) {
                localVarQueryParameter['businessKey'] = businessKey;
            }
            if (businessKeyLike !== undefined) {
                localVarQueryParameter['businessKeyLike'] = businessKeyLike;
            }
            if (caseInstanceId !== undefined) {
                localVarQueryParameter['caseInstanceId'] = caseInstanceId;
            }
            if (processDefinitionId !== undefined) {
                localVarQueryParameter['processDefinitionId'] = processDefinitionId;
            }
            if (processDefinitionKey !== undefined) {
                localVarQueryParameter['processDefinitionKey'] = processDefinitionKey;
            }
            if (processDefinitionKeyIn !== undefined) {
                localVarQueryParameter['processDefinitionKeyIn'] = processDefinitionKeyIn;
            }
            if (processDefinitionKeyNotIn !== undefined) {
                localVarQueryParameter['processDefinitionKeyNotIn'] = processDefinitionKeyNotIn;
            }
            if (deploymentId !== undefined) {
                localVarQueryParameter['deploymentId'] = deploymentId;
            }
            if (superProcessInstance !== undefined) {
                localVarQueryParameter['superProcessInstance'] = superProcessInstance;
            }
            if (subProcessInstance !== undefined) {
                localVarQueryParameter['subProcessInstance'] = subProcessInstance;
            }
            if (superCaseInstance !== undefined) {
                localVarQueryParameter['superCaseInstance'] = superCaseInstance;
            }
            if (subCaseInstance !== undefined) {
                localVarQueryParameter['subCaseInstance'] = subCaseInstance;
            }
            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }
            if (suspended !== undefined) {
                localVarQueryParameter['suspended'] = suspended;
            }
            if (withIncident !== undefined) {
                localVarQueryParameter['withIncident'] = withIncident;
            }
            if (incidentId !== undefined) {
                localVarQueryParameter['incidentId'] = incidentId;
            }
            if (incidentType !== undefined) {
                localVarQueryParameter['incidentType'] = incidentType;
            }
            if (incidentMessage !== undefined) {
                localVarQueryParameter['incidentMessage'] = incidentMessage;
            }
            if (incidentMessageLike !== undefined) {
                localVarQueryParameter['incidentMessageLike'] = incidentMessageLike;
            }
            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }
            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }
            if (processDefinitionWithoutTenantId !== undefined) {
                localVarQueryParameter['processDefinitionWithoutTenantId'] = processDefinitionWithoutTenantId;
            }
            if (activityIdIn !== undefined) {
                localVarQueryParameter['activityIdIn'] = activityIdIn;
            }
            if (rootProcessInstances !== undefined) {
                localVarQueryParameter['rootProcessInstances'] = rootProcessInstances;
            }
            if (leafProcessInstances !== undefined) {
                localVarQueryParameter['leafProcessInstances'] = leafProcessInstances;
            }
            if (variables !== undefined) {
                localVarQueryParameter['variables'] = variables;
            }
            if (variableNamesIgnoreCase !== undefined) {
                localVarQueryParameter['variableNamesIgnoreCase'] = variableNamesIgnoreCase;
            }
            if (variableValuesIgnoreCase !== undefined) {
                localVarQueryParameter['variableValuesIgnoreCase'] = variableValuesIgnoreCase;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for the number of process instances that fulfill given parameters.
         * @param {string} [processInstanceIds] Filter by a comma-separated list of process instance ids.
         * @param {string} [businessKey] Filter by process instance business key.
         * @param {string} [businessKeyLike] Filter by process instance business key that the parameter is a substring of.
         * @param {string} [caseInstanceId] Filter by case instance id.
         * @param {string} [processDefinitionId] Filter by the deployment the id belongs to.
         * @param {string} [processDefinitionKey] Filter by the key of the process definition the instances run on.
         * @param {string} [processDefinitionKeyIn] Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys.
         * @param {string} [processDefinitionKeyNotIn] Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {string} [superProcessInstance] Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id.
         * @param {string} [subProcessInstance] Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id.
         * @param {string} [superCaseInstance] Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.
         * @param {string} [subCaseInstance] Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id.
         * @param {boolean} [active] Only include active process instances. Value may only be true, as false is the default behavior.
         * @param {boolean} [suspended] Only include suspended process instances. Value may only be true, as false is the default behavior.
         * @param {boolean} [withIncident] Filter by presence of incidents. Selects only process instances that have an incident.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process instances which belong to no tenant.
         * @param {boolean} [processDefinitionWithoutTenantId] Only include process instances which process definition has no tenant id.
         * @param {string} [activityIdIn] Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids.
         * @param {boolean} [rootProcessInstances] Restrict the query to all process instances that are top level process instances.
         * @param {boolean} [leafProcessInstances] Restrict the query to all process instances that are leaf instances. (i.e. don\&#39;t have any sub instances).
         * @param {string} [variables] Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstancesCount: async (processInstanceIds, businessKey, businessKeyLike, caseInstanceId, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionKeyNotIn, deploymentId, superProcessInstance, subProcessInstance, superCaseInstance, subCaseInstance, active, suspended, withIncident, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, processDefinitionWithoutTenantId, activityIdIn, rootProcessInstances, leafProcessInstances, variables, variableNamesIgnoreCase, variableValuesIgnoreCase, options = {}) => {
            const localVarPath = `/process-instance/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (processInstanceIds !== undefined) {
                localVarQueryParameter['processInstanceIds'] = processInstanceIds;
            }
            if (businessKey !== undefined) {
                localVarQueryParameter['businessKey'] = businessKey;
            }
            if (businessKeyLike !== undefined) {
                localVarQueryParameter['businessKeyLike'] = businessKeyLike;
            }
            if (caseInstanceId !== undefined) {
                localVarQueryParameter['caseInstanceId'] = caseInstanceId;
            }
            if (processDefinitionId !== undefined) {
                localVarQueryParameter['processDefinitionId'] = processDefinitionId;
            }
            if (processDefinitionKey !== undefined) {
                localVarQueryParameter['processDefinitionKey'] = processDefinitionKey;
            }
            if (processDefinitionKeyIn !== undefined) {
                localVarQueryParameter['processDefinitionKeyIn'] = processDefinitionKeyIn;
            }
            if (processDefinitionKeyNotIn !== undefined) {
                localVarQueryParameter['processDefinitionKeyNotIn'] = processDefinitionKeyNotIn;
            }
            if (deploymentId !== undefined) {
                localVarQueryParameter['deploymentId'] = deploymentId;
            }
            if (superProcessInstance !== undefined) {
                localVarQueryParameter['superProcessInstance'] = superProcessInstance;
            }
            if (subProcessInstance !== undefined) {
                localVarQueryParameter['subProcessInstance'] = subProcessInstance;
            }
            if (superCaseInstance !== undefined) {
                localVarQueryParameter['superCaseInstance'] = superCaseInstance;
            }
            if (subCaseInstance !== undefined) {
                localVarQueryParameter['subCaseInstance'] = subCaseInstance;
            }
            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }
            if (suspended !== undefined) {
                localVarQueryParameter['suspended'] = suspended;
            }
            if (withIncident !== undefined) {
                localVarQueryParameter['withIncident'] = withIncident;
            }
            if (incidentId !== undefined) {
                localVarQueryParameter['incidentId'] = incidentId;
            }
            if (incidentType !== undefined) {
                localVarQueryParameter['incidentType'] = incidentType;
            }
            if (incidentMessage !== undefined) {
                localVarQueryParameter['incidentMessage'] = incidentMessage;
            }
            if (incidentMessageLike !== undefined) {
                localVarQueryParameter['incidentMessageLike'] = incidentMessageLike;
            }
            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }
            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }
            if (processDefinitionWithoutTenantId !== undefined) {
                localVarQueryParameter['processDefinitionWithoutTenantId'] = processDefinitionWithoutTenantId;
            }
            if (activityIdIn !== undefined) {
                localVarQueryParameter['activityIdIn'] = activityIdIn;
            }
            if (rootProcessInstances !== undefined) {
                localVarQueryParameter['rootProcessInstances'] = rootProcessInstances;
            }
            if (leafProcessInstances !== undefined) {
                localVarQueryParameter['leafProcessInstances'] = leafProcessInstances;
            }
            if (variables !== undefined) {
                localVarQueryParameter['variables'] = variables;
            }
            if (variableNamesIgnoreCase !== undefined) {
                localVarQueryParameter['variableNamesIgnoreCase'] = variableNamesIgnoreCase;
            }
            if (variableValuesIgnoreCase !== undefined) {
                localVarQueryParameter['variableValuesIgnoreCase'] = variableValuesIgnoreCase;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submits a list of modification instructions to change a process instance\'s execution state. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Canceling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed immediately and in the order they are provided in this request\'s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/develop/user-guide/process-engine/process-instance-modification/).
         * @param {string} id The id of the process instance to modify.
         * @param {ProcessInstanceModificationDto} [processInstanceModificationDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyProcessInstance: async (id, processInstanceModificationDto, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('modifyProcessInstance', 'id', id);
            const localVarPath = `/process-instance/{id}/modification`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(processInstanceModificationDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submits a list of modification instructions to change a process instance\'s execution state async. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Cancelling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed asynchronous and in the order they are provided in this request\'s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-modification/).
         * @param {string} id The id of the process instance to modify.
         * @param {ProcessInstanceModificationDto} [processInstanceModificationDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyProcessInstanceAsyncOperation: async (id, processInstanceModificationDto, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('modifyProcessInstanceAsyncOperation', 'id', id);
            const localVarPath = `/process-instance/{id}/modification-async`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(processInstanceModificationDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates or deletes the variables of a process instance by id. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
         * @param {string} id The id of the process instance to set variables for.
         * @param {PatchVariablesDto} [patchVariablesDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyProcessInstanceVariables: async (id, patchVariablesDto, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('modifyProcessInstanceVariables', 'id', id);
            const localVarPath = `/process-instance/{id}/variables`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(patchVariablesDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for process instances that fulfill given parameters through a JSON object. This method is slightly more powerful than the Get Instances method because it allows filtering by multiple process variables of types `string`, `number` or `boolean`.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {ProcessInstanceQueryDto} [processInstanceQueryDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryProcessInstances: async (firstResult, maxResults, processInstanceQueryDto, options = {}) => {
            const localVarPath = `/process-instance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }
            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(processInstanceQueryDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for the number of process instances that fulfill the given parameters. This method takes the same message body as the Get Instances (POST) method and therefore it is slightly more powerful than the Get Instance Count method.
         * @param {ProcessInstanceQueryDto} [processInstanceQueryDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryProcessInstancesCount: async (processInstanceQueryDto, options = {}) => {
            const localVarPath = `/process-instance/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(processInstanceQueryDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets a variable of a given process instance by id.
         * @param {string} id The id of the process instance to set the variable for.
         * @param {string} varName The name of the variable to set.
         * @param {VariableValueDto} [variableValueDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProcessInstanceVariable: async (id, varName, variableValueDto, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('setProcessInstanceVariable', 'id', id);
            // verify required parameter 'varName' is not null or undefined
            (0, common_1.assertParamExists)('setProcessInstanceVariable', 'varName', varName);
            const localVarPath = `/process-instance/{id}/variables/{varName}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(variableValueDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the serialized value for a binary variable or the binary value for a file variable.
         * @param {string} id The id of the process instance to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {any} [data] The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory.
         * @param {string} [valueType] The name of the variable type. Either Bytes for a byte array variable or File for a file variable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProcessInstanceVariableBinary: async (id, varName, data, valueType, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('setProcessInstanceVariableBinary', 'id', id);
            // verify required parameter 'varName' is not null or undefined
            (0, common_1.assertParamExists)('setProcessInstanceVariableBinary', 'varName', varName);
            const localVarPath = `/process-instance/{id}/variables/{varName}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            if (data !== undefined) {
                localVarFormParams.append('data', data);
            }
            if (valueType !== undefined) {
                localVarFormParams.append('valueType', valueType);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a batch to set retries of jobs associated with given processes asynchronously.
         * @param {SetJobRetriesByProcessDto} [setJobRetriesByProcessDto] Please note that if both processInstances and processInstanceQuery are provided, then the resulting execution will be performed on the union of these sets. **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRetriesByProcess: async (setJobRetriesByProcessDto, options = {}) => {
            const localVarPath = `/process-instance/job-retries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(setJobRetriesByProcessDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a batch to set retries of jobs asynchronously based on a historic process instance query.
         * @param {SetJobRetriesByProcessDto} [setJobRetriesByProcessDto] Please note that if both processInstances and historicProcessInstanceQuery are provided, then the resulting execution will be performed on the union of these sets. **Unallowed property**: &#x60;processInstanceQuery&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRetriesByProcessHistoricQueryBased: async (setJobRetriesByProcessDto, options = {}) => {
            const localVarPath = `/process-instance/job-retries-historic-query-based`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(setJobRetriesByProcessDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activates or suspends process instances by providing certain criteria:  # Activate/Suspend Process Instance By Process Definition Id * `suspend` * `processDefinitionId`  # Activate/Suspend Process Instance By Process Definition Key  * `suspend` * `processDefinitionKey` * `processDefinitionTenantId` * `processDefinitionWithoutTenantId`  # Activate/Suspend Process Instance In Group * `suspend` * `processInstanceIds` * `processInstanceQuery` * `historicProcessInstanceQuery`
         * @param {ProcessInstanceSuspensionStateDto} [processInstanceSuspensionStateDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSuspensionState: async (processInstanceSuspensionStateDto, options = {}) => {
            const localVarPath = `/process-instance/suspended`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(processInstanceSuspensionStateDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activates or suspends process instances asynchronously with a list of process instance ids, a process instance query, and/or a historical process instance query.
         * @param {ProcessInstanceSuspensionStateAsyncDto} [processInstanceSuspensionStateAsyncDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSuspensionStateAsyncOperation: async (processInstanceSuspensionStateAsyncDto, options = {}) => {
            const localVarPath = `/process-instance/suspended-async`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(processInstanceSuspensionStateAsyncDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activates or suspends a given process instance by id.
         * @param {string} id The id of the process instance to activate or suspend.
         * @param {SuspensionStateDto} [suspensionStateDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSuspensionStateById: async (id, suspensionStateDto, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateSuspensionStateById', 'id', id);
            const localVarPath = `/process-instance/{id}/suspended`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(suspensionStateDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.ProcessInstanceApiAxiosParamCreator = ProcessInstanceApiAxiosParamCreator;
/**
 * ProcessInstanceApi - functional programming interface
 * @export
 */
const ProcessInstanceApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ProcessInstanceApiAxiosParamCreator)(configuration);
    return {
        /**
         * Deletes a set of process instances asynchronously (batch) based on a historic process instance query.
         * @param {DeleteProcessInstancesDto} [deleteProcessInstancesDto] **Unallowed property**: &#x60;processInstanceQuery&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAsyncHistoricQueryBased(deleteProcessInstancesDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAsyncHistoricQueryBased(deleteProcessInstancesDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Deletes a running process instance by id.
         * @param {string} id The id of the process instance to be deleted.
         * @param {boolean} [skipCustomListeners] If set to true, the custom listeners will be skipped.
         * @param {boolean} [skipIoMappings] If set to true, the input/output mappings will be skipped.
         * @param {boolean} [skipSubprocesses] If set to true, subprocesses related to deleted processes will be skipped.
         * @param {boolean} [failIfNotExists] If set to false, the request will still be successful if the process id is not found.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProcessInstance(id, skipCustomListeners, skipIoMappings, skipSubprocesses, failIfNotExists, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProcessInstance(id, skipCustomListeners, skipIoMappings, skipSubprocesses, failIfNotExists, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Deletes a variable of a process instance by id.
         * @param {string} id The id of the process instance to delete the variable from.
         * @param {string} varName The name of the variable to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProcessInstanceVariable(id, varName, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProcessInstanceVariable(id, varName, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Deletes multiple process instances asynchronously (batch).
         * @param {DeleteProcessInstancesDto} [deleteProcessInstancesDto] **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProcessInstancesAsyncOperation(deleteProcessInstancesDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProcessInstancesAsyncOperation(deleteProcessInstancesDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves an Activity Instance (Tree) for a given process instance by id.
         * @param {string} id The id of the process instance for which the activity instance should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivityInstanceTree(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivityInstanceTree(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves a variable of a given process instance by id.
         * @param {string} id The id of the process instance to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessInstanceVariable(id, varName, deserializeValue, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessInstanceVariable(id, varName, deserializeValue, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves the content of a Process Variable by the Process Instance id and the Process Variable name. Applicable for byte array or file Process Variables.
         * @param {string} id The id of the process instance to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessInstanceVariableBinary(id, varName, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessInstanceVariableBinary(id, varName, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves all variables of a given process instance by id.
         * @param {string} id The id of the process instance to retrieve the variables from.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessInstanceVariables(id, deserializeValue, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessInstanceVariables(id, deserializeValue, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Queries for process instances that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of process instances. The size of the result set can be retrieved by using the Get Instance Count method.
         * @param {'instanceId' | 'definitionKey' | 'definitionId' | 'tenantId' | 'businessKey'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {string} [processInstanceIds] Filter by a comma-separated list of process instance ids.
         * @param {string} [businessKey] Filter by process instance business key.
         * @param {string} [businessKeyLike] Filter by process instance business key that the parameter is a substring of.
         * @param {string} [caseInstanceId] Filter by case instance id.
         * @param {string} [processDefinitionId] Filter by the deployment the id belongs to.
         * @param {string} [processDefinitionKey] Filter by the key of the process definition the instances run on.
         * @param {string} [processDefinitionKeyIn] Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys.
         * @param {string} [processDefinitionKeyNotIn] Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {string} [superProcessInstance] Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id.
         * @param {string} [subProcessInstance] Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id.
         * @param {string} [superCaseInstance] Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.
         * @param {string} [subCaseInstance] Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id.
         * @param {boolean} [active] Only include active process instances. Value may only be true, as false is the default behavior.
         * @param {boolean} [suspended] Only include suspended process instances. Value may only be true, as false is the default behavior.
         * @param {boolean} [withIncident] Filter by presence of incidents. Selects only process instances that have an incident.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process instances which belong to no tenant.
         * @param {boolean} [processDefinitionWithoutTenantId] Only include process instances which process definition has no tenant id.
         * @param {string} [activityIdIn] Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids.
         * @param {boolean} [rootProcessInstances] Restrict the query to all process instances that are top level process instances.
         * @param {boolean} [leafProcessInstances] Restrict the query to all process instances that are leaf instances. (i.e. don\&#39;t have any sub instances).
         * @param {string} [variables] Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessInstances(sortBy, sortOrder, firstResult, maxResults, processInstanceIds, businessKey, businessKeyLike, caseInstanceId, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionKeyNotIn, deploymentId, superProcessInstance, subProcessInstance, superCaseInstance, subCaseInstance, active, suspended, withIncident, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, processDefinitionWithoutTenantId, activityIdIn, rootProcessInstances, leafProcessInstances, variables, variableNamesIgnoreCase, variableValuesIgnoreCase, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessInstances(sortBy, sortOrder, firstResult, maxResults, processInstanceIds, businessKey, businessKeyLike, caseInstanceId, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionKeyNotIn, deploymentId, superProcessInstance, subProcessInstance, superCaseInstance, subCaseInstance, active, suspended, withIncident, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, processDefinitionWithoutTenantId, activityIdIn, rootProcessInstances, leafProcessInstances, variables, variableNamesIgnoreCase, variableValuesIgnoreCase, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Queries for the number of process instances that fulfill given parameters.
         * @param {string} [processInstanceIds] Filter by a comma-separated list of process instance ids.
         * @param {string} [businessKey] Filter by process instance business key.
         * @param {string} [businessKeyLike] Filter by process instance business key that the parameter is a substring of.
         * @param {string} [caseInstanceId] Filter by case instance id.
         * @param {string} [processDefinitionId] Filter by the deployment the id belongs to.
         * @param {string} [processDefinitionKey] Filter by the key of the process definition the instances run on.
         * @param {string} [processDefinitionKeyIn] Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys.
         * @param {string} [processDefinitionKeyNotIn] Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {string} [superProcessInstance] Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id.
         * @param {string} [subProcessInstance] Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id.
         * @param {string} [superCaseInstance] Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.
         * @param {string} [subCaseInstance] Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id.
         * @param {boolean} [active] Only include active process instances. Value may only be true, as false is the default behavior.
         * @param {boolean} [suspended] Only include suspended process instances. Value may only be true, as false is the default behavior.
         * @param {boolean} [withIncident] Filter by presence of incidents. Selects only process instances that have an incident.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process instances which belong to no tenant.
         * @param {boolean} [processDefinitionWithoutTenantId] Only include process instances which process definition has no tenant id.
         * @param {string} [activityIdIn] Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids.
         * @param {boolean} [rootProcessInstances] Restrict the query to all process instances that are top level process instances.
         * @param {boolean} [leafProcessInstances] Restrict the query to all process instances that are leaf instances. (i.e. don\&#39;t have any sub instances).
         * @param {string} [variables] Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessInstancesCount(processInstanceIds, businessKey, businessKeyLike, caseInstanceId, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionKeyNotIn, deploymentId, superProcessInstance, subProcessInstance, superCaseInstance, subCaseInstance, active, suspended, withIncident, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, processDefinitionWithoutTenantId, activityIdIn, rootProcessInstances, leafProcessInstances, variables, variableNamesIgnoreCase, variableValuesIgnoreCase, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessInstancesCount(processInstanceIds, businessKey, businessKeyLike, caseInstanceId, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionKeyNotIn, deploymentId, superProcessInstance, subProcessInstance, superCaseInstance, subCaseInstance, active, suspended, withIncident, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, processDefinitionWithoutTenantId, activityIdIn, rootProcessInstances, leafProcessInstances, variables, variableNamesIgnoreCase, variableValuesIgnoreCase, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Submits a list of modification instructions to change a process instance\'s execution state. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Canceling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed immediately and in the order they are provided in this request\'s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/develop/user-guide/process-engine/process-instance-modification/).
         * @param {string} id The id of the process instance to modify.
         * @param {ProcessInstanceModificationDto} [processInstanceModificationDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyProcessInstance(id, processInstanceModificationDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyProcessInstance(id, processInstanceModificationDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Submits a list of modification instructions to change a process instance\'s execution state async. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Cancelling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed asynchronous and in the order they are provided in this request\'s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-modification/).
         * @param {string} id The id of the process instance to modify.
         * @param {ProcessInstanceModificationDto} [processInstanceModificationDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyProcessInstanceAsyncOperation(id, processInstanceModificationDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyProcessInstanceAsyncOperation(id, processInstanceModificationDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Updates or deletes the variables of a process instance by id. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
         * @param {string} id The id of the process instance to set variables for.
         * @param {PatchVariablesDto} [patchVariablesDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyProcessInstanceVariables(id, patchVariablesDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyProcessInstanceVariables(id, patchVariablesDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Queries for process instances that fulfill given parameters through a JSON object. This method is slightly more powerful than the Get Instances method because it allows filtering by multiple process variables of types `string`, `number` or `boolean`.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {ProcessInstanceQueryDto} [processInstanceQueryDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryProcessInstances(firstResult, maxResults, processInstanceQueryDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryProcessInstances(firstResult, maxResults, processInstanceQueryDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Queries for the number of process instances that fulfill the given parameters. This method takes the same message body as the Get Instances (POST) method and therefore it is slightly more powerful than the Get Instance Count method.
         * @param {ProcessInstanceQueryDto} [processInstanceQueryDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryProcessInstancesCount(processInstanceQueryDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryProcessInstancesCount(processInstanceQueryDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Sets a variable of a given process instance by id.
         * @param {string} id The id of the process instance to set the variable for.
         * @param {string} varName The name of the variable to set.
         * @param {VariableValueDto} [variableValueDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setProcessInstanceVariable(id, varName, variableValueDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setProcessInstanceVariable(id, varName, variableValueDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Sets the serialized value for a binary variable or the binary value for a file variable.
         * @param {string} id The id of the process instance to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {any} [data] The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory.
         * @param {string} [valueType] The name of the variable type. Either Bytes for a byte array variable or File for a file variable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setProcessInstanceVariableBinary(id, varName, data, valueType, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setProcessInstanceVariableBinary(id, varName, data, valueType, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Create a batch to set retries of jobs associated with given processes asynchronously.
         * @param {SetJobRetriesByProcessDto} [setJobRetriesByProcessDto] Please note that if both processInstances and processInstanceQuery are provided, then the resulting execution will be performed on the union of these sets. **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRetriesByProcess(setJobRetriesByProcessDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setRetriesByProcess(setJobRetriesByProcessDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Create a batch to set retries of jobs asynchronously based on a historic process instance query.
         * @param {SetJobRetriesByProcessDto} [setJobRetriesByProcessDto] Please note that if both processInstances and historicProcessInstanceQuery are provided, then the resulting execution will be performed on the union of these sets. **Unallowed property**: &#x60;processInstanceQuery&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRetriesByProcessHistoricQueryBased(setJobRetriesByProcessDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setRetriesByProcessHistoricQueryBased(setJobRetriesByProcessDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Activates or suspends process instances by providing certain criteria:  # Activate/Suspend Process Instance By Process Definition Id * `suspend` * `processDefinitionId`  # Activate/Suspend Process Instance By Process Definition Key  * `suspend` * `processDefinitionKey` * `processDefinitionTenantId` * `processDefinitionWithoutTenantId`  # Activate/Suspend Process Instance In Group * `suspend` * `processInstanceIds` * `processInstanceQuery` * `historicProcessInstanceQuery`
         * @param {ProcessInstanceSuspensionStateDto} [processInstanceSuspensionStateDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSuspensionState(processInstanceSuspensionStateDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSuspensionState(processInstanceSuspensionStateDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Activates or suspends process instances asynchronously with a list of process instance ids, a process instance query, and/or a historical process instance query.
         * @param {ProcessInstanceSuspensionStateAsyncDto} [processInstanceSuspensionStateAsyncDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSuspensionStateAsyncOperation(processInstanceSuspensionStateAsyncDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSuspensionStateAsyncOperation(processInstanceSuspensionStateAsyncDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Activates or suspends a given process instance by id.
         * @param {string} id The id of the process instance to activate or suspend.
         * @param {SuspensionStateDto} [suspensionStateDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSuspensionStateById(id, suspensionStateDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSuspensionStateById(id, suspensionStateDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.ProcessInstanceApiFp = ProcessInstanceApiFp;
/**
 * ProcessInstanceApi - factory interface
 * @export
 */
const ProcessInstanceApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ProcessInstanceApiFp)(configuration);
    return {
        /**
         * Deletes a set of process instances asynchronously (batch) based on a historic process instance query.
         * @param {DeleteProcessInstancesDto} [deleteProcessInstancesDto] **Unallowed property**: &#x60;processInstanceQuery&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAsyncHistoricQueryBased(deleteProcessInstancesDto, options) {
            return localVarFp.deleteAsyncHistoricQueryBased(deleteProcessInstancesDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a running process instance by id.
         * @param {string} id The id of the process instance to be deleted.
         * @param {boolean} [skipCustomListeners] If set to true, the custom listeners will be skipped.
         * @param {boolean} [skipIoMappings] If set to true, the input/output mappings will be skipped.
         * @param {boolean} [skipSubprocesses] If set to true, subprocesses related to deleted processes will be skipped.
         * @param {boolean} [failIfNotExists] If set to false, the request will still be successful if the process id is not found.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessInstance(id, skipCustomListeners, skipIoMappings, skipSubprocesses, failIfNotExists, options) {
            return localVarFp.deleteProcessInstance(id, skipCustomListeners, skipIoMappings, skipSubprocesses, failIfNotExists, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a variable of a process instance by id.
         * @param {string} id The id of the process instance to delete the variable from.
         * @param {string} varName The name of the variable to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessInstanceVariable(id, varName, options) {
            return localVarFp.deleteProcessInstanceVariable(id, varName, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes multiple process instances asynchronously (batch).
         * @param {DeleteProcessInstancesDto} [deleteProcessInstancesDto] **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessInstancesAsyncOperation(deleteProcessInstancesDto, options) {
            return localVarFp.deleteProcessInstancesAsyncOperation(deleteProcessInstancesDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves an Activity Instance (Tree) for a given process instance by id.
         * @param {string} id The id of the process instance for which the activity instance should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityInstanceTree(id, options) {
            return localVarFp.getActivityInstanceTree(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a variable of a given process instance by id.
         * @param {string} id The id of the process instance to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstanceVariable(id, varName, deserializeValue, options) {
            return localVarFp.getProcessInstanceVariable(id, varName, deserializeValue, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the content of a Process Variable by the Process Instance id and the Process Variable name. Applicable for byte array or file Process Variables.
         * @param {string} id The id of the process instance to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstanceVariableBinary(id, varName, options) {
            return localVarFp.getProcessInstanceVariableBinary(id, varName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all variables of a given process instance by id.
         * @param {string} id The id of the process instance to retrieve the variables from.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstanceVariables(id, deserializeValue, options) {
            return localVarFp.getProcessInstanceVariables(id, deserializeValue, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for process instances that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of process instances. The size of the result set can be retrieved by using the Get Instance Count method.
         * @param {'instanceId' | 'definitionKey' | 'definitionId' | 'tenantId' | 'businessKey'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {string} [processInstanceIds] Filter by a comma-separated list of process instance ids.
         * @param {string} [businessKey] Filter by process instance business key.
         * @param {string} [businessKeyLike] Filter by process instance business key that the parameter is a substring of.
         * @param {string} [caseInstanceId] Filter by case instance id.
         * @param {string} [processDefinitionId] Filter by the deployment the id belongs to.
         * @param {string} [processDefinitionKey] Filter by the key of the process definition the instances run on.
         * @param {string} [processDefinitionKeyIn] Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys.
         * @param {string} [processDefinitionKeyNotIn] Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {string} [superProcessInstance] Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id.
         * @param {string} [subProcessInstance] Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id.
         * @param {string} [superCaseInstance] Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.
         * @param {string} [subCaseInstance] Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id.
         * @param {boolean} [active] Only include active process instances. Value may only be true, as false is the default behavior.
         * @param {boolean} [suspended] Only include suspended process instances. Value may only be true, as false is the default behavior.
         * @param {boolean} [withIncident] Filter by presence of incidents. Selects only process instances that have an incident.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process instances which belong to no tenant.
         * @param {boolean} [processDefinitionWithoutTenantId] Only include process instances which process definition has no tenant id.
         * @param {string} [activityIdIn] Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids.
         * @param {boolean} [rootProcessInstances] Restrict the query to all process instances that are top level process instances.
         * @param {boolean} [leafProcessInstances] Restrict the query to all process instances that are leaf instances. (i.e. don\&#39;t have any sub instances).
         * @param {string} [variables] Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstances(sortBy, sortOrder, firstResult, maxResults, processInstanceIds, businessKey, businessKeyLike, caseInstanceId, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionKeyNotIn, deploymentId, superProcessInstance, subProcessInstance, superCaseInstance, subCaseInstance, active, suspended, withIncident, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, processDefinitionWithoutTenantId, activityIdIn, rootProcessInstances, leafProcessInstances, variables, variableNamesIgnoreCase, variableValuesIgnoreCase, options) {
            return localVarFp.getProcessInstances(sortBy, sortOrder, firstResult, maxResults, processInstanceIds, businessKey, businessKeyLike, caseInstanceId, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionKeyNotIn, deploymentId, superProcessInstance, subProcessInstance, superCaseInstance, subCaseInstance, active, suspended, withIncident, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, processDefinitionWithoutTenantId, activityIdIn, rootProcessInstances, leafProcessInstances, variables, variableNamesIgnoreCase, variableValuesIgnoreCase, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for the number of process instances that fulfill given parameters.
         * @param {string} [processInstanceIds] Filter by a comma-separated list of process instance ids.
         * @param {string} [businessKey] Filter by process instance business key.
         * @param {string} [businessKeyLike] Filter by process instance business key that the parameter is a substring of.
         * @param {string} [caseInstanceId] Filter by case instance id.
         * @param {string} [processDefinitionId] Filter by the deployment the id belongs to.
         * @param {string} [processDefinitionKey] Filter by the key of the process definition the instances run on.
         * @param {string} [processDefinitionKeyIn] Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys.
         * @param {string} [processDefinitionKeyNotIn] Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {string} [superProcessInstance] Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id.
         * @param {string} [subProcessInstance] Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id.
         * @param {string} [superCaseInstance] Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.
         * @param {string} [subCaseInstance] Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id.
         * @param {boolean} [active] Only include active process instances. Value may only be true, as false is the default behavior.
         * @param {boolean} [suspended] Only include suspended process instances. Value may only be true, as false is the default behavior.
         * @param {boolean} [withIncident] Filter by presence of incidents. Selects only process instances that have an incident.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process instances which belong to no tenant.
         * @param {boolean} [processDefinitionWithoutTenantId] Only include process instances which process definition has no tenant id.
         * @param {string} [activityIdIn] Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids.
         * @param {boolean} [rootProcessInstances] Restrict the query to all process instances that are top level process instances.
         * @param {boolean} [leafProcessInstances] Restrict the query to all process instances that are leaf instances. (i.e. don\&#39;t have any sub instances).
         * @param {string} [variables] Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstancesCount(processInstanceIds, businessKey, businessKeyLike, caseInstanceId, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionKeyNotIn, deploymentId, superProcessInstance, subProcessInstance, superCaseInstance, subCaseInstance, active, suspended, withIncident, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, processDefinitionWithoutTenantId, activityIdIn, rootProcessInstances, leafProcessInstances, variables, variableNamesIgnoreCase, variableValuesIgnoreCase, options) {
            return localVarFp.getProcessInstancesCount(processInstanceIds, businessKey, businessKeyLike, caseInstanceId, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionKeyNotIn, deploymentId, superProcessInstance, subProcessInstance, superCaseInstance, subCaseInstance, active, suspended, withIncident, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, processDefinitionWithoutTenantId, activityIdIn, rootProcessInstances, leafProcessInstances, variables, variableNamesIgnoreCase, variableValuesIgnoreCase, options).then((request) => request(axios, basePath));
        },
        /**
         * Submits a list of modification instructions to change a process instance\'s execution state. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Canceling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed immediately and in the order they are provided in this request\'s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/develop/user-guide/process-engine/process-instance-modification/).
         * @param {string} id The id of the process instance to modify.
         * @param {ProcessInstanceModificationDto} [processInstanceModificationDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyProcessInstance(id, processInstanceModificationDto, options) {
            return localVarFp.modifyProcessInstance(id, processInstanceModificationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Submits a list of modification instructions to change a process instance\'s execution state async. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Cancelling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed asynchronous and in the order they are provided in this request\'s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-modification/).
         * @param {string} id The id of the process instance to modify.
         * @param {ProcessInstanceModificationDto} [processInstanceModificationDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyProcessInstanceAsyncOperation(id, processInstanceModificationDto, options) {
            return localVarFp.modifyProcessInstanceAsyncOperation(id, processInstanceModificationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates or deletes the variables of a process instance by id. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
         * @param {string} id The id of the process instance to set variables for.
         * @param {PatchVariablesDto} [patchVariablesDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyProcessInstanceVariables(id, patchVariablesDto, options) {
            return localVarFp.modifyProcessInstanceVariables(id, patchVariablesDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for process instances that fulfill given parameters through a JSON object. This method is slightly more powerful than the Get Instances method because it allows filtering by multiple process variables of types `string`, `number` or `boolean`.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {ProcessInstanceQueryDto} [processInstanceQueryDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryProcessInstances(firstResult, maxResults, processInstanceQueryDto, options) {
            return localVarFp.queryProcessInstances(firstResult, maxResults, processInstanceQueryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for the number of process instances that fulfill the given parameters. This method takes the same message body as the Get Instances (POST) method and therefore it is slightly more powerful than the Get Instance Count method.
         * @param {ProcessInstanceQueryDto} [processInstanceQueryDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryProcessInstancesCount(processInstanceQueryDto, options) {
            return localVarFp.queryProcessInstancesCount(processInstanceQueryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets a variable of a given process instance by id.
         * @param {string} id The id of the process instance to set the variable for.
         * @param {string} varName The name of the variable to set.
         * @param {VariableValueDto} [variableValueDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProcessInstanceVariable(id, varName, variableValueDto, options) {
            return localVarFp.setProcessInstanceVariable(id, varName, variableValueDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the serialized value for a binary variable or the binary value for a file variable.
         * @param {string} id The id of the process instance to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {any} [data] The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory.
         * @param {string} [valueType] The name of the variable type. Either Bytes for a byte array variable or File for a file variable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProcessInstanceVariableBinary(id, varName, data, valueType, options) {
            return localVarFp.setProcessInstanceVariableBinary(id, varName, data, valueType, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a batch to set retries of jobs associated with given processes asynchronously.
         * @param {SetJobRetriesByProcessDto} [setJobRetriesByProcessDto] Please note that if both processInstances and processInstanceQuery are provided, then the resulting execution will be performed on the union of these sets. **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRetriesByProcess(setJobRetriesByProcessDto, options) {
            return localVarFp.setRetriesByProcess(setJobRetriesByProcessDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a batch to set retries of jobs asynchronously based on a historic process instance query.
         * @param {SetJobRetriesByProcessDto} [setJobRetriesByProcessDto] Please note that if both processInstances and historicProcessInstanceQuery are provided, then the resulting execution will be performed on the union of these sets. **Unallowed property**: &#x60;processInstanceQuery&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRetriesByProcessHistoricQueryBased(setJobRetriesByProcessDto, options) {
            return localVarFp.setRetriesByProcessHistoricQueryBased(setJobRetriesByProcessDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Activates or suspends process instances by providing certain criteria:  # Activate/Suspend Process Instance By Process Definition Id * `suspend` * `processDefinitionId`  # Activate/Suspend Process Instance By Process Definition Key  * `suspend` * `processDefinitionKey` * `processDefinitionTenantId` * `processDefinitionWithoutTenantId`  # Activate/Suspend Process Instance In Group * `suspend` * `processInstanceIds` * `processInstanceQuery` * `historicProcessInstanceQuery`
         * @param {ProcessInstanceSuspensionStateDto} [processInstanceSuspensionStateDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSuspensionState(processInstanceSuspensionStateDto, options) {
            return localVarFp.updateSuspensionState(processInstanceSuspensionStateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Activates or suspends process instances asynchronously with a list of process instance ids, a process instance query, and/or a historical process instance query.
         * @param {ProcessInstanceSuspensionStateAsyncDto} [processInstanceSuspensionStateAsyncDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSuspensionStateAsyncOperation(processInstanceSuspensionStateAsyncDto, options) {
            return localVarFp.updateSuspensionStateAsyncOperation(processInstanceSuspensionStateAsyncDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Activates or suspends a given process instance by id.
         * @param {string} id The id of the process instance to activate or suspend.
         * @param {SuspensionStateDto} [suspensionStateDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSuspensionStateById(id, suspensionStateDto, options) {
            return localVarFp.updateSuspensionStateById(id, suspensionStateDto, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ProcessInstanceApiFactory = ProcessInstanceApiFactory;
/**
 * ProcessInstanceApi - object-oriented interface
 * @export
 * @class ProcessInstanceApi
 * @extends {BaseAPI}
 */
class ProcessInstanceApi extends base_1.BaseAPI {
    /**
     * Deletes a set of process instances asynchronously (batch) based on a historic process instance query.
     * @param {DeleteProcessInstancesDto} [deleteProcessInstancesDto] **Unallowed property**: &#x60;processInstanceQuery&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    deleteAsyncHistoricQueryBased(deleteProcessInstancesDto, options) {
        return (0, exports.ProcessInstanceApiFp)(this.configuration).deleteAsyncHistoricQueryBased(deleteProcessInstancesDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes a running process instance by id.
     * @param {string} id The id of the process instance to be deleted.
     * @param {boolean} [skipCustomListeners] If set to true, the custom listeners will be skipped.
     * @param {boolean} [skipIoMappings] If set to true, the input/output mappings will be skipped.
     * @param {boolean} [skipSubprocesses] If set to true, subprocesses related to deleted processes will be skipped.
     * @param {boolean} [failIfNotExists] If set to false, the request will still be successful if the process id is not found.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    deleteProcessInstance(id, skipCustomListeners, skipIoMappings, skipSubprocesses, failIfNotExists, options) {
        return (0, exports.ProcessInstanceApiFp)(this.configuration).deleteProcessInstance(id, skipCustomListeners, skipIoMappings, skipSubprocesses, failIfNotExists, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes a variable of a process instance by id.
     * @param {string} id The id of the process instance to delete the variable from.
     * @param {string} varName The name of the variable to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    deleteProcessInstanceVariable(id, varName, options) {
        return (0, exports.ProcessInstanceApiFp)(this.configuration).deleteProcessInstanceVariable(id, varName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes multiple process instances asynchronously (batch).
     * @param {DeleteProcessInstancesDto} [deleteProcessInstancesDto] **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    deleteProcessInstancesAsyncOperation(deleteProcessInstancesDto, options) {
        return (0, exports.ProcessInstanceApiFp)(this.configuration).deleteProcessInstancesAsyncOperation(deleteProcessInstancesDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves an Activity Instance (Tree) for a given process instance by id.
     * @param {string} id The id of the process instance for which the activity instance should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    getActivityInstanceTree(id, options) {
        return (0, exports.ProcessInstanceApiFp)(this.configuration).getActivityInstanceTree(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a variable of a given process instance by id.
     * @param {string} id The id of the process instance to retrieve the variable for.
     * @param {string} varName The name of the variable to retrieve.
     * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    getProcessInstanceVariable(id, varName, deserializeValue, options) {
        return (0, exports.ProcessInstanceApiFp)(this.configuration).getProcessInstanceVariable(id, varName, deserializeValue, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the content of a Process Variable by the Process Instance id and the Process Variable name. Applicable for byte array or file Process Variables.
     * @param {string} id The id of the process instance to retrieve the variable for.
     * @param {string} varName The name of the variable to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    getProcessInstanceVariableBinary(id, varName, options) {
        return (0, exports.ProcessInstanceApiFp)(this.configuration).getProcessInstanceVariableBinary(id, varName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves all variables of a given process instance by id.
     * @param {string} id The id of the process instance to retrieve the variables from.
     * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    getProcessInstanceVariables(id, deserializeValue, options) {
        return (0, exports.ProcessInstanceApiFp)(this.configuration).getProcessInstanceVariables(id, deserializeValue, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for process instances that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of process instances. The size of the result set can be retrieved by using the Get Instance Count method.
     * @param {'instanceId' | 'definitionKey' | 'definitionId' | 'tenantId' | 'businessKey'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {string} [processInstanceIds] Filter by a comma-separated list of process instance ids.
     * @param {string} [businessKey] Filter by process instance business key.
     * @param {string} [businessKeyLike] Filter by process instance business key that the parameter is a substring of.
     * @param {string} [caseInstanceId] Filter by case instance id.
     * @param {string} [processDefinitionId] Filter by the deployment the id belongs to.
     * @param {string} [processDefinitionKey] Filter by the key of the process definition the instances run on.
     * @param {string} [processDefinitionKeyIn] Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys.
     * @param {string} [processDefinitionKeyNotIn] Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys.
     * @param {string} [deploymentId] Filter by the deployment the id belongs to.
     * @param {string} [superProcessInstance] Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id.
     * @param {string} [subProcessInstance] Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id.
     * @param {string} [superCaseInstance] Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.
     * @param {string} [subCaseInstance] Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id.
     * @param {boolean} [active] Only include active process instances. Value may only be true, as false is the default behavior.
     * @param {boolean} [suspended] Only include suspended process instances. Value may only be true, as false is the default behavior.
     * @param {boolean} [withIncident] Filter by presence of incidents. Selects only process instances that have an incident.
     * @param {string} [incidentId] Filter by the incident id.
     * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param {string} [incidentMessage] Filter by the incident message. Exact match.
     * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
     * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids.
     * @param {boolean} [withoutTenantId] Only include process instances which belong to no tenant.
     * @param {boolean} [processDefinitionWithoutTenantId] Only include process instances which process definition has no tenant id.
     * @param {string} [activityIdIn] Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids.
     * @param {boolean} [rootProcessInstances] Restrict the query to all process instances that are top level process instances.
     * @param {boolean} [leafProcessInstances] Restrict the query to all process instances that are leaf instances. (i.e. don\&#39;t have any sub instances).
     * @param {string} [variables] Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal.
     * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    getProcessInstances(sortBy, sortOrder, firstResult, maxResults, processInstanceIds, businessKey, businessKeyLike, caseInstanceId, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionKeyNotIn, deploymentId, superProcessInstance, subProcessInstance, superCaseInstance, subCaseInstance, active, suspended, withIncident, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, processDefinitionWithoutTenantId, activityIdIn, rootProcessInstances, leafProcessInstances, variables, variableNamesIgnoreCase, variableValuesIgnoreCase, options) {
        return (0, exports.ProcessInstanceApiFp)(this.configuration).getProcessInstances(sortBy, sortOrder, firstResult, maxResults, processInstanceIds, businessKey, businessKeyLike, caseInstanceId, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionKeyNotIn, deploymentId, superProcessInstance, subProcessInstance, superCaseInstance, subCaseInstance, active, suspended, withIncident, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, processDefinitionWithoutTenantId, activityIdIn, rootProcessInstances, leafProcessInstances, variables, variableNamesIgnoreCase, variableValuesIgnoreCase, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for the number of process instances that fulfill given parameters.
     * @param {string} [processInstanceIds] Filter by a comma-separated list of process instance ids.
     * @param {string} [businessKey] Filter by process instance business key.
     * @param {string} [businessKeyLike] Filter by process instance business key that the parameter is a substring of.
     * @param {string} [caseInstanceId] Filter by case instance id.
     * @param {string} [processDefinitionId] Filter by the deployment the id belongs to.
     * @param {string} [processDefinitionKey] Filter by the key of the process definition the instances run on.
     * @param {string} [processDefinitionKeyIn] Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys.
     * @param {string} [processDefinitionKeyNotIn] Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys.
     * @param {string} [deploymentId] Filter by the deployment the id belongs to.
     * @param {string} [superProcessInstance] Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id.
     * @param {string} [subProcessInstance] Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id.
     * @param {string} [superCaseInstance] Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.
     * @param {string} [subCaseInstance] Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id.
     * @param {boolean} [active] Only include active process instances. Value may only be true, as false is the default behavior.
     * @param {boolean} [suspended] Only include suspended process instances. Value may only be true, as false is the default behavior.
     * @param {boolean} [withIncident] Filter by presence of incidents. Selects only process instances that have an incident.
     * @param {string} [incidentId] Filter by the incident id.
     * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param {string} [incidentMessage] Filter by the incident message. Exact match.
     * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
     * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids.
     * @param {boolean} [withoutTenantId] Only include process instances which belong to no tenant.
     * @param {boolean} [processDefinitionWithoutTenantId] Only include process instances which process definition has no tenant id.
     * @param {string} [activityIdIn] Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids.
     * @param {boolean} [rootProcessInstances] Restrict the query to all process instances that are top level process instances.
     * @param {boolean} [leafProcessInstances] Restrict the query to all process instances that are leaf instances. (i.e. don\&#39;t have any sub instances).
     * @param {string} [variables] Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal.
     * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    getProcessInstancesCount(processInstanceIds, businessKey, businessKeyLike, caseInstanceId, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionKeyNotIn, deploymentId, superProcessInstance, subProcessInstance, superCaseInstance, subCaseInstance, active, suspended, withIncident, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, processDefinitionWithoutTenantId, activityIdIn, rootProcessInstances, leafProcessInstances, variables, variableNamesIgnoreCase, variableValuesIgnoreCase, options) {
        return (0, exports.ProcessInstanceApiFp)(this.configuration).getProcessInstancesCount(processInstanceIds, businessKey, businessKeyLike, caseInstanceId, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionKeyNotIn, deploymentId, superProcessInstance, subProcessInstance, superCaseInstance, subCaseInstance, active, suspended, withIncident, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, processDefinitionWithoutTenantId, activityIdIn, rootProcessInstances, leafProcessInstances, variables, variableNamesIgnoreCase, variableValuesIgnoreCase, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Submits a list of modification instructions to change a process instance\'s execution state. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Canceling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed immediately and in the order they are provided in this request\'s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/develop/user-guide/process-engine/process-instance-modification/).
     * @param {string} id The id of the process instance to modify.
     * @param {ProcessInstanceModificationDto} [processInstanceModificationDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    modifyProcessInstance(id, processInstanceModificationDto, options) {
        return (0, exports.ProcessInstanceApiFp)(this.configuration).modifyProcessInstance(id, processInstanceModificationDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Submits a list of modification instructions to change a process instance\'s execution state async. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Cancelling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed asynchronous and in the order they are provided in this request\'s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-modification/).
     * @param {string} id The id of the process instance to modify.
     * @param {ProcessInstanceModificationDto} [processInstanceModificationDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    modifyProcessInstanceAsyncOperation(id, processInstanceModificationDto, options) {
        return (0, exports.ProcessInstanceApiFp)(this.configuration).modifyProcessInstanceAsyncOperation(id, processInstanceModificationDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates or deletes the variables of a process instance by id. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
     * @param {string} id The id of the process instance to set variables for.
     * @param {PatchVariablesDto} [patchVariablesDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    modifyProcessInstanceVariables(id, patchVariablesDto, options) {
        return (0, exports.ProcessInstanceApiFp)(this.configuration).modifyProcessInstanceVariables(id, patchVariablesDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for process instances that fulfill given parameters through a JSON object. This method is slightly more powerful than the Get Instances method because it allows filtering by multiple process variables of types `string`, `number` or `boolean`.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {ProcessInstanceQueryDto} [processInstanceQueryDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    queryProcessInstances(firstResult, maxResults, processInstanceQueryDto, options) {
        return (0, exports.ProcessInstanceApiFp)(this.configuration).queryProcessInstances(firstResult, maxResults, processInstanceQueryDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for the number of process instances that fulfill the given parameters. This method takes the same message body as the Get Instances (POST) method and therefore it is slightly more powerful than the Get Instance Count method.
     * @param {ProcessInstanceQueryDto} [processInstanceQueryDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    queryProcessInstancesCount(processInstanceQueryDto, options) {
        return (0, exports.ProcessInstanceApiFp)(this.configuration).queryProcessInstancesCount(processInstanceQueryDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets a variable of a given process instance by id.
     * @param {string} id The id of the process instance to set the variable for.
     * @param {string} varName The name of the variable to set.
     * @param {VariableValueDto} [variableValueDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    setProcessInstanceVariable(id, varName, variableValueDto, options) {
        return (0, exports.ProcessInstanceApiFp)(this.configuration).setProcessInstanceVariable(id, varName, variableValueDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets the serialized value for a binary variable or the binary value for a file variable.
     * @param {string} id The id of the process instance to retrieve the variable for.
     * @param {string} varName The name of the variable to retrieve.
     * @param {any} [data] The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory.
     * @param {string} [valueType] The name of the variable type. Either Bytes for a byte array variable or File for a file variable.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    setProcessInstanceVariableBinary(id, varName, data, valueType, options) {
        return (0, exports.ProcessInstanceApiFp)(this.configuration).setProcessInstanceVariableBinary(id, varName, data, valueType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a batch to set retries of jobs associated with given processes asynchronously.
     * @param {SetJobRetriesByProcessDto} [setJobRetriesByProcessDto] Please note that if both processInstances and processInstanceQuery are provided, then the resulting execution will be performed on the union of these sets. **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    setRetriesByProcess(setJobRetriesByProcessDto, options) {
        return (0, exports.ProcessInstanceApiFp)(this.configuration).setRetriesByProcess(setJobRetriesByProcessDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a batch to set retries of jobs asynchronously based on a historic process instance query.
     * @param {SetJobRetriesByProcessDto} [setJobRetriesByProcessDto] Please note that if both processInstances and historicProcessInstanceQuery are provided, then the resulting execution will be performed on the union of these sets. **Unallowed property**: &#x60;processInstanceQuery&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    setRetriesByProcessHistoricQueryBased(setJobRetriesByProcessDto, options) {
        return (0, exports.ProcessInstanceApiFp)(this.configuration).setRetriesByProcessHistoricQueryBased(setJobRetriesByProcessDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Activates or suspends process instances by providing certain criteria:  # Activate/Suspend Process Instance By Process Definition Id * `suspend` * `processDefinitionId`  # Activate/Suspend Process Instance By Process Definition Key  * `suspend` * `processDefinitionKey` * `processDefinitionTenantId` * `processDefinitionWithoutTenantId`  # Activate/Suspend Process Instance In Group * `suspend` * `processInstanceIds` * `processInstanceQuery` * `historicProcessInstanceQuery`
     * @param {ProcessInstanceSuspensionStateDto} [processInstanceSuspensionStateDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    updateSuspensionState(processInstanceSuspensionStateDto, options) {
        return (0, exports.ProcessInstanceApiFp)(this.configuration).updateSuspensionState(processInstanceSuspensionStateDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Activates or suspends process instances asynchronously with a list of process instance ids, a process instance query, and/or a historical process instance query.
     * @param {ProcessInstanceSuspensionStateAsyncDto} [processInstanceSuspensionStateAsyncDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    updateSuspensionStateAsyncOperation(processInstanceSuspensionStateAsyncDto, options) {
        return (0, exports.ProcessInstanceApiFp)(this.configuration).updateSuspensionStateAsyncOperation(processInstanceSuspensionStateAsyncDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Activates or suspends a given process instance by id.
     * @param {string} id The id of the process instance to activate or suspend.
     * @param {SuspensionStateDto} [suspensionStateDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    updateSuspensionStateById(id, suspensionStateDto, options) {
        return (0, exports.ProcessInstanceApiFp)(this.configuration).updateSuspensionStateById(id, suspensionStateDto, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ProcessInstanceApi = ProcessInstanceApi;
/**
 * SchemaLogApi - axios parameter creator
 * @export
 */
const SchemaLogApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Queries for schema log entries that fulfill given parameters.
         * @param {string} [version] Only return schema log entries with a specific version.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchemaLog: async (version, firstResult, maxResults, options = {}) => {
            const localVarPath = `/schema/log`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }
            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }
            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for schema log entries that fulfill given parameters.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {SchemaLogQueryDto} [schemaLogQueryDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querySchemaLog: async (firstResult, maxResults, schemaLogQueryDto, options = {}) => {
            const localVarPath = `/schema/log`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }
            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(schemaLogQueryDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.SchemaLogApiAxiosParamCreator = SchemaLogApiAxiosParamCreator;
/**
 * SchemaLogApi - functional programming interface
 * @export
 */
const SchemaLogApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.SchemaLogApiAxiosParamCreator)(configuration);
    return {
        /**
         * Queries for schema log entries that fulfill given parameters.
         * @param {string} [version] Only return schema log entries with a specific version.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchemaLog(version, firstResult, maxResults, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchemaLog(version, firstResult, maxResults, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Queries for schema log entries that fulfill given parameters.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {SchemaLogQueryDto} [schemaLogQueryDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async querySchemaLog(firstResult, maxResults, schemaLogQueryDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.querySchemaLog(firstResult, maxResults, schemaLogQueryDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.SchemaLogApiFp = SchemaLogApiFp;
/**
 * SchemaLogApi - factory interface
 * @export
 */
const SchemaLogApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.SchemaLogApiFp)(configuration);
    return {
        /**
         * Queries for schema log entries that fulfill given parameters.
         * @param {string} [version] Only return schema log entries with a specific version.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchemaLog(version, firstResult, maxResults, options) {
            return localVarFp.getSchemaLog(version, firstResult, maxResults, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for schema log entries that fulfill given parameters.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {SchemaLogQueryDto} [schemaLogQueryDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querySchemaLog(firstResult, maxResults, schemaLogQueryDto, options) {
            return localVarFp.querySchemaLog(firstResult, maxResults, schemaLogQueryDto, options).then((request) => request(axios, basePath));
        },
    };
};
exports.SchemaLogApiFactory = SchemaLogApiFactory;
/**
 * SchemaLogApi - object-oriented interface
 * @export
 * @class SchemaLogApi
 * @extends {BaseAPI}
 */
class SchemaLogApi extends base_1.BaseAPI {
    /**
     * Queries for schema log entries that fulfill given parameters.
     * @param {string} [version] Only return schema log entries with a specific version.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaLogApi
     */
    getSchemaLog(version, firstResult, maxResults, options) {
        return (0, exports.SchemaLogApiFp)(this.configuration).getSchemaLog(version, firstResult, maxResults, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for schema log entries that fulfill given parameters.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {SchemaLogQueryDto} [schemaLogQueryDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaLogApi
     */
    querySchemaLog(firstResult, maxResults, schemaLogQueryDto, options) {
        return (0, exports.SchemaLogApiFp)(this.configuration).querySchemaLog(firstResult, maxResults, schemaLogQueryDto, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SchemaLogApi = SchemaLogApi;
/**
 * SignalApi - axios parameter creator
 * @export
 */
const SignalApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * A signal is an event of global scope (broadcast semantics) and is delivered to all active handlers. Internally this maps to the engine\'s signal event received builder method `RuntimeService#createSignalEvent()`. For more information about the signal behavior, see the [Signal Events](https://docs.camunda.org/manual/7.13/reference/bpmn20/events/signal-events/) section of the [BPMN 2.0 Implementation Reference](https://docs.camunda.org/manual/7.13/reference/bpmn20/).
         * @param {SignalDto} [signalDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        throwSignal: async (signalDto, options = {}) => {
            const localVarPath = `/signal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(signalDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.SignalApiAxiosParamCreator = SignalApiAxiosParamCreator;
/**
 * SignalApi - functional programming interface
 * @export
 */
const SignalApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.SignalApiAxiosParamCreator)(configuration);
    return {
        /**
         * A signal is an event of global scope (broadcast semantics) and is delivered to all active handlers. Internally this maps to the engine\'s signal event received builder method `RuntimeService#createSignalEvent()`. For more information about the signal behavior, see the [Signal Events](https://docs.camunda.org/manual/7.13/reference/bpmn20/events/signal-events/) section of the [BPMN 2.0 Implementation Reference](https://docs.camunda.org/manual/7.13/reference/bpmn20/).
         * @param {SignalDto} [signalDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async throwSignal(signalDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.throwSignal(signalDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.SignalApiFp = SignalApiFp;
/**
 * SignalApi - factory interface
 * @export
 */
const SignalApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.SignalApiFp)(configuration);
    return {
        /**
         * A signal is an event of global scope (broadcast semantics) and is delivered to all active handlers. Internally this maps to the engine\'s signal event received builder method `RuntimeService#createSignalEvent()`. For more information about the signal behavior, see the [Signal Events](https://docs.camunda.org/manual/7.13/reference/bpmn20/events/signal-events/) section of the [BPMN 2.0 Implementation Reference](https://docs.camunda.org/manual/7.13/reference/bpmn20/).
         * @param {SignalDto} [signalDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        throwSignal(signalDto, options) {
            return localVarFp.throwSignal(signalDto, options).then((request) => request(axios, basePath));
        },
    };
};
exports.SignalApiFactory = SignalApiFactory;
/**
 * SignalApi - object-oriented interface
 * @export
 * @class SignalApi
 * @extends {BaseAPI}
 */
class SignalApi extends base_1.BaseAPI {
    /**
     * A signal is an event of global scope (broadcast semantics) and is delivered to all active handlers. Internally this maps to the engine\'s signal event received builder method `RuntimeService#createSignalEvent()`. For more information about the signal behavior, see the [Signal Events](https://docs.camunda.org/manual/7.13/reference/bpmn20/events/signal-events/) section of the [BPMN 2.0 Implementation Reference](https://docs.camunda.org/manual/7.13/reference/bpmn20/).
     * @param {SignalDto} [signalDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignalApi
     */
    throwSignal(signalDto, options) {
        return (0, exports.SignalApiFp)(this.configuration).throwSignal(signalDto, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SignalApi = SignalApi;
/**
 * TaskApi - axios parameter creator
 * @export
 */
const TaskApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Claims a task for a specific user.  **Note:** The difference with the [Set Assignee](https://docs.camunda.org/manual/7.13/reference/rest/task/post-assignee/) method is that here a check is performed to see if the task already has a user assigned to it.
         * @param {string} id The id of the task to claim.
         * @param {UserIdDto} [userIdDto] Provide the id of the user that claims the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claim: async (id, userIdDto, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('claim', 'id', id);
            const localVarPath = `/task/{id}/claim`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(userIdDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Completes a task and updates process variables.
         * @param {string} id The id of the task to complete.
         * @param {CompleteTaskDto} [completeTaskDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        complete: async (id, completeTaskDto, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('complete', 'id', id);
            const localVarPath = `/task/{id}/complete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(completeTaskDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new task.
         * @param {TaskDto} [taskDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTask: async (taskDto, options = {}) => {
            const localVarPath = `/task/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(taskDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delegates a task to another user.
         * @param {string} id The id of the task to delegate.
         * @param {UserIdDto} [userIdDto] Provide the id of the user that the task should be delegated to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegateTask: async (id, userIdDto, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('delegateTask', 'id', id);
            const localVarPath = `/task/{id}/delegate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(userIdDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a task by id.
         * @param {string} id The id of the task to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTask: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteTask', 'id', id);
            const localVarPath = `/task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the deployed form that is referenced from a given task. For further information please refer to the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
         * @param {string} id The id of the task to get the deployed form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedForm: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getDeployedForm', 'id', id);
            const localVarPath = `/task/{id}/deployed-form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the form key for a task. The form key corresponds to the `FormData#formKey` property in the engine. This key can be used to do task-specific form rendering in client applications. Additionally, the context path of the containing process application is returned.
         * @param {string} id The id of the task to retrieve the form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForm: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getForm', 'id', id);
            const localVarPath = `/task/{id}/form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the form variables for a task. The form variables take form data specified on the task into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @param {string} id The id of the task to retrieve the variables for.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFormVariables: async (id, variableNames, deserializeValues, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getFormVariables', 'id', id);
            const localVarPath = `/task/{id}/form-variables`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (variableNames !== undefined) {
                localVarQueryParameter['variableNames'] = variableNames;
            }
            if (deserializeValues !== undefined) {
                localVarQueryParameter['deserializeValues'] = deserializeValues;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the rendered form for a task. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @param {string} id The id of the task to get the rendered form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRenderedForm: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getRenderedForm', 'id', id);
            const localVarPath = `/task/{id}/rendered-form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a task by id.
         * @param {string} id The id of the task to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getTask', 'id', id);
            const localVarPath = `/task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for tasks that fulfill a given filter. The size of the result set can be retrieved by using the Get Task Count method.  **Security Consideration:** There are several query parameters (such as assigneeExpression) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) for custom code in the user guide for details.
         * @param {string} [processInstanceId] Restrict to tasks that belong to process instances with the given id.
         * @param {string} [processInstanceIdIn] Restrict to tasks that belong to process instances with the given ids.
         * @param {string} [processInstanceBusinessKey] Restrict to tasks that belong to process instances with the given business key.
         * @param {string} [processInstanceBusinessKeyExpression] Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {string} [processInstanceBusinessKeyIn] Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
         * @param {string} [processInstanceBusinessKeyLike] Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
         * @param {string} [processInstanceBusinessKeyLikeExpression] Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [processDefinitionId] Restrict to tasks that belong to a process definition with the given id.
         * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
         * @param {string} [processDefinitionKeyIn] Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
         * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
         * @param {string} [processDefinitionNameLike] Restrict to tasks that have a process definition name that has the parameter value as  a substring.
         * @param {string} [executionId] Restrict to tasks that belong to an execution with the given id.
         * @param {string} [caseInstanceId] Restrict to tasks that belong to case instances with the given id.
         * @param {string} [caseInstanceBusinessKey] Restrict to tasks that belong to case instances with the given business key.
         * @param {string} [caseInstanceBusinessKeyLike] Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
         * @param {string} [caseDefinitionId] Restrict to tasks that belong to a case definition with the given id.
         * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
         * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
         * @param {string} [caseDefinitionNameLike] Restrict to tasks that have a case definition name that has the parameter value as a  substring.
         * @param {string} [caseExecutionId] Restrict to tasks that belong to a case execution with the given id.
         * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
         * @param {string} [tenantIdIn] Only include tasks which belong to one of the passed and comma-separated  tenant ids.
         * @param {boolean} [withoutTenantId] Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
         * @param {string} [assignee] Restrict to tasks that the given user is assigned to.
         * @param {string} [assigneeExpression] Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeLike] Restrict to tasks that have an assignee that has the parameter  value as a substring.
         * @param {string} [assigneeLikeExpression] Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeIn] Only include tasks which are assigned to one of the passed and  comma-separated user ids.
         * @param {string} [owner] Restrict to tasks that the given user owns.
         * @param {string} [ownerExpression] Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateGroup] Only include tasks that are offered to the given group.
         * @param {string} [candidateGroupExpression] Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateUser] Only include tasks that are offered to the given user or to one of his groups.
         * @param {string} [candidateUserExpression] Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {boolean} [includeAssignedTasks] Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
         * @param {string} [involvedUser] Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
         * @param {string} [involvedUserExpression] Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
         * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
         * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
         * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
         * @param {string} [taskDefinitionKeyLike] Restrict to tasks that have a key that has the parameter value as a substring.
         * @param {string} [name] Restrict to tasks that have the given name.
         * @param {string} [nameNotEqual] Restrict to tasks that do not have the given name.
         * @param {string} [nameLike] Restrict to tasks that have a name with the given parameter value as substring.
         * @param {string} [nameNotLike] Restrict to tasks that do not have a name with the given parameter value as substring.
         * @param {string} [description] Restrict to tasks that have the given description.
         * @param {string} [descriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
         * @param {number} [priority] Restrict to tasks that have the given priority.
         * @param {number} [maxPriority] Restrict to tasks that have a lower or equal priority.
         * @param {number} [minPriority] Restrict to tasks that have a higher or equal priority.
         * @param {string} [dueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [dueDateExpression] Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
         * @param {string} [dueAfterExpression] Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
         * @param {string} [dueBeforeExpression] Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [followUpDateExpression] Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
         * @param {string} [followUpAfterExpression] Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
         * @param {string} [followUpBeforeExpression] Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBeforeOrNotExistent] Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
         * @param {string} [followUpBeforeOrNotExistentExpression] Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdOn] Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
         * @param {string} [createdOnExpression] Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdAfter] Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [createdAfterExpression] Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdBefore] Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
         * @param {string} [createdBeforeExpression] Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {'PENDING' | 'RESOLVED'} [delegationState] Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
         * @param {string} [candidateGroups] Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
         * @param {string} [candidateGroupsExpression] Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
         * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withCandidateUsers] Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateUsers] Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [caseInstanceVariables] Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
         * @param {string} [parentTaskId] Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
         * @param {'instanceId' | 'caseInstanceId' | 'dueDate' | 'executionId' | 'caseExecutionId' | 'assignee' | 'created' | 'description' | 'id' | 'name' | 'nameCaseInsensitive' | 'priority' | 'processVariable' | 'executionVariable' | 'taskVariable' | 'caseExecutionVariable' | 'caseInstanceVariable'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks: async (processInstanceId, processInstanceIdIn, processInstanceBusinessKey, processInstanceBusinessKeyExpression, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, processInstanceBusinessKeyLikeExpression, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionName, processDefinitionNameLike, executionId, caseInstanceId, caseInstanceBusinessKey, caseInstanceBusinessKeyLike, caseDefinitionId, caseDefinitionKey, caseDefinitionName, caseDefinitionNameLike, caseExecutionId, activityInstanceIdIn, tenantIdIn, withoutTenantId, assignee, assigneeExpression, assigneeLike, assigneeLikeExpression, assigneeIn, owner, ownerExpression, candidateGroup, candidateGroupExpression, candidateUser, candidateUserExpression, includeAssignedTasks, involvedUser, involvedUserExpression, assigned, unassigned, taskDefinitionKey, taskDefinitionKeyIn, taskDefinitionKeyLike, name, nameNotEqual, nameLike, nameNotLike, description, descriptionLike, priority, maxPriority, minPriority, dueDate, dueDateExpression, dueAfter, dueAfterExpression, dueBefore, dueBeforeExpression, followUpDate, followUpDateExpression, followUpAfter, followUpAfterExpression, followUpBefore, followUpBeforeExpression, followUpBeforeOrNotExistent, followUpBeforeOrNotExistentExpression, createdOn, createdOnExpression, createdAfter, createdAfterExpression, createdBefore, createdBeforeExpression, delegationState, candidateGroups, candidateGroupsExpression, withCandidateGroups, withoutCandidateGroups, withCandidateUsers, withoutCandidateUsers, active, suspended, taskVariables, processVariables, caseInstanceVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, parentTaskId, sortBy, sortOrder, firstResult, maxResults, options = {}) => {
            const localVarPath = `/task`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (processInstanceId !== undefined) {
                localVarQueryParameter['processInstanceId'] = processInstanceId;
            }
            if (processInstanceIdIn !== undefined) {
                localVarQueryParameter['processInstanceIdIn'] = processInstanceIdIn;
            }
            if (processInstanceBusinessKey !== undefined) {
                localVarQueryParameter['processInstanceBusinessKey'] = processInstanceBusinessKey;
            }
            if (processInstanceBusinessKeyExpression !== undefined) {
                localVarQueryParameter['processInstanceBusinessKeyExpression'] = processInstanceBusinessKeyExpression;
            }
            if (processInstanceBusinessKeyIn !== undefined) {
                localVarQueryParameter['processInstanceBusinessKeyIn'] = processInstanceBusinessKeyIn;
            }
            if (processInstanceBusinessKeyLike !== undefined) {
                localVarQueryParameter['processInstanceBusinessKeyLike'] = processInstanceBusinessKeyLike;
            }
            if (processInstanceBusinessKeyLikeExpression !== undefined) {
                localVarQueryParameter['processInstanceBusinessKeyLikeExpression'] = processInstanceBusinessKeyLikeExpression;
            }
            if (processDefinitionId !== undefined) {
                localVarQueryParameter['processDefinitionId'] = processDefinitionId;
            }
            if (processDefinitionKey !== undefined) {
                localVarQueryParameter['processDefinitionKey'] = processDefinitionKey;
            }
            if (processDefinitionKeyIn !== undefined) {
                localVarQueryParameter['processDefinitionKeyIn'] = processDefinitionKeyIn;
            }
            if (processDefinitionName !== undefined) {
                localVarQueryParameter['processDefinitionName'] = processDefinitionName;
            }
            if (processDefinitionNameLike !== undefined) {
                localVarQueryParameter['processDefinitionNameLike'] = processDefinitionNameLike;
            }
            if (executionId !== undefined) {
                localVarQueryParameter['executionId'] = executionId;
            }
            if (caseInstanceId !== undefined) {
                localVarQueryParameter['caseInstanceId'] = caseInstanceId;
            }
            if (caseInstanceBusinessKey !== undefined) {
                localVarQueryParameter['caseInstanceBusinessKey'] = caseInstanceBusinessKey;
            }
            if (caseInstanceBusinessKeyLike !== undefined) {
                localVarQueryParameter['caseInstanceBusinessKeyLike'] = caseInstanceBusinessKeyLike;
            }
            if (caseDefinitionId !== undefined) {
                localVarQueryParameter['caseDefinitionId'] = caseDefinitionId;
            }
            if (caseDefinitionKey !== undefined) {
                localVarQueryParameter['caseDefinitionKey'] = caseDefinitionKey;
            }
            if (caseDefinitionName !== undefined) {
                localVarQueryParameter['caseDefinitionName'] = caseDefinitionName;
            }
            if (caseDefinitionNameLike !== undefined) {
                localVarQueryParameter['caseDefinitionNameLike'] = caseDefinitionNameLike;
            }
            if (caseExecutionId !== undefined) {
                localVarQueryParameter['caseExecutionId'] = caseExecutionId;
            }
            if (activityInstanceIdIn !== undefined) {
                localVarQueryParameter['activityInstanceIdIn'] = activityInstanceIdIn;
            }
            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }
            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }
            if (assignee !== undefined) {
                localVarQueryParameter['assignee'] = assignee;
            }
            if (assigneeExpression !== undefined) {
                localVarQueryParameter['assigneeExpression'] = assigneeExpression;
            }
            if (assigneeLike !== undefined) {
                localVarQueryParameter['assigneeLike'] = assigneeLike;
            }
            if (assigneeLikeExpression !== undefined) {
                localVarQueryParameter['assigneeLikeExpression'] = assigneeLikeExpression;
            }
            if (assigneeIn !== undefined) {
                localVarQueryParameter['assigneeIn'] = assigneeIn;
            }
            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }
            if (ownerExpression !== undefined) {
                localVarQueryParameter['ownerExpression'] = ownerExpression;
            }
            if (candidateGroup !== undefined) {
                localVarQueryParameter['candidateGroup'] = candidateGroup;
            }
            if (candidateGroupExpression !== undefined) {
                localVarQueryParameter['candidateGroupExpression'] = candidateGroupExpression;
            }
            if (candidateUser !== undefined) {
                localVarQueryParameter['candidateUser'] = candidateUser;
            }
            if (candidateUserExpression !== undefined) {
                localVarQueryParameter['candidateUserExpression'] = candidateUserExpression;
            }
            if (includeAssignedTasks !== undefined) {
                localVarQueryParameter['includeAssignedTasks'] = includeAssignedTasks;
            }
            if (involvedUser !== undefined) {
                localVarQueryParameter['involvedUser'] = involvedUser;
            }
            if (involvedUserExpression !== undefined) {
                localVarQueryParameter['involvedUserExpression'] = involvedUserExpression;
            }
            if (assigned !== undefined) {
                localVarQueryParameter['assigned'] = assigned;
            }
            if (unassigned !== undefined) {
                localVarQueryParameter['unassigned'] = unassigned;
            }
            if (taskDefinitionKey !== undefined) {
                localVarQueryParameter['taskDefinitionKey'] = taskDefinitionKey;
            }
            if (taskDefinitionKeyIn !== undefined) {
                localVarQueryParameter['taskDefinitionKeyIn'] = taskDefinitionKeyIn;
            }
            if (taskDefinitionKeyLike !== undefined) {
                localVarQueryParameter['taskDefinitionKeyLike'] = taskDefinitionKeyLike;
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (nameNotEqual !== undefined) {
                localVarQueryParameter['nameNotEqual'] = nameNotEqual;
            }
            if (nameLike !== undefined) {
                localVarQueryParameter['nameLike'] = nameLike;
            }
            if (nameNotLike !== undefined) {
                localVarQueryParameter['nameNotLike'] = nameNotLike;
            }
            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }
            if (descriptionLike !== undefined) {
                localVarQueryParameter['descriptionLike'] = descriptionLike;
            }
            if (priority !== undefined) {
                localVarQueryParameter['priority'] = priority;
            }
            if (maxPriority !== undefined) {
                localVarQueryParameter['maxPriority'] = maxPriority;
            }
            if (minPriority !== undefined) {
                localVarQueryParameter['minPriority'] = minPriority;
            }
            if (dueDate !== undefined) {
                localVarQueryParameter['dueDate'] = dueDate;
            }
            if (dueDateExpression !== undefined) {
                localVarQueryParameter['dueDateExpression'] = dueDateExpression;
            }
            if (dueAfter !== undefined) {
                localVarQueryParameter['dueAfter'] = dueAfter;
            }
            if (dueAfterExpression !== undefined) {
                localVarQueryParameter['dueAfterExpression'] = dueAfterExpression;
            }
            if (dueBefore !== undefined) {
                localVarQueryParameter['dueBefore'] = dueBefore;
            }
            if (dueBeforeExpression !== undefined) {
                localVarQueryParameter['dueBeforeExpression'] = dueBeforeExpression;
            }
            if (followUpDate !== undefined) {
                localVarQueryParameter['followUpDate'] = followUpDate;
            }
            if (followUpDateExpression !== undefined) {
                localVarQueryParameter['followUpDateExpression'] = followUpDateExpression;
            }
            if (followUpAfter !== undefined) {
                localVarQueryParameter['followUpAfter'] = followUpAfter;
            }
            if (followUpAfterExpression !== undefined) {
                localVarQueryParameter['followUpAfterExpression'] = followUpAfterExpression;
            }
            if (followUpBefore !== undefined) {
                localVarQueryParameter['followUpBefore'] = followUpBefore;
            }
            if (followUpBeforeExpression !== undefined) {
                localVarQueryParameter['followUpBeforeExpression'] = followUpBeforeExpression;
            }
            if (followUpBeforeOrNotExistent !== undefined) {
                localVarQueryParameter['followUpBeforeOrNotExistent'] = followUpBeforeOrNotExistent;
            }
            if (followUpBeforeOrNotExistentExpression !== undefined) {
                localVarQueryParameter['followUpBeforeOrNotExistentExpression'] = followUpBeforeOrNotExistentExpression;
            }
            if (createdOn !== undefined) {
                localVarQueryParameter['createdOn'] = createdOn;
            }
            if (createdOnExpression !== undefined) {
                localVarQueryParameter['createdOnExpression'] = createdOnExpression;
            }
            if (createdAfter !== undefined) {
                localVarQueryParameter['createdAfter'] = createdAfter;
            }
            if (createdAfterExpression !== undefined) {
                localVarQueryParameter['createdAfterExpression'] = createdAfterExpression;
            }
            if (createdBefore !== undefined) {
                localVarQueryParameter['createdBefore'] = createdBefore;
            }
            if (createdBeforeExpression !== undefined) {
                localVarQueryParameter['createdBeforeExpression'] = createdBeforeExpression;
            }
            if (delegationState !== undefined) {
                localVarQueryParameter['delegationState'] = delegationState;
            }
            if (candidateGroups !== undefined) {
                localVarQueryParameter['candidateGroups'] = candidateGroups;
            }
            if (candidateGroupsExpression !== undefined) {
                localVarQueryParameter['candidateGroupsExpression'] = candidateGroupsExpression;
            }
            if (withCandidateGroups !== undefined) {
                localVarQueryParameter['withCandidateGroups'] = withCandidateGroups;
            }
            if (withoutCandidateGroups !== undefined) {
                localVarQueryParameter['withoutCandidateGroups'] = withoutCandidateGroups;
            }
            if (withCandidateUsers !== undefined) {
                localVarQueryParameter['withCandidateUsers'] = withCandidateUsers;
            }
            if (withoutCandidateUsers !== undefined) {
                localVarQueryParameter['withoutCandidateUsers'] = withoutCandidateUsers;
            }
            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }
            if (suspended !== undefined) {
                localVarQueryParameter['suspended'] = suspended;
            }
            if (taskVariables !== undefined) {
                localVarQueryParameter['taskVariables'] = taskVariables;
            }
            if (processVariables !== undefined) {
                localVarQueryParameter['processVariables'] = processVariables;
            }
            if (caseInstanceVariables !== undefined) {
                localVarQueryParameter['caseInstanceVariables'] = caseInstanceVariables;
            }
            if (variableNamesIgnoreCase !== undefined) {
                localVarQueryParameter['variableNamesIgnoreCase'] = variableNamesIgnoreCase;
            }
            if (variableValuesIgnoreCase !== undefined) {
                localVarQueryParameter['variableValuesIgnoreCase'] = variableValuesIgnoreCase;
            }
            if (parentTaskId !== undefined) {
                localVarQueryParameter['parentTaskId'] = parentTaskId;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }
            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }
            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the number of tasks that fulfill a provided filter. Corresponds to the size of the result set when using the [Get Tasks](https://docs.camunda.org/manual/7.13/reference/rest/task/) method.  **Security Consideration:** There are several query parameters (such as assigneeExpression) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) for custom code in the user guide for details.
         * @param {string} [processInstanceId] Restrict to tasks that belong to process instances with the given id.
         * @param {string} [processInstanceIdIn] Restrict to tasks that belong to process instances with the given ids.
         * @param {string} [processInstanceBusinessKey] Restrict to tasks that belong to process instances with the given business key.
         * @param {string} [processInstanceBusinessKeyExpression] Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {string} [processInstanceBusinessKeyIn] Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
         * @param {string} [processInstanceBusinessKeyLike] Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
         * @param {string} [processInstanceBusinessKeyLikeExpression] Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [processDefinitionId] Restrict to tasks that belong to a process definition with the given id.
         * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
         * @param {string} [processDefinitionKeyIn] Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
         * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
         * @param {string} [processDefinitionNameLike] Restrict to tasks that have a process definition name that has the parameter value as  a substring.
         * @param {string} [executionId] Restrict to tasks that belong to an execution with the given id.
         * @param {string} [caseInstanceId] Restrict to tasks that belong to case instances with the given id.
         * @param {string} [caseInstanceBusinessKey] Restrict to tasks that belong to case instances with the given business key.
         * @param {string} [caseInstanceBusinessKeyLike] Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
         * @param {string} [caseDefinitionId] Restrict to tasks that belong to a case definition with the given id.
         * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
         * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
         * @param {string} [caseDefinitionNameLike] Restrict to tasks that have a case definition name that has the parameter value as a  substring.
         * @param {string} [caseExecutionId] Restrict to tasks that belong to a case execution with the given id.
         * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
         * @param {string} [tenantIdIn] Only include tasks which belong to one of the passed and comma-separated  tenant ids.
         * @param {boolean} [withoutTenantId] Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
         * @param {string} [assignee] Restrict to tasks that the given user is assigned to.
         * @param {string} [assigneeExpression] Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeLike] Restrict to tasks that have an assignee that has the parameter  value as a substring.
         * @param {string} [assigneeLikeExpression] Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeIn] Only include tasks which are assigned to one of the passed and  comma-separated user ids.
         * @param {string} [owner] Restrict to tasks that the given user owns.
         * @param {string} [ownerExpression] Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateGroup] Only include tasks that are offered to the given group.
         * @param {string} [candidateGroupExpression] Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateUser] Only include tasks that are offered to the given user or to one of his groups.
         * @param {string} [candidateUserExpression] Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {boolean} [includeAssignedTasks] Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
         * @param {string} [involvedUser] Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
         * @param {string} [involvedUserExpression] Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
         * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
         * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
         * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
         * @param {string} [taskDefinitionKeyLike] Restrict to tasks that have a key that has the parameter value as a substring.
         * @param {string} [name] Restrict to tasks that have the given name.
         * @param {string} [nameNotEqual] Restrict to tasks that do not have the given name.
         * @param {string} [nameLike] Restrict to tasks that have a name with the given parameter value as substring.
         * @param {string} [nameNotLike] Restrict to tasks that do not have a name with the given parameter value as substring.
         * @param {string} [description] Restrict to tasks that have the given description.
         * @param {string} [descriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
         * @param {number} [priority] Restrict to tasks that have the given priority.
         * @param {number} [maxPriority] Restrict to tasks that have a lower or equal priority.
         * @param {number} [minPriority] Restrict to tasks that have a higher or equal priority.
         * @param {string} [dueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [dueDateExpression] Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
         * @param {string} [dueAfterExpression] Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
         * @param {string} [dueBeforeExpression] Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [followUpDateExpression] Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
         * @param {string} [followUpAfterExpression] Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
         * @param {string} [followUpBeforeExpression] Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBeforeOrNotExistent] Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
         * @param {string} [followUpBeforeOrNotExistentExpression] Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdOn] Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
         * @param {string} [createdOnExpression] Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdAfter] Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [createdAfterExpression] Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdBefore] Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
         * @param {string} [createdBeforeExpression] Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {'PENDING' | 'RESOLVED'} [delegationState] Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
         * @param {string} [candidateGroups] Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
         * @param {string} [candidateGroupsExpression] Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
         * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withCandidateUsers] Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateUsers] Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [caseInstanceVariables] Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
         * @param {string} [parentTaskId] Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksCount: async (processInstanceId, processInstanceIdIn, processInstanceBusinessKey, processInstanceBusinessKeyExpression, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, processInstanceBusinessKeyLikeExpression, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionName, processDefinitionNameLike, executionId, caseInstanceId, caseInstanceBusinessKey, caseInstanceBusinessKeyLike, caseDefinitionId, caseDefinitionKey, caseDefinitionName, caseDefinitionNameLike, caseExecutionId, activityInstanceIdIn, tenantIdIn, withoutTenantId, assignee, assigneeExpression, assigneeLike, assigneeLikeExpression, assigneeIn, owner, ownerExpression, candidateGroup, candidateGroupExpression, candidateUser, candidateUserExpression, includeAssignedTasks, involvedUser, involvedUserExpression, assigned, unassigned, taskDefinitionKey, taskDefinitionKeyIn, taskDefinitionKeyLike, name, nameNotEqual, nameLike, nameNotLike, description, descriptionLike, priority, maxPriority, minPriority, dueDate, dueDateExpression, dueAfter, dueAfterExpression, dueBefore, dueBeforeExpression, followUpDate, followUpDateExpression, followUpAfter, followUpAfterExpression, followUpBefore, followUpBeforeExpression, followUpBeforeOrNotExistent, followUpBeforeOrNotExistentExpression, createdOn, createdOnExpression, createdAfter, createdAfterExpression, createdBefore, createdBeforeExpression, delegationState, candidateGroups, candidateGroupsExpression, withCandidateGroups, withoutCandidateGroups, withCandidateUsers, withoutCandidateUsers, active, suspended, taskVariables, processVariables, caseInstanceVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, parentTaskId, options = {}) => {
            const localVarPath = `/task/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (processInstanceId !== undefined) {
                localVarQueryParameter['processInstanceId'] = processInstanceId;
            }
            if (processInstanceIdIn !== undefined) {
                localVarQueryParameter['processInstanceIdIn'] = processInstanceIdIn;
            }
            if (processInstanceBusinessKey !== undefined) {
                localVarQueryParameter['processInstanceBusinessKey'] = processInstanceBusinessKey;
            }
            if (processInstanceBusinessKeyExpression !== undefined) {
                localVarQueryParameter['processInstanceBusinessKeyExpression'] = processInstanceBusinessKeyExpression;
            }
            if (processInstanceBusinessKeyIn !== undefined) {
                localVarQueryParameter['processInstanceBusinessKeyIn'] = processInstanceBusinessKeyIn;
            }
            if (processInstanceBusinessKeyLike !== undefined) {
                localVarQueryParameter['processInstanceBusinessKeyLike'] = processInstanceBusinessKeyLike;
            }
            if (processInstanceBusinessKeyLikeExpression !== undefined) {
                localVarQueryParameter['processInstanceBusinessKeyLikeExpression'] = processInstanceBusinessKeyLikeExpression;
            }
            if (processDefinitionId !== undefined) {
                localVarQueryParameter['processDefinitionId'] = processDefinitionId;
            }
            if (processDefinitionKey !== undefined) {
                localVarQueryParameter['processDefinitionKey'] = processDefinitionKey;
            }
            if (processDefinitionKeyIn !== undefined) {
                localVarQueryParameter['processDefinitionKeyIn'] = processDefinitionKeyIn;
            }
            if (processDefinitionName !== undefined) {
                localVarQueryParameter['processDefinitionName'] = processDefinitionName;
            }
            if (processDefinitionNameLike !== undefined) {
                localVarQueryParameter['processDefinitionNameLike'] = processDefinitionNameLike;
            }
            if (executionId !== undefined) {
                localVarQueryParameter['executionId'] = executionId;
            }
            if (caseInstanceId !== undefined) {
                localVarQueryParameter['caseInstanceId'] = caseInstanceId;
            }
            if (caseInstanceBusinessKey !== undefined) {
                localVarQueryParameter['caseInstanceBusinessKey'] = caseInstanceBusinessKey;
            }
            if (caseInstanceBusinessKeyLike !== undefined) {
                localVarQueryParameter['caseInstanceBusinessKeyLike'] = caseInstanceBusinessKeyLike;
            }
            if (caseDefinitionId !== undefined) {
                localVarQueryParameter['caseDefinitionId'] = caseDefinitionId;
            }
            if (caseDefinitionKey !== undefined) {
                localVarQueryParameter['caseDefinitionKey'] = caseDefinitionKey;
            }
            if (caseDefinitionName !== undefined) {
                localVarQueryParameter['caseDefinitionName'] = caseDefinitionName;
            }
            if (caseDefinitionNameLike !== undefined) {
                localVarQueryParameter['caseDefinitionNameLike'] = caseDefinitionNameLike;
            }
            if (caseExecutionId !== undefined) {
                localVarQueryParameter['caseExecutionId'] = caseExecutionId;
            }
            if (activityInstanceIdIn !== undefined) {
                localVarQueryParameter['activityInstanceIdIn'] = activityInstanceIdIn;
            }
            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }
            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }
            if (assignee !== undefined) {
                localVarQueryParameter['assignee'] = assignee;
            }
            if (assigneeExpression !== undefined) {
                localVarQueryParameter['assigneeExpression'] = assigneeExpression;
            }
            if (assigneeLike !== undefined) {
                localVarQueryParameter['assigneeLike'] = assigneeLike;
            }
            if (assigneeLikeExpression !== undefined) {
                localVarQueryParameter['assigneeLikeExpression'] = assigneeLikeExpression;
            }
            if (assigneeIn !== undefined) {
                localVarQueryParameter['assigneeIn'] = assigneeIn;
            }
            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }
            if (ownerExpression !== undefined) {
                localVarQueryParameter['ownerExpression'] = ownerExpression;
            }
            if (candidateGroup !== undefined) {
                localVarQueryParameter['candidateGroup'] = candidateGroup;
            }
            if (candidateGroupExpression !== undefined) {
                localVarQueryParameter['candidateGroupExpression'] = candidateGroupExpression;
            }
            if (candidateUser !== undefined) {
                localVarQueryParameter['candidateUser'] = candidateUser;
            }
            if (candidateUserExpression !== undefined) {
                localVarQueryParameter['candidateUserExpression'] = candidateUserExpression;
            }
            if (includeAssignedTasks !== undefined) {
                localVarQueryParameter['includeAssignedTasks'] = includeAssignedTasks;
            }
            if (involvedUser !== undefined) {
                localVarQueryParameter['involvedUser'] = involvedUser;
            }
            if (involvedUserExpression !== undefined) {
                localVarQueryParameter['involvedUserExpression'] = involvedUserExpression;
            }
            if (assigned !== undefined) {
                localVarQueryParameter['assigned'] = assigned;
            }
            if (unassigned !== undefined) {
                localVarQueryParameter['unassigned'] = unassigned;
            }
            if (taskDefinitionKey !== undefined) {
                localVarQueryParameter['taskDefinitionKey'] = taskDefinitionKey;
            }
            if (taskDefinitionKeyIn !== undefined) {
                localVarQueryParameter['taskDefinitionKeyIn'] = taskDefinitionKeyIn;
            }
            if (taskDefinitionKeyLike !== undefined) {
                localVarQueryParameter['taskDefinitionKeyLike'] = taskDefinitionKeyLike;
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (nameNotEqual !== undefined) {
                localVarQueryParameter['nameNotEqual'] = nameNotEqual;
            }
            if (nameLike !== undefined) {
                localVarQueryParameter['nameLike'] = nameLike;
            }
            if (nameNotLike !== undefined) {
                localVarQueryParameter['nameNotLike'] = nameNotLike;
            }
            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }
            if (descriptionLike !== undefined) {
                localVarQueryParameter['descriptionLike'] = descriptionLike;
            }
            if (priority !== undefined) {
                localVarQueryParameter['priority'] = priority;
            }
            if (maxPriority !== undefined) {
                localVarQueryParameter['maxPriority'] = maxPriority;
            }
            if (minPriority !== undefined) {
                localVarQueryParameter['minPriority'] = minPriority;
            }
            if (dueDate !== undefined) {
                localVarQueryParameter['dueDate'] = dueDate;
            }
            if (dueDateExpression !== undefined) {
                localVarQueryParameter['dueDateExpression'] = dueDateExpression;
            }
            if (dueAfter !== undefined) {
                localVarQueryParameter['dueAfter'] = dueAfter;
            }
            if (dueAfterExpression !== undefined) {
                localVarQueryParameter['dueAfterExpression'] = dueAfterExpression;
            }
            if (dueBefore !== undefined) {
                localVarQueryParameter['dueBefore'] = dueBefore;
            }
            if (dueBeforeExpression !== undefined) {
                localVarQueryParameter['dueBeforeExpression'] = dueBeforeExpression;
            }
            if (followUpDate !== undefined) {
                localVarQueryParameter['followUpDate'] = followUpDate;
            }
            if (followUpDateExpression !== undefined) {
                localVarQueryParameter['followUpDateExpression'] = followUpDateExpression;
            }
            if (followUpAfter !== undefined) {
                localVarQueryParameter['followUpAfter'] = followUpAfter;
            }
            if (followUpAfterExpression !== undefined) {
                localVarQueryParameter['followUpAfterExpression'] = followUpAfterExpression;
            }
            if (followUpBefore !== undefined) {
                localVarQueryParameter['followUpBefore'] = followUpBefore;
            }
            if (followUpBeforeExpression !== undefined) {
                localVarQueryParameter['followUpBeforeExpression'] = followUpBeforeExpression;
            }
            if (followUpBeforeOrNotExistent !== undefined) {
                localVarQueryParameter['followUpBeforeOrNotExistent'] = followUpBeforeOrNotExistent;
            }
            if (followUpBeforeOrNotExistentExpression !== undefined) {
                localVarQueryParameter['followUpBeforeOrNotExistentExpression'] = followUpBeforeOrNotExistentExpression;
            }
            if (createdOn !== undefined) {
                localVarQueryParameter['createdOn'] = createdOn;
            }
            if (createdOnExpression !== undefined) {
                localVarQueryParameter['createdOnExpression'] = createdOnExpression;
            }
            if (createdAfter !== undefined) {
                localVarQueryParameter['createdAfter'] = createdAfter;
            }
            if (createdAfterExpression !== undefined) {
                localVarQueryParameter['createdAfterExpression'] = createdAfterExpression;
            }
            if (createdBefore !== undefined) {
                localVarQueryParameter['createdBefore'] = createdBefore;
            }
            if (createdBeforeExpression !== undefined) {
                localVarQueryParameter['createdBeforeExpression'] = createdBeforeExpression;
            }
            if (delegationState !== undefined) {
                localVarQueryParameter['delegationState'] = delegationState;
            }
            if (candidateGroups !== undefined) {
                localVarQueryParameter['candidateGroups'] = candidateGroups;
            }
            if (candidateGroupsExpression !== undefined) {
                localVarQueryParameter['candidateGroupsExpression'] = candidateGroupsExpression;
            }
            if (withCandidateGroups !== undefined) {
                localVarQueryParameter['withCandidateGroups'] = withCandidateGroups;
            }
            if (withoutCandidateGroups !== undefined) {
                localVarQueryParameter['withoutCandidateGroups'] = withoutCandidateGroups;
            }
            if (withCandidateUsers !== undefined) {
                localVarQueryParameter['withCandidateUsers'] = withCandidateUsers;
            }
            if (withoutCandidateUsers !== undefined) {
                localVarQueryParameter['withoutCandidateUsers'] = withoutCandidateUsers;
            }
            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }
            if (suspended !== undefined) {
                localVarQueryParameter['suspended'] = suspended;
            }
            if (taskVariables !== undefined) {
                localVarQueryParameter['taskVariables'] = taskVariables;
            }
            if (processVariables !== undefined) {
                localVarQueryParameter['processVariables'] = processVariables;
            }
            if (caseInstanceVariables !== undefined) {
                localVarQueryParameter['caseInstanceVariables'] = caseInstanceVariables;
            }
            if (variableNamesIgnoreCase !== undefined) {
                localVarQueryParameter['variableNamesIgnoreCase'] = variableNamesIgnoreCase;
            }
            if (variableValuesIgnoreCase !== undefined) {
                localVarQueryParameter['variableValuesIgnoreCase'] = variableValuesIgnoreCase;
            }
            if (parentTaskId !== undefined) {
                localVarQueryParameter['parentTaskId'] = parentTaskId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reports a business error in the context of a running task by id. The error code must be specified to identify the BPMN error handler. See the documentation for [Reporting Bpmn Error](https://docs.camunda.org/manual/7.13/reference/bpmn20/tasks/user-task/#reporting-bpmn-error) in User Tasks.
         * @param {string} id The id of the task a BPMN error is reported for.
         * @param {TaskBpmnErrorDto} [taskBpmnErrorDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleBpmnError: async (id, taskBpmnErrorDto, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('handleBpmnError', 'id', id);
            const localVarPath = `/task/{id}/bpmnError`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(taskBpmnErrorDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reports an escalation in the context of a running task by id. The escalation code must be specified to identify the escalation handler. See the documentation for [Reporting Bpmn Escalation](https://docs.camunda.org/manual/7.13/reference/bpmn20/tasks/user-task/#reporting-bpmn-escalation) in User Tasks.
         * @param {string} id The id of the task in which context a BPMN escalation is reported.
         * @param {TaskEscalationDto} [taskEscalationDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleEscalation: async (id, taskEscalationDto, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('handleEscalation', 'id', id);
            const localVarPath = `/task/{id}/bpmnEscalation`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(taskEscalationDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for tasks that fulfill a given filter. This method is slightly more powerful than the [Get Tasks](https://docs.camunda.org/manual/7.13/reference/rest/task/get-query/) method because it allows filtering by multiple process or task variables of types `String`, `Number` or `Boolean`. The size of the result set can be retrieved by using the [Get Task Count (POST)](https://docs.camunda.org/manual/7.13/reference/rest/task/post-query-count/) method.  **Security Consideration**: There are several parameters (such as `assigneeExpression`) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) in the user guide for details.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {TaskQueryDto} [taskQueryDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryTasks: async (firstResult, maxResults, taskQueryDto, options = {}) => {
            const localVarPath = `/task`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }
            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(taskQueryDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the number of tasks that fulfill the given filter. Corresponds to the size of the result set of the [Get Tasks (POST)](https://docs.camunda.org/manual/7.13/reference/rest/task/post-query/) method and takes the same parameters.  **Security Consideration**: There are several parameters (such as `assigneeExpression`) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) in the user guide for details.
         * @param {TaskQueryDto} [taskQueryDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryTasksCount: async (taskQueryDto, options = {}) => {
            const localVarPath = `/task/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(taskQueryDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resolves a task and updates execution variables.  Resolving a task marks that the assignee is done with the task delegated to them, and that it can be sent back to the owner. Can only be executed when the task has been delegated. The assignee will be set to the owner, who performed the delegation.
         * @param {string} id The id of the task to resolve.
         * @param {CompleteTaskDto} [completeTaskDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolve: async (id, completeTaskDto, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('resolve', 'id', id);
            const localVarPath = `/task/{id}/resolve`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(completeTaskDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes the assignee of a task to a specific user.  **Note:** The difference with the [Claim Task](https://docs.camunda.org/manual/7.13/reference/rest/task/post-claim/) method is that this method does not check if the task already has a user assigned to it.
         * @param {string} id The id of the task to set the assignee for.
         * @param {UserIdDto} [userIdDto] Provide the id of the user that will be the assignee of the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAssignee: async (id, userIdDto, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('setAssignee', 'id', id);
            const localVarPath = `/task/{id}/assignee`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(userIdDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Completes a task and updates process variables using a form submit. There are two difference between this method and the `complete` method:  * If the task is in state `PENDING` - i.e., has been delegated before, it is not completed but resolved. Otherwise it will be completed. * If the task has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See the [Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/_index/#generated-task-forms) section of the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/) for more information.
         * @param {string} id The id of the task to submit the form for.
         * @param {CompleteTaskDto} [completeTaskDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submit: async (id, completeTaskDto, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('submit', 'id', id);
            const localVarPath = `/task/{id}/submit-form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(completeTaskDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resets a task\'s assignee. If successful, the task is not assigned to a user.
         * @param {string} id The id of the task to unclaim.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unclaim: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('unclaim', 'id', id);
            const localVarPath = `/task/{id}/unclaim`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a task.
         * @param {string} id The id of the task to be updated.
         * @param {TaskDto} [taskDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask: async (id, taskDto, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateTask', 'id', id);
            const localVarPath = `/task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(taskDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.TaskApiAxiosParamCreator = TaskApiAxiosParamCreator;
/**
 * TaskApi - functional programming interface
 * @export
 */
const TaskApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TaskApiAxiosParamCreator)(configuration);
    return {
        /**
         * Claims a task for a specific user.  **Note:** The difference with the [Set Assignee](https://docs.camunda.org/manual/7.13/reference/rest/task/post-assignee/) method is that here a check is performed to see if the task already has a user assigned to it.
         * @param {string} id The id of the task to claim.
         * @param {UserIdDto} [userIdDto] Provide the id of the user that claims the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async claim(id, userIdDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.claim(id, userIdDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Completes a task and updates process variables.
         * @param {string} id The id of the task to complete.
         * @param {CompleteTaskDto} [completeTaskDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async complete(id, completeTaskDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.complete(id, completeTaskDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Creates a new task.
         * @param {TaskDto} [taskDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTask(taskDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTask(taskDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Delegates a task to another user.
         * @param {string} id The id of the task to delegate.
         * @param {UserIdDto} [userIdDto] Provide the id of the user that the task should be delegated to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delegateTask(id, userIdDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delegateTask(id, userIdDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Removes a task by id.
         * @param {string} id The id of the task to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTask(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTask(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves the deployed form that is referenced from a given task. For further information please refer to the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
         * @param {string} id The id of the task to get the deployed form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeployedForm(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeployedForm(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves the form key for a task. The form key corresponds to the `FormData#formKey` property in the engine. This key can be used to do task-specific form rendering in client applications. Additionally, the context path of the containing process application is returned.
         * @param {string} id The id of the task to retrieve the form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForm(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForm(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves the form variables for a task. The form variables take form data specified on the task into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @param {string} id The id of the task to retrieve the variables for.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFormVariables(id, variableNames, deserializeValues, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFormVariables(id, variableNames, deserializeValues, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves the rendered form for a task. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @param {string} id The id of the task to get the rendered form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRenderedForm(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRenderedForm(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves a task by id.
         * @param {string} id The id of the task to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTask(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTask(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Queries for tasks that fulfill a given filter. The size of the result set can be retrieved by using the Get Task Count method.  **Security Consideration:** There are several query parameters (such as assigneeExpression) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) for custom code in the user guide for details.
         * @param {string} [processInstanceId] Restrict to tasks that belong to process instances with the given id.
         * @param {string} [processInstanceIdIn] Restrict to tasks that belong to process instances with the given ids.
         * @param {string} [processInstanceBusinessKey] Restrict to tasks that belong to process instances with the given business key.
         * @param {string} [processInstanceBusinessKeyExpression] Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {string} [processInstanceBusinessKeyIn] Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
         * @param {string} [processInstanceBusinessKeyLike] Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
         * @param {string} [processInstanceBusinessKeyLikeExpression] Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [processDefinitionId] Restrict to tasks that belong to a process definition with the given id.
         * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
         * @param {string} [processDefinitionKeyIn] Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
         * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
         * @param {string} [processDefinitionNameLike] Restrict to tasks that have a process definition name that has the parameter value as  a substring.
         * @param {string} [executionId] Restrict to tasks that belong to an execution with the given id.
         * @param {string} [caseInstanceId] Restrict to tasks that belong to case instances with the given id.
         * @param {string} [caseInstanceBusinessKey] Restrict to tasks that belong to case instances with the given business key.
         * @param {string} [caseInstanceBusinessKeyLike] Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
         * @param {string} [caseDefinitionId] Restrict to tasks that belong to a case definition with the given id.
         * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
         * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
         * @param {string} [caseDefinitionNameLike] Restrict to tasks that have a case definition name that has the parameter value as a  substring.
         * @param {string} [caseExecutionId] Restrict to tasks that belong to a case execution with the given id.
         * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
         * @param {string} [tenantIdIn] Only include tasks which belong to one of the passed and comma-separated  tenant ids.
         * @param {boolean} [withoutTenantId] Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
         * @param {string} [assignee] Restrict to tasks that the given user is assigned to.
         * @param {string} [assigneeExpression] Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeLike] Restrict to tasks that have an assignee that has the parameter  value as a substring.
         * @param {string} [assigneeLikeExpression] Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeIn] Only include tasks which are assigned to one of the passed and  comma-separated user ids.
         * @param {string} [owner] Restrict to tasks that the given user owns.
         * @param {string} [ownerExpression] Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateGroup] Only include tasks that are offered to the given group.
         * @param {string} [candidateGroupExpression] Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateUser] Only include tasks that are offered to the given user or to one of his groups.
         * @param {string} [candidateUserExpression] Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {boolean} [includeAssignedTasks] Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
         * @param {string} [involvedUser] Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
         * @param {string} [involvedUserExpression] Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
         * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
         * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
         * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
         * @param {string} [taskDefinitionKeyLike] Restrict to tasks that have a key that has the parameter value as a substring.
         * @param {string} [name] Restrict to tasks that have the given name.
         * @param {string} [nameNotEqual] Restrict to tasks that do not have the given name.
         * @param {string} [nameLike] Restrict to tasks that have a name with the given parameter value as substring.
         * @param {string} [nameNotLike] Restrict to tasks that do not have a name with the given parameter value as substring.
         * @param {string} [description] Restrict to tasks that have the given description.
         * @param {string} [descriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
         * @param {number} [priority] Restrict to tasks that have the given priority.
         * @param {number} [maxPriority] Restrict to tasks that have a lower or equal priority.
         * @param {number} [minPriority] Restrict to tasks that have a higher or equal priority.
         * @param {string} [dueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [dueDateExpression] Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
         * @param {string} [dueAfterExpression] Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
         * @param {string} [dueBeforeExpression] Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [followUpDateExpression] Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
         * @param {string} [followUpAfterExpression] Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
         * @param {string} [followUpBeforeExpression] Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBeforeOrNotExistent] Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
         * @param {string} [followUpBeforeOrNotExistentExpression] Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdOn] Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
         * @param {string} [createdOnExpression] Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdAfter] Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [createdAfterExpression] Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdBefore] Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
         * @param {string} [createdBeforeExpression] Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {'PENDING' | 'RESOLVED'} [delegationState] Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
         * @param {string} [candidateGroups] Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
         * @param {string} [candidateGroupsExpression] Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
         * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withCandidateUsers] Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateUsers] Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [caseInstanceVariables] Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
         * @param {string} [parentTaskId] Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
         * @param {'instanceId' | 'caseInstanceId' | 'dueDate' | 'executionId' | 'caseExecutionId' | 'assignee' | 'created' | 'description' | 'id' | 'name' | 'nameCaseInsensitive' | 'priority' | 'processVariable' | 'executionVariable' | 'taskVariable' | 'caseExecutionVariable' | 'caseInstanceVariable'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTasks(processInstanceId, processInstanceIdIn, processInstanceBusinessKey, processInstanceBusinessKeyExpression, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, processInstanceBusinessKeyLikeExpression, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionName, processDefinitionNameLike, executionId, caseInstanceId, caseInstanceBusinessKey, caseInstanceBusinessKeyLike, caseDefinitionId, caseDefinitionKey, caseDefinitionName, caseDefinitionNameLike, caseExecutionId, activityInstanceIdIn, tenantIdIn, withoutTenantId, assignee, assigneeExpression, assigneeLike, assigneeLikeExpression, assigneeIn, owner, ownerExpression, candidateGroup, candidateGroupExpression, candidateUser, candidateUserExpression, includeAssignedTasks, involvedUser, involvedUserExpression, assigned, unassigned, taskDefinitionKey, taskDefinitionKeyIn, taskDefinitionKeyLike, name, nameNotEqual, nameLike, nameNotLike, description, descriptionLike, priority, maxPriority, minPriority, dueDate, dueDateExpression, dueAfter, dueAfterExpression, dueBefore, dueBeforeExpression, followUpDate, followUpDateExpression, followUpAfter, followUpAfterExpression, followUpBefore, followUpBeforeExpression, followUpBeforeOrNotExistent, followUpBeforeOrNotExistentExpression, createdOn, createdOnExpression, createdAfter, createdAfterExpression, createdBefore, createdBeforeExpression, delegationState, candidateGroups, candidateGroupsExpression, withCandidateGroups, withoutCandidateGroups, withCandidateUsers, withoutCandidateUsers, active, suspended, taskVariables, processVariables, caseInstanceVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, parentTaskId, sortBy, sortOrder, firstResult, maxResults, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTasks(processInstanceId, processInstanceIdIn, processInstanceBusinessKey, processInstanceBusinessKeyExpression, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, processInstanceBusinessKeyLikeExpression, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionName, processDefinitionNameLike, executionId, caseInstanceId, caseInstanceBusinessKey, caseInstanceBusinessKeyLike, caseDefinitionId, caseDefinitionKey, caseDefinitionName, caseDefinitionNameLike, caseExecutionId, activityInstanceIdIn, tenantIdIn, withoutTenantId, assignee, assigneeExpression, assigneeLike, assigneeLikeExpression, assigneeIn, owner, ownerExpression, candidateGroup, candidateGroupExpression, candidateUser, candidateUserExpression, includeAssignedTasks, involvedUser, involvedUserExpression, assigned, unassigned, taskDefinitionKey, taskDefinitionKeyIn, taskDefinitionKeyLike, name, nameNotEqual, nameLike, nameNotLike, description, descriptionLike, priority, maxPriority, minPriority, dueDate, dueDateExpression, dueAfter, dueAfterExpression, dueBefore, dueBeforeExpression, followUpDate, followUpDateExpression, followUpAfter, followUpAfterExpression, followUpBefore, followUpBeforeExpression, followUpBeforeOrNotExistent, followUpBeforeOrNotExistentExpression, createdOn, createdOnExpression, createdAfter, createdAfterExpression, createdBefore, createdBeforeExpression, delegationState, candidateGroups, candidateGroupsExpression, withCandidateGroups, withoutCandidateGroups, withCandidateUsers, withoutCandidateUsers, active, suspended, taskVariables, processVariables, caseInstanceVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, parentTaskId, sortBy, sortOrder, firstResult, maxResults, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves the number of tasks that fulfill a provided filter. Corresponds to the size of the result set when using the [Get Tasks](https://docs.camunda.org/manual/7.13/reference/rest/task/) method.  **Security Consideration:** There are several query parameters (such as assigneeExpression) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) for custom code in the user guide for details.
         * @param {string} [processInstanceId] Restrict to tasks that belong to process instances with the given id.
         * @param {string} [processInstanceIdIn] Restrict to tasks that belong to process instances with the given ids.
         * @param {string} [processInstanceBusinessKey] Restrict to tasks that belong to process instances with the given business key.
         * @param {string} [processInstanceBusinessKeyExpression] Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {string} [processInstanceBusinessKeyIn] Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
         * @param {string} [processInstanceBusinessKeyLike] Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
         * @param {string} [processInstanceBusinessKeyLikeExpression] Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [processDefinitionId] Restrict to tasks that belong to a process definition with the given id.
         * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
         * @param {string} [processDefinitionKeyIn] Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
         * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
         * @param {string} [processDefinitionNameLike] Restrict to tasks that have a process definition name that has the parameter value as  a substring.
         * @param {string} [executionId] Restrict to tasks that belong to an execution with the given id.
         * @param {string} [caseInstanceId] Restrict to tasks that belong to case instances with the given id.
         * @param {string} [caseInstanceBusinessKey] Restrict to tasks that belong to case instances with the given business key.
         * @param {string} [caseInstanceBusinessKeyLike] Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
         * @param {string} [caseDefinitionId] Restrict to tasks that belong to a case definition with the given id.
         * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
         * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
         * @param {string} [caseDefinitionNameLike] Restrict to tasks that have a case definition name that has the parameter value as a  substring.
         * @param {string} [caseExecutionId] Restrict to tasks that belong to a case execution with the given id.
         * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
         * @param {string} [tenantIdIn] Only include tasks which belong to one of the passed and comma-separated  tenant ids.
         * @param {boolean} [withoutTenantId] Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
         * @param {string} [assignee] Restrict to tasks that the given user is assigned to.
         * @param {string} [assigneeExpression] Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeLike] Restrict to tasks that have an assignee that has the parameter  value as a substring.
         * @param {string} [assigneeLikeExpression] Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeIn] Only include tasks which are assigned to one of the passed and  comma-separated user ids.
         * @param {string} [owner] Restrict to tasks that the given user owns.
         * @param {string} [ownerExpression] Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateGroup] Only include tasks that are offered to the given group.
         * @param {string} [candidateGroupExpression] Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateUser] Only include tasks that are offered to the given user or to one of his groups.
         * @param {string} [candidateUserExpression] Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {boolean} [includeAssignedTasks] Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
         * @param {string} [involvedUser] Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
         * @param {string} [involvedUserExpression] Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
         * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
         * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
         * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
         * @param {string} [taskDefinitionKeyLike] Restrict to tasks that have a key that has the parameter value as a substring.
         * @param {string} [name] Restrict to tasks that have the given name.
         * @param {string} [nameNotEqual] Restrict to tasks that do not have the given name.
         * @param {string} [nameLike] Restrict to tasks that have a name with the given parameter value as substring.
         * @param {string} [nameNotLike] Restrict to tasks that do not have a name with the given parameter value as substring.
         * @param {string} [description] Restrict to tasks that have the given description.
         * @param {string} [descriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
         * @param {number} [priority] Restrict to tasks that have the given priority.
         * @param {number} [maxPriority] Restrict to tasks that have a lower or equal priority.
         * @param {number} [minPriority] Restrict to tasks that have a higher or equal priority.
         * @param {string} [dueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [dueDateExpression] Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
         * @param {string} [dueAfterExpression] Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
         * @param {string} [dueBeforeExpression] Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [followUpDateExpression] Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
         * @param {string} [followUpAfterExpression] Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
         * @param {string} [followUpBeforeExpression] Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBeforeOrNotExistent] Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
         * @param {string} [followUpBeforeOrNotExistentExpression] Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdOn] Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
         * @param {string} [createdOnExpression] Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdAfter] Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [createdAfterExpression] Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdBefore] Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
         * @param {string} [createdBeforeExpression] Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {'PENDING' | 'RESOLVED'} [delegationState] Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
         * @param {string} [candidateGroups] Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
         * @param {string} [candidateGroupsExpression] Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
         * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withCandidateUsers] Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateUsers] Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [caseInstanceVariables] Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
         * @param {string} [parentTaskId] Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTasksCount(processInstanceId, processInstanceIdIn, processInstanceBusinessKey, processInstanceBusinessKeyExpression, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, processInstanceBusinessKeyLikeExpression, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionName, processDefinitionNameLike, executionId, caseInstanceId, caseInstanceBusinessKey, caseInstanceBusinessKeyLike, caseDefinitionId, caseDefinitionKey, caseDefinitionName, caseDefinitionNameLike, caseExecutionId, activityInstanceIdIn, tenantIdIn, withoutTenantId, assignee, assigneeExpression, assigneeLike, assigneeLikeExpression, assigneeIn, owner, ownerExpression, candidateGroup, candidateGroupExpression, candidateUser, candidateUserExpression, includeAssignedTasks, involvedUser, involvedUserExpression, assigned, unassigned, taskDefinitionKey, taskDefinitionKeyIn, taskDefinitionKeyLike, name, nameNotEqual, nameLike, nameNotLike, description, descriptionLike, priority, maxPriority, minPriority, dueDate, dueDateExpression, dueAfter, dueAfterExpression, dueBefore, dueBeforeExpression, followUpDate, followUpDateExpression, followUpAfter, followUpAfterExpression, followUpBefore, followUpBeforeExpression, followUpBeforeOrNotExistent, followUpBeforeOrNotExistentExpression, createdOn, createdOnExpression, createdAfter, createdAfterExpression, createdBefore, createdBeforeExpression, delegationState, candidateGroups, candidateGroupsExpression, withCandidateGroups, withoutCandidateGroups, withCandidateUsers, withoutCandidateUsers, active, suspended, taskVariables, processVariables, caseInstanceVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, parentTaskId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTasksCount(processInstanceId, processInstanceIdIn, processInstanceBusinessKey, processInstanceBusinessKeyExpression, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, processInstanceBusinessKeyLikeExpression, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionName, processDefinitionNameLike, executionId, caseInstanceId, caseInstanceBusinessKey, caseInstanceBusinessKeyLike, caseDefinitionId, caseDefinitionKey, caseDefinitionName, caseDefinitionNameLike, caseExecutionId, activityInstanceIdIn, tenantIdIn, withoutTenantId, assignee, assigneeExpression, assigneeLike, assigneeLikeExpression, assigneeIn, owner, ownerExpression, candidateGroup, candidateGroupExpression, candidateUser, candidateUserExpression, includeAssignedTasks, involvedUser, involvedUserExpression, assigned, unassigned, taskDefinitionKey, taskDefinitionKeyIn, taskDefinitionKeyLike, name, nameNotEqual, nameLike, nameNotLike, description, descriptionLike, priority, maxPriority, minPriority, dueDate, dueDateExpression, dueAfter, dueAfterExpression, dueBefore, dueBeforeExpression, followUpDate, followUpDateExpression, followUpAfter, followUpAfterExpression, followUpBefore, followUpBeforeExpression, followUpBeforeOrNotExistent, followUpBeforeOrNotExistentExpression, createdOn, createdOnExpression, createdAfter, createdAfterExpression, createdBefore, createdBeforeExpression, delegationState, candidateGroups, candidateGroupsExpression, withCandidateGroups, withoutCandidateGroups, withCandidateUsers, withoutCandidateUsers, active, suspended, taskVariables, processVariables, caseInstanceVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, parentTaskId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Reports a business error in the context of a running task by id. The error code must be specified to identify the BPMN error handler. See the documentation for [Reporting Bpmn Error](https://docs.camunda.org/manual/7.13/reference/bpmn20/tasks/user-task/#reporting-bpmn-error) in User Tasks.
         * @param {string} id The id of the task a BPMN error is reported for.
         * @param {TaskBpmnErrorDto} [taskBpmnErrorDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleBpmnError(id, taskBpmnErrorDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleBpmnError(id, taskBpmnErrorDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Reports an escalation in the context of a running task by id. The escalation code must be specified to identify the escalation handler. See the documentation for [Reporting Bpmn Escalation](https://docs.camunda.org/manual/7.13/reference/bpmn20/tasks/user-task/#reporting-bpmn-escalation) in User Tasks.
         * @param {string} id The id of the task in which context a BPMN escalation is reported.
         * @param {TaskEscalationDto} [taskEscalationDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleEscalation(id, taskEscalationDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleEscalation(id, taskEscalationDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Queries for tasks that fulfill a given filter. This method is slightly more powerful than the [Get Tasks](https://docs.camunda.org/manual/7.13/reference/rest/task/get-query/) method because it allows filtering by multiple process or task variables of types `String`, `Number` or `Boolean`. The size of the result set can be retrieved by using the [Get Task Count (POST)](https://docs.camunda.org/manual/7.13/reference/rest/task/post-query-count/) method.  **Security Consideration**: There are several parameters (such as `assigneeExpression`) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) in the user guide for details.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {TaskQueryDto} [taskQueryDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryTasks(firstResult, maxResults, taskQueryDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryTasks(firstResult, maxResults, taskQueryDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves the number of tasks that fulfill the given filter. Corresponds to the size of the result set of the [Get Tasks (POST)](https://docs.camunda.org/manual/7.13/reference/rest/task/post-query/) method and takes the same parameters.  **Security Consideration**: There are several parameters (such as `assigneeExpression`) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) in the user guide for details.
         * @param {TaskQueryDto} [taskQueryDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryTasksCount(taskQueryDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryTasksCount(taskQueryDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Resolves a task and updates execution variables.  Resolving a task marks that the assignee is done with the task delegated to them, and that it can be sent back to the owner. Can only be executed when the task has been delegated. The assignee will be set to the owner, who performed the delegation.
         * @param {string} id The id of the task to resolve.
         * @param {CompleteTaskDto} [completeTaskDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolve(id, completeTaskDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resolve(id, completeTaskDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Changes the assignee of a task to a specific user.  **Note:** The difference with the [Claim Task](https://docs.camunda.org/manual/7.13/reference/rest/task/post-claim/) method is that this method does not check if the task already has a user assigned to it.
         * @param {string} id The id of the task to set the assignee for.
         * @param {UserIdDto} [userIdDto] Provide the id of the user that will be the assignee of the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setAssignee(id, userIdDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setAssignee(id, userIdDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Completes a task and updates process variables using a form submit. There are two difference between this method and the `complete` method:  * If the task is in state `PENDING` - i.e., has been delegated before, it is not completed but resolved. Otherwise it will be completed. * If the task has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See the [Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/_index/#generated-task-forms) section of the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/) for more information.
         * @param {string} id The id of the task to submit the form for.
         * @param {CompleteTaskDto} [completeTaskDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submit(id, completeTaskDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submit(id, completeTaskDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Resets a task\'s assignee. If successful, the task is not assigned to a user.
         * @param {string} id The id of the task to unclaim.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unclaim(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unclaim(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Updates a task.
         * @param {string} id The id of the task to be updated.
         * @param {TaskDto} [taskDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTask(id, taskDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTask(id, taskDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.TaskApiFp = TaskApiFp;
/**
 * TaskApi - factory interface
 * @export
 */
const TaskApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TaskApiFp)(configuration);
    return {
        /**
         * Claims a task for a specific user.  **Note:** The difference with the [Set Assignee](https://docs.camunda.org/manual/7.13/reference/rest/task/post-assignee/) method is that here a check is performed to see if the task already has a user assigned to it.
         * @param {string} id The id of the task to claim.
         * @param {UserIdDto} [userIdDto] Provide the id of the user that claims the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claim(id, userIdDto, options) {
            return localVarFp.claim(id, userIdDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Completes a task and updates process variables.
         * @param {string} id The id of the task to complete.
         * @param {CompleteTaskDto} [completeTaskDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        complete(id, completeTaskDto, options) {
            return localVarFp.complete(id, completeTaskDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new task.
         * @param {TaskDto} [taskDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTask(taskDto, options) {
            return localVarFp.createTask(taskDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Delegates a task to another user.
         * @param {string} id The id of the task to delegate.
         * @param {UserIdDto} [userIdDto] Provide the id of the user that the task should be delegated to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegateTask(id, userIdDto, options) {
            return localVarFp.delegateTask(id, userIdDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a task by id.
         * @param {string} id The id of the task to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTask(id, options) {
            return localVarFp.deleteTask(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the deployed form that is referenced from a given task. For further information please refer to the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
         * @param {string} id The id of the task to get the deployed form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedForm(id, options) {
            return localVarFp.getDeployedForm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the form key for a task. The form key corresponds to the `FormData#formKey` property in the engine. This key can be used to do task-specific form rendering in client applications. Additionally, the context path of the containing process application is returned.
         * @param {string} id The id of the task to retrieve the form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForm(id, options) {
            return localVarFp.getForm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the form variables for a task. The form variables take form data specified on the task into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @param {string} id The id of the task to retrieve the variables for.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFormVariables(id, variableNames, deserializeValues, options) {
            return localVarFp.getFormVariables(id, variableNames, deserializeValues, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the rendered form for a task. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @param {string} id The id of the task to get the rendered form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRenderedForm(id, options) {
            return localVarFp.getRenderedForm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a task by id.
         * @param {string} id The id of the task to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask(id, options) {
            return localVarFp.getTask(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for tasks that fulfill a given filter. The size of the result set can be retrieved by using the Get Task Count method.  **Security Consideration:** There are several query parameters (such as assigneeExpression) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) for custom code in the user guide for details.
         * @param {string} [processInstanceId] Restrict to tasks that belong to process instances with the given id.
         * @param {string} [processInstanceIdIn] Restrict to tasks that belong to process instances with the given ids.
         * @param {string} [processInstanceBusinessKey] Restrict to tasks that belong to process instances with the given business key.
         * @param {string} [processInstanceBusinessKeyExpression] Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {string} [processInstanceBusinessKeyIn] Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
         * @param {string} [processInstanceBusinessKeyLike] Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
         * @param {string} [processInstanceBusinessKeyLikeExpression] Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [processDefinitionId] Restrict to tasks that belong to a process definition with the given id.
         * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
         * @param {string} [processDefinitionKeyIn] Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
         * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
         * @param {string} [processDefinitionNameLike] Restrict to tasks that have a process definition name that has the parameter value as  a substring.
         * @param {string} [executionId] Restrict to tasks that belong to an execution with the given id.
         * @param {string} [caseInstanceId] Restrict to tasks that belong to case instances with the given id.
         * @param {string} [caseInstanceBusinessKey] Restrict to tasks that belong to case instances with the given business key.
         * @param {string} [caseInstanceBusinessKeyLike] Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
         * @param {string} [caseDefinitionId] Restrict to tasks that belong to a case definition with the given id.
         * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
         * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
         * @param {string} [caseDefinitionNameLike] Restrict to tasks that have a case definition name that has the parameter value as a  substring.
         * @param {string} [caseExecutionId] Restrict to tasks that belong to a case execution with the given id.
         * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
         * @param {string} [tenantIdIn] Only include tasks which belong to one of the passed and comma-separated  tenant ids.
         * @param {boolean} [withoutTenantId] Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
         * @param {string} [assignee] Restrict to tasks that the given user is assigned to.
         * @param {string} [assigneeExpression] Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeLike] Restrict to tasks that have an assignee that has the parameter  value as a substring.
         * @param {string} [assigneeLikeExpression] Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeIn] Only include tasks which are assigned to one of the passed and  comma-separated user ids.
         * @param {string} [owner] Restrict to tasks that the given user owns.
         * @param {string} [ownerExpression] Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateGroup] Only include tasks that are offered to the given group.
         * @param {string} [candidateGroupExpression] Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateUser] Only include tasks that are offered to the given user or to one of his groups.
         * @param {string} [candidateUserExpression] Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {boolean} [includeAssignedTasks] Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
         * @param {string} [involvedUser] Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
         * @param {string} [involvedUserExpression] Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
         * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
         * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
         * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
         * @param {string} [taskDefinitionKeyLike] Restrict to tasks that have a key that has the parameter value as a substring.
         * @param {string} [name] Restrict to tasks that have the given name.
         * @param {string} [nameNotEqual] Restrict to tasks that do not have the given name.
         * @param {string} [nameLike] Restrict to tasks that have a name with the given parameter value as substring.
         * @param {string} [nameNotLike] Restrict to tasks that do not have a name with the given parameter value as substring.
         * @param {string} [description] Restrict to tasks that have the given description.
         * @param {string} [descriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
         * @param {number} [priority] Restrict to tasks that have the given priority.
         * @param {number} [maxPriority] Restrict to tasks that have a lower or equal priority.
         * @param {number} [minPriority] Restrict to tasks that have a higher or equal priority.
         * @param {string} [dueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [dueDateExpression] Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
         * @param {string} [dueAfterExpression] Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
         * @param {string} [dueBeforeExpression] Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [followUpDateExpression] Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
         * @param {string} [followUpAfterExpression] Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
         * @param {string} [followUpBeforeExpression] Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBeforeOrNotExistent] Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
         * @param {string} [followUpBeforeOrNotExistentExpression] Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdOn] Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
         * @param {string} [createdOnExpression] Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdAfter] Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [createdAfterExpression] Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdBefore] Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
         * @param {string} [createdBeforeExpression] Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {'PENDING' | 'RESOLVED'} [delegationState] Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
         * @param {string} [candidateGroups] Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
         * @param {string} [candidateGroupsExpression] Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
         * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withCandidateUsers] Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateUsers] Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [caseInstanceVariables] Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
         * @param {string} [parentTaskId] Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
         * @param {'instanceId' | 'caseInstanceId' | 'dueDate' | 'executionId' | 'caseExecutionId' | 'assignee' | 'created' | 'description' | 'id' | 'name' | 'nameCaseInsensitive' | 'priority' | 'processVariable' | 'executionVariable' | 'taskVariable' | 'caseExecutionVariable' | 'caseInstanceVariable'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks(processInstanceId, processInstanceIdIn, processInstanceBusinessKey, processInstanceBusinessKeyExpression, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, processInstanceBusinessKeyLikeExpression, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionName, processDefinitionNameLike, executionId, caseInstanceId, caseInstanceBusinessKey, caseInstanceBusinessKeyLike, caseDefinitionId, caseDefinitionKey, caseDefinitionName, caseDefinitionNameLike, caseExecutionId, activityInstanceIdIn, tenantIdIn, withoutTenantId, assignee, assigneeExpression, assigneeLike, assigneeLikeExpression, assigneeIn, owner, ownerExpression, candidateGroup, candidateGroupExpression, candidateUser, candidateUserExpression, includeAssignedTasks, involvedUser, involvedUserExpression, assigned, unassigned, taskDefinitionKey, taskDefinitionKeyIn, taskDefinitionKeyLike, name, nameNotEqual, nameLike, nameNotLike, description, descriptionLike, priority, maxPriority, minPriority, dueDate, dueDateExpression, dueAfter, dueAfterExpression, dueBefore, dueBeforeExpression, followUpDate, followUpDateExpression, followUpAfter, followUpAfterExpression, followUpBefore, followUpBeforeExpression, followUpBeforeOrNotExistent, followUpBeforeOrNotExistentExpression, createdOn, createdOnExpression, createdAfter, createdAfterExpression, createdBefore, createdBeforeExpression, delegationState, candidateGroups, candidateGroupsExpression, withCandidateGroups, withoutCandidateGroups, withCandidateUsers, withoutCandidateUsers, active, suspended, taskVariables, processVariables, caseInstanceVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, parentTaskId, sortBy, sortOrder, firstResult, maxResults, options) {
            return localVarFp.getTasks(processInstanceId, processInstanceIdIn, processInstanceBusinessKey, processInstanceBusinessKeyExpression, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, processInstanceBusinessKeyLikeExpression, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionName, processDefinitionNameLike, executionId, caseInstanceId, caseInstanceBusinessKey, caseInstanceBusinessKeyLike, caseDefinitionId, caseDefinitionKey, caseDefinitionName, caseDefinitionNameLike, caseExecutionId, activityInstanceIdIn, tenantIdIn, withoutTenantId, assignee, assigneeExpression, assigneeLike, assigneeLikeExpression, assigneeIn, owner, ownerExpression, candidateGroup, candidateGroupExpression, candidateUser, candidateUserExpression, includeAssignedTasks, involvedUser, involvedUserExpression, assigned, unassigned, taskDefinitionKey, taskDefinitionKeyIn, taskDefinitionKeyLike, name, nameNotEqual, nameLike, nameNotLike, description, descriptionLike, priority, maxPriority, minPriority, dueDate, dueDateExpression, dueAfter, dueAfterExpression, dueBefore, dueBeforeExpression, followUpDate, followUpDateExpression, followUpAfter, followUpAfterExpression, followUpBefore, followUpBeforeExpression, followUpBeforeOrNotExistent, followUpBeforeOrNotExistentExpression, createdOn, createdOnExpression, createdAfter, createdAfterExpression, createdBefore, createdBeforeExpression, delegationState, candidateGroups, candidateGroupsExpression, withCandidateGroups, withoutCandidateGroups, withCandidateUsers, withoutCandidateUsers, active, suspended, taskVariables, processVariables, caseInstanceVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, parentTaskId, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the number of tasks that fulfill a provided filter. Corresponds to the size of the result set when using the [Get Tasks](https://docs.camunda.org/manual/7.13/reference/rest/task/) method.  **Security Consideration:** There are several query parameters (such as assigneeExpression) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) for custom code in the user guide for details.
         * @param {string} [processInstanceId] Restrict to tasks that belong to process instances with the given id.
         * @param {string} [processInstanceIdIn] Restrict to tasks that belong to process instances with the given ids.
         * @param {string} [processInstanceBusinessKey] Restrict to tasks that belong to process instances with the given business key.
         * @param {string} [processInstanceBusinessKeyExpression] Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {string} [processInstanceBusinessKeyIn] Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
         * @param {string} [processInstanceBusinessKeyLike] Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
         * @param {string} [processInstanceBusinessKeyLikeExpression] Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [processDefinitionId] Restrict to tasks that belong to a process definition with the given id.
         * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
         * @param {string} [processDefinitionKeyIn] Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
         * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
         * @param {string} [processDefinitionNameLike] Restrict to tasks that have a process definition name that has the parameter value as  a substring.
         * @param {string} [executionId] Restrict to tasks that belong to an execution with the given id.
         * @param {string} [caseInstanceId] Restrict to tasks that belong to case instances with the given id.
         * @param {string} [caseInstanceBusinessKey] Restrict to tasks that belong to case instances with the given business key.
         * @param {string} [caseInstanceBusinessKeyLike] Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
         * @param {string} [caseDefinitionId] Restrict to tasks that belong to a case definition with the given id.
         * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
         * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
         * @param {string} [caseDefinitionNameLike] Restrict to tasks that have a case definition name that has the parameter value as a  substring.
         * @param {string} [caseExecutionId] Restrict to tasks that belong to a case execution with the given id.
         * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
         * @param {string} [tenantIdIn] Only include tasks which belong to one of the passed and comma-separated  tenant ids.
         * @param {boolean} [withoutTenantId] Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
         * @param {string} [assignee] Restrict to tasks that the given user is assigned to.
         * @param {string} [assigneeExpression] Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeLike] Restrict to tasks that have an assignee that has the parameter  value as a substring.
         * @param {string} [assigneeLikeExpression] Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeIn] Only include tasks which are assigned to one of the passed and  comma-separated user ids.
         * @param {string} [owner] Restrict to tasks that the given user owns.
         * @param {string} [ownerExpression] Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateGroup] Only include tasks that are offered to the given group.
         * @param {string} [candidateGroupExpression] Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateUser] Only include tasks that are offered to the given user or to one of his groups.
         * @param {string} [candidateUserExpression] Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {boolean} [includeAssignedTasks] Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
         * @param {string} [involvedUser] Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
         * @param {string} [involvedUserExpression] Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
         * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
         * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
         * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
         * @param {string} [taskDefinitionKeyLike] Restrict to tasks that have a key that has the parameter value as a substring.
         * @param {string} [name] Restrict to tasks that have the given name.
         * @param {string} [nameNotEqual] Restrict to tasks that do not have the given name.
         * @param {string} [nameLike] Restrict to tasks that have a name with the given parameter value as substring.
         * @param {string} [nameNotLike] Restrict to tasks that do not have a name with the given parameter value as substring.
         * @param {string} [description] Restrict to tasks that have the given description.
         * @param {string} [descriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
         * @param {number} [priority] Restrict to tasks that have the given priority.
         * @param {number} [maxPriority] Restrict to tasks that have a lower or equal priority.
         * @param {number} [minPriority] Restrict to tasks that have a higher or equal priority.
         * @param {string} [dueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [dueDateExpression] Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
         * @param {string} [dueAfterExpression] Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
         * @param {string} [dueBeforeExpression] Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [followUpDateExpression] Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
         * @param {string} [followUpAfterExpression] Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
         * @param {string} [followUpBeforeExpression] Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBeforeOrNotExistent] Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
         * @param {string} [followUpBeforeOrNotExistentExpression] Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdOn] Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
         * @param {string} [createdOnExpression] Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdAfter] Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [createdAfterExpression] Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdBefore] Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
         * @param {string} [createdBeforeExpression] Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {'PENDING' | 'RESOLVED'} [delegationState] Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
         * @param {string} [candidateGroups] Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
         * @param {string} [candidateGroupsExpression] Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
         * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withCandidateUsers] Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateUsers] Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [caseInstanceVariables] Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
         * @param {string} [parentTaskId] Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksCount(processInstanceId, processInstanceIdIn, processInstanceBusinessKey, processInstanceBusinessKeyExpression, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, processInstanceBusinessKeyLikeExpression, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionName, processDefinitionNameLike, executionId, caseInstanceId, caseInstanceBusinessKey, caseInstanceBusinessKeyLike, caseDefinitionId, caseDefinitionKey, caseDefinitionName, caseDefinitionNameLike, caseExecutionId, activityInstanceIdIn, tenantIdIn, withoutTenantId, assignee, assigneeExpression, assigneeLike, assigneeLikeExpression, assigneeIn, owner, ownerExpression, candidateGroup, candidateGroupExpression, candidateUser, candidateUserExpression, includeAssignedTasks, involvedUser, involvedUserExpression, assigned, unassigned, taskDefinitionKey, taskDefinitionKeyIn, taskDefinitionKeyLike, name, nameNotEqual, nameLike, nameNotLike, description, descriptionLike, priority, maxPriority, minPriority, dueDate, dueDateExpression, dueAfter, dueAfterExpression, dueBefore, dueBeforeExpression, followUpDate, followUpDateExpression, followUpAfter, followUpAfterExpression, followUpBefore, followUpBeforeExpression, followUpBeforeOrNotExistent, followUpBeforeOrNotExistentExpression, createdOn, createdOnExpression, createdAfter, createdAfterExpression, createdBefore, createdBeforeExpression, delegationState, candidateGroups, candidateGroupsExpression, withCandidateGroups, withoutCandidateGroups, withCandidateUsers, withoutCandidateUsers, active, suspended, taskVariables, processVariables, caseInstanceVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, parentTaskId, options) {
            return localVarFp.getTasksCount(processInstanceId, processInstanceIdIn, processInstanceBusinessKey, processInstanceBusinessKeyExpression, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, processInstanceBusinessKeyLikeExpression, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionName, processDefinitionNameLike, executionId, caseInstanceId, caseInstanceBusinessKey, caseInstanceBusinessKeyLike, caseDefinitionId, caseDefinitionKey, caseDefinitionName, caseDefinitionNameLike, caseExecutionId, activityInstanceIdIn, tenantIdIn, withoutTenantId, assignee, assigneeExpression, assigneeLike, assigneeLikeExpression, assigneeIn, owner, ownerExpression, candidateGroup, candidateGroupExpression, candidateUser, candidateUserExpression, includeAssignedTasks, involvedUser, involvedUserExpression, assigned, unassigned, taskDefinitionKey, taskDefinitionKeyIn, taskDefinitionKeyLike, name, nameNotEqual, nameLike, nameNotLike, description, descriptionLike, priority, maxPriority, minPriority, dueDate, dueDateExpression, dueAfter, dueAfterExpression, dueBefore, dueBeforeExpression, followUpDate, followUpDateExpression, followUpAfter, followUpAfterExpression, followUpBefore, followUpBeforeExpression, followUpBeforeOrNotExistent, followUpBeforeOrNotExistentExpression, createdOn, createdOnExpression, createdAfter, createdAfterExpression, createdBefore, createdBeforeExpression, delegationState, candidateGroups, candidateGroupsExpression, withCandidateGroups, withoutCandidateGroups, withCandidateUsers, withoutCandidateUsers, active, suspended, taskVariables, processVariables, caseInstanceVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, parentTaskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Reports a business error in the context of a running task by id. The error code must be specified to identify the BPMN error handler. See the documentation for [Reporting Bpmn Error](https://docs.camunda.org/manual/7.13/reference/bpmn20/tasks/user-task/#reporting-bpmn-error) in User Tasks.
         * @param {string} id The id of the task a BPMN error is reported for.
         * @param {TaskBpmnErrorDto} [taskBpmnErrorDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleBpmnError(id, taskBpmnErrorDto, options) {
            return localVarFp.handleBpmnError(id, taskBpmnErrorDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Reports an escalation in the context of a running task by id. The escalation code must be specified to identify the escalation handler. See the documentation for [Reporting Bpmn Escalation](https://docs.camunda.org/manual/7.13/reference/bpmn20/tasks/user-task/#reporting-bpmn-escalation) in User Tasks.
         * @param {string} id The id of the task in which context a BPMN escalation is reported.
         * @param {TaskEscalationDto} [taskEscalationDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleEscalation(id, taskEscalationDto, options) {
            return localVarFp.handleEscalation(id, taskEscalationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for tasks that fulfill a given filter. This method is slightly more powerful than the [Get Tasks](https://docs.camunda.org/manual/7.13/reference/rest/task/get-query/) method because it allows filtering by multiple process or task variables of types `String`, `Number` or `Boolean`. The size of the result set can be retrieved by using the [Get Task Count (POST)](https://docs.camunda.org/manual/7.13/reference/rest/task/post-query-count/) method.  **Security Consideration**: There are several parameters (such as `assigneeExpression`) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) in the user guide for details.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {TaskQueryDto} [taskQueryDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryTasks(firstResult, maxResults, taskQueryDto, options) {
            return localVarFp.queryTasks(firstResult, maxResults, taskQueryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the number of tasks that fulfill the given filter. Corresponds to the size of the result set of the [Get Tasks (POST)](https://docs.camunda.org/manual/7.13/reference/rest/task/post-query/) method and takes the same parameters.  **Security Consideration**: There are several parameters (such as `assigneeExpression`) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) in the user guide for details.
         * @param {TaskQueryDto} [taskQueryDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryTasksCount(taskQueryDto, options) {
            return localVarFp.queryTasksCount(taskQueryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Resolves a task and updates execution variables.  Resolving a task marks that the assignee is done with the task delegated to them, and that it can be sent back to the owner. Can only be executed when the task has been delegated. The assignee will be set to the owner, who performed the delegation.
         * @param {string} id The id of the task to resolve.
         * @param {CompleteTaskDto} [completeTaskDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolve(id, completeTaskDto, options) {
            return localVarFp.resolve(id, completeTaskDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes the assignee of a task to a specific user.  **Note:** The difference with the [Claim Task](https://docs.camunda.org/manual/7.13/reference/rest/task/post-claim/) method is that this method does not check if the task already has a user assigned to it.
         * @param {string} id The id of the task to set the assignee for.
         * @param {UserIdDto} [userIdDto] Provide the id of the user that will be the assignee of the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAssignee(id, userIdDto, options) {
            return localVarFp.setAssignee(id, userIdDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Completes a task and updates process variables using a form submit. There are two difference between this method and the `complete` method:  * If the task is in state `PENDING` - i.e., has been delegated before, it is not completed but resolved. Otherwise it will be completed. * If the task has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See the [Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/_index/#generated-task-forms) section of the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/) for more information.
         * @param {string} id The id of the task to submit the form for.
         * @param {CompleteTaskDto} [completeTaskDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submit(id, completeTaskDto, options) {
            return localVarFp.submit(id, completeTaskDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Resets a task\'s assignee. If successful, the task is not assigned to a user.
         * @param {string} id The id of the task to unclaim.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unclaim(id, options) {
            return localVarFp.unclaim(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a task.
         * @param {string} id The id of the task to be updated.
         * @param {TaskDto} [taskDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask(id, taskDto, options) {
            return localVarFp.updateTask(id, taskDto, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TaskApiFactory = TaskApiFactory;
/**
 * TaskApi - object-oriented interface
 * @export
 * @class TaskApi
 * @extends {BaseAPI}
 */
class TaskApi extends base_1.BaseAPI {
    /**
     * Claims a task for a specific user.  **Note:** The difference with the [Set Assignee](https://docs.camunda.org/manual/7.13/reference/rest/task/post-assignee/) method is that here a check is performed to see if the task already has a user assigned to it.
     * @param {string} id The id of the task to claim.
     * @param {UserIdDto} [userIdDto] Provide the id of the user that claims the task.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    claim(id, userIdDto, options) {
        return (0, exports.TaskApiFp)(this.configuration).claim(id, userIdDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Completes a task and updates process variables.
     * @param {string} id The id of the task to complete.
     * @param {CompleteTaskDto} [completeTaskDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    complete(id, completeTaskDto, options) {
        return (0, exports.TaskApiFp)(this.configuration).complete(id, completeTaskDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new task.
     * @param {TaskDto} [taskDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    createTask(taskDto, options) {
        return (0, exports.TaskApiFp)(this.configuration).createTask(taskDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delegates a task to another user.
     * @param {string} id The id of the task to delegate.
     * @param {UserIdDto} [userIdDto] Provide the id of the user that the task should be delegated to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    delegateTask(id, userIdDto, options) {
        return (0, exports.TaskApiFp)(this.configuration).delegateTask(id, userIdDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Removes a task by id.
     * @param {string} id The id of the task to be removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    deleteTask(id, options) {
        return (0, exports.TaskApiFp)(this.configuration).deleteTask(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the deployed form that is referenced from a given task. For further information please refer to the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
     * @param {string} id The id of the task to get the deployed form for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    getDeployedForm(id, options) {
        return (0, exports.TaskApiFp)(this.configuration).getDeployedForm(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the form key for a task. The form key corresponds to the `FormData#formKey` property in the engine. This key can be used to do task-specific form rendering in client applications. Additionally, the context path of the containing process application is returned.
     * @param {string} id The id of the task to retrieve the form for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    getForm(id, options) {
        return (0, exports.TaskApiFp)(this.configuration).getForm(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the form variables for a task. The form variables take form data specified on the task into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
     * @param {string} id The id of the task to retrieve the variables for.
     * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
     * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    getFormVariables(id, variableNames, deserializeValues, options) {
        return (0, exports.TaskApiFp)(this.configuration).getFormVariables(id, variableNames, deserializeValues, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the rendered form for a task. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
     * @param {string} id The id of the task to get the rendered form for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    getRenderedForm(id, options) {
        return (0, exports.TaskApiFp)(this.configuration).getRenderedForm(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a task by id.
     * @param {string} id The id of the task to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    getTask(id, options) {
        return (0, exports.TaskApiFp)(this.configuration).getTask(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for tasks that fulfill a given filter. The size of the result set can be retrieved by using the Get Task Count method.  **Security Consideration:** There are several query parameters (such as assigneeExpression) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) for custom code in the user guide for details.
     * @param {string} [processInstanceId] Restrict to tasks that belong to process instances with the given id.
     * @param {string} [processInstanceIdIn] Restrict to tasks that belong to process instances with the given ids.
     * @param {string} [processInstanceBusinessKey] Restrict to tasks that belong to process instances with the given business key.
     * @param {string} [processInstanceBusinessKeyExpression] Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
     * @param {string} [processInstanceBusinessKeyIn] Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
     * @param {string} [processInstanceBusinessKeyLike] Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
     * @param {string} [processInstanceBusinessKeyLikeExpression] Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [processDefinitionId] Restrict to tasks that belong to a process definition with the given id.
     * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
     * @param {string} [processDefinitionKeyIn] Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
     * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
     * @param {string} [processDefinitionNameLike] Restrict to tasks that have a process definition name that has the parameter value as  a substring.
     * @param {string} [executionId] Restrict to tasks that belong to an execution with the given id.
     * @param {string} [caseInstanceId] Restrict to tasks that belong to case instances with the given id.
     * @param {string} [caseInstanceBusinessKey] Restrict to tasks that belong to case instances with the given business key.
     * @param {string} [caseInstanceBusinessKeyLike] Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
     * @param {string} [caseDefinitionId] Restrict to tasks that belong to a case definition with the given id.
     * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
     * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
     * @param {string} [caseDefinitionNameLike] Restrict to tasks that have a case definition name that has the parameter value as a  substring.
     * @param {string} [caseExecutionId] Restrict to tasks that belong to a case execution with the given id.
     * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
     * @param {string} [tenantIdIn] Only include tasks which belong to one of the passed and comma-separated  tenant ids.
     * @param {boolean} [withoutTenantId] Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
     * @param {string} [assignee] Restrict to tasks that the given user is assigned to.
     * @param {string} [assigneeExpression] Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [assigneeLike] Restrict to tasks that have an assignee that has the parameter  value as a substring.
     * @param {string} [assigneeLikeExpression] Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [assigneeIn] Only include tasks which are assigned to one of the passed and  comma-separated user ids.
     * @param {string} [owner] Restrict to tasks that the given user owns.
     * @param {string} [ownerExpression] Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [candidateGroup] Only include tasks that are offered to the given group.
     * @param {string} [candidateGroupExpression] Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [candidateUser] Only include tasks that are offered to the given user or to one of his groups.
     * @param {string} [candidateUserExpression] Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {boolean} [includeAssignedTasks] Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
     * @param {string} [involvedUser] Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
     * @param {string} [involvedUserExpression] Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
     * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
     * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
     * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
     * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
     * @param {string} [taskDefinitionKeyLike] Restrict to tasks that have a key that has the parameter value as a substring.
     * @param {string} [name] Restrict to tasks that have the given name.
     * @param {string} [nameNotEqual] Restrict to tasks that do not have the given name.
     * @param {string} [nameLike] Restrict to tasks that have a name with the given parameter value as substring.
     * @param {string} [nameNotLike] Restrict to tasks that do not have a name with the given parameter value as substring.
     * @param {string} [description] Restrict to tasks that have the given description.
     * @param {string} [descriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
     * @param {number} [priority] Restrict to tasks that have the given priority.
     * @param {number} [maxPriority] Restrict to tasks that have a lower or equal priority.
     * @param {number} [minPriority] Restrict to tasks that have a higher or equal priority.
     * @param {string} [dueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
     * @param {string} [dueDateExpression] Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [dueAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
     * @param {string} [dueAfterExpression] Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [dueBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
     * @param {string} [dueBeforeExpression] Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [followUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
     * @param {string} [followUpDateExpression] Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [followUpAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
     * @param {string} [followUpAfterExpression] Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [followUpBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
     * @param {string} [followUpBeforeExpression] Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [followUpBeforeOrNotExistent] Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
     * @param {string} [followUpBeforeOrNotExistentExpression] Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [createdOn] Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
     * @param {string} [createdOnExpression] Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [createdAfter] Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
     * @param {string} [createdAfterExpression] Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [createdBefore] Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
     * @param {string} [createdBeforeExpression] Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {'PENDING' | 'RESOLVED'} [delegationState] Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
     * @param {string} [candidateGroups] Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
     * @param {string} [candidateGroupsExpression] Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
     * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [withCandidateUsers] Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [withoutCandidateUsers] Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {string} [caseInstanceVariables] Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
     * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
     * @param {string} [parentTaskId] Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
     * @param {'instanceId' | 'caseInstanceId' | 'dueDate' | 'executionId' | 'caseExecutionId' | 'assignee' | 'created' | 'description' | 'id' | 'name' | 'nameCaseInsensitive' | 'priority' | 'processVariable' | 'executionVariable' | 'taskVariable' | 'caseExecutionVariable' | 'caseInstanceVariable'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    getTasks(processInstanceId, processInstanceIdIn, processInstanceBusinessKey, processInstanceBusinessKeyExpression, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, processInstanceBusinessKeyLikeExpression, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionName, processDefinitionNameLike, executionId, caseInstanceId, caseInstanceBusinessKey, caseInstanceBusinessKeyLike, caseDefinitionId, caseDefinitionKey, caseDefinitionName, caseDefinitionNameLike, caseExecutionId, activityInstanceIdIn, tenantIdIn, withoutTenantId, assignee, assigneeExpression, assigneeLike, assigneeLikeExpression, assigneeIn, owner, ownerExpression, candidateGroup, candidateGroupExpression, candidateUser, candidateUserExpression, includeAssignedTasks, involvedUser, involvedUserExpression, assigned, unassigned, taskDefinitionKey, taskDefinitionKeyIn, taskDefinitionKeyLike, name, nameNotEqual, nameLike, nameNotLike, description, descriptionLike, priority, maxPriority, minPriority, dueDate, dueDateExpression, dueAfter, dueAfterExpression, dueBefore, dueBeforeExpression, followUpDate, followUpDateExpression, followUpAfter, followUpAfterExpression, followUpBefore, followUpBeforeExpression, followUpBeforeOrNotExistent, followUpBeforeOrNotExistentExpression, createdOn, createdOnExpression, createdAfter, createdAfterExpression, createdBefore, createdBeforeExpression, delegationState, candidateGroups, candidateGroupsExpression, withCandidateGroups, withoutCandidateGroups, withCandidateUsers, withoutCandidateUsers, active, suspended, taskVariables, processVariables, caseInstanceVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, parentTaskId, sortBy, sortOrder, firstResult, maxResults, options) {
        return (0, exports.TaskApiFp)(this.configuration).getTasks(processInstanceId, processInstanceIdIn, processInstanceBusinessKey, processInstanceBusinessKeyExpression, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, processInstanceBusinessKeyLikeExpression, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionName, processDefinitionNameLike, executionId, caseInstanceId, caseInstanceBusinessKey, caseInstanceBusinessKeyLike, caseDefinitionId, caseDefinitionKey, caseDefinitionName, caseDefinitionNameLike, caseExecutionId, activityInstanceIdIn, tenantIdIn, withoutTenantId, assignee, assigneeExpression, assigneeLike, assigneeLikeExpression, assigneeIn, owner, ownerExpression, candidateGroup, candidateGroupExpression, candidateUser, candidateUserExpression, includeAssignedTasks, involvedUser, involvedUserExpression, assigned, unassigned, taskDefinitionKey, taskDefinitionKeyIn, taskDefinitionKeyLike, name, nameNotEqual, nameLike, nameNotLike, description, descriptionLike, priority, maxPriority, minPriority, dueDate, dueDateExpression, dueAfter, dueAfterExpression, dueBefore, dueBeforeExpression, followUpDate, followUpDateExpression, followUpAfter, followUpAfterExpression, followUpBefore, followUpBeforeExpression, followUpBeforeOrNotExistent, followUpBeforeOrNotExistentExpression, createdOn, createdOnExpression, createdAfter, createdAfterExpression, createdBefore, createdBeforeExpression, delegationState, candidateGroups, candidateGroupsExpression, withCandidateGroups, withoutCandidateGroups, withCandidateUsers, withoutCandidateUsers, active, suspended, taskVariables, processVariables, caseInstanceVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, parentTaskId, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the number of tasks that fulfill a provided filter. Corresponds to the size of the result set when using the [Get Tasks](https://docs.camunda.org/manual/7.13/reference/rest/task/) method.  **Security Consideration:** There are several query parameters (such as assigneeExpression) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) for custom code in the user guide for details.
     * @param {string} [processInstanceId] Restrict to tasks that belong to process instances with the given id.
     * @param {string} [processInstanceIdIn] Restrict to tasks that belong to process instances with the given ids.
     * @param {string} [processInstanceBusinessKey] Restrict to tasks that belong to process instances with the given business key.
     * @param {string} [processInstanceBusinessKeyExpression] Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
     * @param {string} [processInstanceBusinessKeyIn] Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
     * @param {string} [processInstanceBusinessKeyLike] Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
     * @param {string} [processInstanceBusinessKeyLikeExpression] Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [processDefinitionId] Restrict to tasks that belong to a process definition with the given id.
     * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
     * @param {string} [processDefinitionKeyIn] Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
     * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
     * @param {string} [processDefinitionNameLike] Restrict to tasks that have a process definition name that has the parameter value as  a substring.
     * @param {string} [executionId] Restrict to tasks that belong to an execution with the given id.
     * @param {string} [caseInstanceId] Restrict to tasks that belong to case instances with the given id.
     * @param {string} [caseInstanceBusinessKey] Restrict to tasks that belong to case instances with the given business key.
     * @param {string} [caseInstanceBusinessKeyLike] Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
     * @param {string} [caseDefinitionId] Restrict to tasks that belong to a case definition with the given id.
     * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
     * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
     * @param {string} [caseDefinitionNameLike] Restrict to tasks that have a case definition name that has the parameter value as a  substring.
     * @param {string} [caseExecutionId] Restrict to tasks that belong to a case execution with the given id.
     * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
     * @param {string} [tenantIdIn] Only include tasks which belong to one of the passed and comma-separated  tenant ids.
     * @param {boolean} [withoutTenantId] Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
     * @param {string} [assignee] Restrict to tasks that the given user is assigned to.
     * @param {string} [assigneeExpression] Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [assigneeLike] Restrict to tasks that have an assignee that has the parameter  value as a substring.
     * @param {string} [assigneeLikeExpression] Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [assigneeIn] Only include tasks which are assigned to one of the passed and  comma-separated user ids.
     * @param {string} [owner] Restrict to tasks that the given user owns.
     * @param {string} [ownerExpression] Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [candidateGroup] Only include tasks that are offered to the given group.
     * @param {string} [candidateGroupExpression] Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [candidateUser] Only include tasks that are offered to the given user or to one of his groups.
     * @param {string} [candidateUserExpression] Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {boolean} [includeAssignedTasks] Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
     * @param {string} [involvedUser] Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
     * @param {string} [involvedUserExpression] Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
     * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
     * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
     * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
     * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
     * @param {string} [taskDefinitionKeyLike] Restrict to tasks that have a key that has the parameter value as a substring.
     * @param {string} [name] Restrict to tasks that have the given name.
     * @param {string} [nameNotEqual] Restrict to tasks that do not have the given name.
     * @param {string} [nameLike] Restrict to tasks that have a name with the given parameter value as substring.
     * @param {string} [nameNotLike] Restrict to tasks that do not have a name with the given parameter value as substring.
     * @param {string} [description] Restrict to tasks that have the given description.
     * @param {string} [descriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
     * @param {number} [priority] Restrict to tasks that have the given priority.
     * @param {number} [maxPriority] Restrict to tasks that have a lower or equal priority.
     * @param {number} [minPriority] Restrict to tasks that have a higher or equal priority.
     * @param {string} [dueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
     * @param {string} [dueDateExpression] Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [dueAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
     * @param {string} [dueAfterExpression] Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [dueBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
     * @param {string} [dueBeforeExpression] Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [followUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
     * @param {string} [followUpDateExpression] Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [followUpAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
     * @param {string} [followUpAfterExpression] Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [followUpBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
     * @param {string} [followUpBeforeExpression] Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [followUpBeforeOrNotExistent] Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
     * @param {string} [followUpBeforeOrNotExistentExpression] Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [createdOn] Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
     * @param {string} [createdOnExpression] Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [createdAfter] Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
     * @param {string} [createdAfterExpression] Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [createdBefore] Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
     * @param {string} [createdBeforeExpression] Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {'PENDING' | 'RESOLVED'} [delegationState] Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
     * @param {string} [candidateGroups] Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
     * @param {string} [candidateGroupsExpression] Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
     * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [withCandidateUsers] Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [withoutCandidateUsers] Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {string} [caseInstanceVariables] Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
     * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
     * @param {string} [parentTaskId] Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    getTasksCount(processInstanceId, processInstanceIdIn, processInstanceBusinessKey, processInstanceBusinessKeyExpression, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, processInstanceBusinessKeyLikeExpression, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionName, processDefinitionNameLike, executionId, caseInstanceId, caseInstanceBusinessKey, caseInstanceBusinessKeyLike, caseDefinitionId, caseDefinitionKey, caseDefinitionName, caseDefinitionNameLike, caseExecutionId, activityInstanceIdIn, tenantIdIn, withoutTenantId, assignee, assigneeExpression, assigneeLike, assigneeLikeExpression, assigneeIn, owner, ownerExpression, candidateGroup, candidateGroupExpression, candidateUser, candidateUserExpression, includeAssignedTasks, involvedUser, involvedUserExpression, assigned, unassigned, taskDefinitionKey, taskDefinitionKeyIn, taskDefinitionKeyLike, name, nameNotEqual, nameLike, nameNotLike, description, descriptionLike, priority, maxPriority, minPriority, dueDate, dueDateExpression, dueAfter, dueAfterExpression, dueBefore, dueBeforeExpression, followUpDate, followUpDateExpression, followUpAfter, followUpAfterExpression, followUpBefore, followUpBeforeExpression, followUpBeforeOrNotExistent, followUpBeforeOrNotExistentExpression, createdOn, createdOnExpression, createdAfter, createdAfterExpression, createdBefore, createdBeforeExpression, delegationState, candidateGroups, candidateGroupsExpression, withCandidateGroups, withoutCandidateGroups, withCandidateUsers, withoutCandidateUsers, active, suspended, taskVariables, processVariables, caseInstanceVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, parentTaskId, options) {
        return (0, exports.TaskApiFp)(this.configuration).getTasksCount(processInstanceId, processInstanceIdIn, processInstanceBusinessKey, processInstanceBusinessKeyExpression, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, processInstanceBusinessKeyLikeExpression, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionName, processDefinitionNameLike, executionId, caseInstanceId, caseInstanceBusinessKey, caseInstanceBusinessKeyLike, caseDefinitionId, caseDefinitionKey, caseDefinitionName, caseDefinitionNameLike, caseExecutionId, activityInstanceIdIn, tenantIdIn, withoutTenantId, assignee, assigneeExpression, assigneeLike, assigneeLikeExpression, assigneeIn, owner, ownerExpression, candidateGroup, candidateGroupExpression, candidateUser, candidateUserExpression, includeAssignedTasks, involvedUser, involvedUserExpression, assigned, unassigned, taskDefinitionKey, taskDefinitionKeyIn, taskDefinitionKeyLike, name, nameNotEqual, nameLike, nameNotLike, description, descriptionLike, priority, maxPriority, minPriority, dueDate, dueDateExpression, dueAfter, dueAfterExpression, dueBefore, dueBeforeExpression, followUpDate, followUpDateExpression, followUpAfter, followUpAfterExpression, followUpBefore, followUpBeforeExpression, followUpBeforeOrNotExistent, followUpBeforeOrNotExistentExpression, createdOn, createdOnExpression, createdAfter, createdAfterExpression, createdBefore, createdBeforeExpression, delegationState, candidateGroups, candidateGroupsExpression, withCandidateGroups, withoutCandidateGroups, withCandidateUsers, withoutCandidateUsers, active, suspended, taskVariables, processVariables, caseInstanceVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, parentTaskId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Reports a business error in the context of a running task by id. The error code must be specified to identify the BPMN error handler. See the documentation for [Reporting Bpmn Error](https://docs.camunda.org/manual/7.13/reference/bpmn20/tasks/user-task/#reporting-bpmn-error) in User Tasks.
     * @param {string} id The id of the task a BPMN error is reported for.
     * @param {TaskBpmnErrorDto} [taskBpmnErrorDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    handleBpmnError(id, taskBpmnErrorDto, options) {
        return (0, exports.TaskApiFp)(this.configuration).handleBpmnError(id, taskBpmnErrorDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Reports an escalation in the context of a running task by id. The escalation code must be specified to identify the escalation handler. See the documentation for [Reporting Bpmn Escalation](https://docs.camunda.org/manual/7.13/reference/bpmn20/tasks/user-task/#reporting-bpmn-escalation) in User Tasks.
     * @param {string} id The id of the task in which context a BPMN escalation is reported.
     * @param {TaskEscalationDto} [taskEscalationDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    handleEscalation(id, taskEscalationDto, options) {
        return (0, exports.TaskApiFp)(this.configuration).handleEscalation(id, taskEscalationDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for tasks that fulfill a given filter. This method is slightly more powerful than the [Get Tasks](https://docs.camunda.org/manual/7.13/reference/rest/task/get-query/) method because it allows filtering by multiple process or task variables of types `String`, `Number` or `Boolean`. The size of the result set can be retrieved by using the [Get Task Count (POST)](https://docs.camunda.org/manual/7.13/reference/rest/task/post-query-count/) method.  **Security Consideration**: There are several parameters (such as `assigneeExpression`) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) in the user guide for details.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {TaskQueryDto} [taskQueryDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    queryTasks(firstResult, maxResults, taskQueryDto, options) {
        return (0, exports.TaskApiFp)(this.configuration).queryTasks(firstResult, maxResults, taskQueryDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the number of tasks that fulfill the given filter. Corresponds to the size of the result set of the [Get Tasks (POST)](https://docs.camunda.org/manual/7.13/reference/rest/task/post-query/) method and takes the same parameters.  **Security Consideration**: There are several parameters (such as `assigneeExpression`) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) in the user guide for details.
     * @param {TaskQueryDto} [taskQueryDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    queryTasksCount(taskQueryDto, options) {
        return (0, exports.TaskApiFp)(this.configuration).queryTasksCount(taskQueryDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Resolves a task and updates execution variables.  Resolving a task marks that the assignee is done with the task delegated to them, and that it can be sent back to the owner. Can only be executed when the task has been delegated. The assignee will be set to the owner, who performed the delegation.
     * @param {string} id The id of the task to resolve.
     * @param {CompleteTaskDto} [completeTaskDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    resolve(id, completeTaskDto, options) {
        return (0, exports.TaskApiFp)(this.configuration).resolve(id, completeTaskDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Changes the assignee of a task to a specific user.  **Note:** The difference with the [Claim Task](https://docs.camunda.org/manual/7.13/reference/rest/task/post-claim/) method is that this method does not check if the task already has a user assigned to it.
     * @param {string} id The id of the task to set the assignee for.
     * @param {UserIdDto} [userIdDto] Provide the id of the user that will be the assignee of the task.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    setAssignee(id, userIdDto, options) {
        return (0, exports.TaskApiFp)(this.configuration).setAssignee(id, userIdDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Completes a task and updates process variables using a form submit. There are two difference between this method and the `complete` method:  * If the task is in state `PENDING` - i.e., has been delegated before, it is not completed but resolved. Otherwise it will be completed. * If the task has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See the [Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/_index/#generated-task-forms) section of the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/) for more information.
     * @param {string} id The id of the task to submit the form for.
     * @param {CompleteTaskDto} [completeTaskDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    submit(id, completeTaskDto, options) {
        return (0, exports.TaskApiFp)(this.configuration).submit(id, completeTaskDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Resets a task\'s assignee. If successful, the task is not assigned to a user.
     * @param {string} id The id of the task to unclaim.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    unclaim(id, options) {
        return (0, exports.TaskApiFp)(this.configuration).unclaim(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates a task.
     * @param {string} id The id of the task to be updated.
     * @param {TaskDto} [taskDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    updateTask(id, taskDto, options) {
        return (0, exports.TaskApiFp)(this.configuration).updateTask(id, taskDto, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TaskApi = TaskApi;
/**
 * TaskAttachmentApi - axios parameter creator
 * @export
 */
const TaskAttachmentApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates an attachment for a task.
         * @param {string} id The id of the task to add the attachment to.
         * @param {string} [attachmentName] The name of the attachment.
         * @param {string} [attachmentDescription] The description of the attachment.
         * @param {string} [attachmentType] The type of the attachment.
         * @param {string} [url] The url to the remote content of the attachment.
         * @param {any} [content] The content of the attachment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAttachment: async (id, attachmentName, attachmentDescription, attachmentType, url, content, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('addAttachment', 'id', id);
            const localVarPath = `/task/{id}/attachment/create`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            if (attachmentName !== undefined) {
                localVarFormParams.append('attachment-name', attachmentName);
            }
            if (attachmentDescription !== undefined) {
                localVarFormParams.append('attachment-description', attachmentDescription);
            }
            if (attachmentType !== undefined) {
                localVarFormParams.append('attachment-type', attachmentType);
            }
            if (url !== undefined) {
                localVarFormParams.append('url', url);
            }
            if (content !== undefined) {
                localVarFormParams.append('content', content);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes an attachment from a task by id.
         * @param {string} id The id of the task.
         * @param {string} attachmentId The id of the attachment to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttachment: async (id, attachmentId, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteAttachment', 'id', id);
            // verify required parameter 'attachmentId' is not null or undefined
            (0, common_1.assertParamExists)('deleteAttachment', 'attachmentId', attachmentId);
            const localVarPath = `/task/{id}/attachment/{attachmentId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"attachmentId"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a task attachment by task id and attachment id.
         * @param {string} id The id of the task.
         * @param {string} attachmentId The id of the attachment to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachment: async (id, attachmentId, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getAttachment', 'id', id);
            // verify required parameter 'attachmentId' is not null or undefined
            (0, common_1.assertParamExists)('getAttachment', 'attachmentId', attachmentId);
            const localVarPath = `/task/{id}/attachment/{attachmentId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"attachmentId"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the binary content of a task attachment by task id and attachment id.
         * @param {string} id The id of the task.
         * @param {string} attachmentId The id of the attachment to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentData: async (id, attachmentId, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getAttachmentData', 'id', id);
            // verify required parameter 'attachmentId' is not null or undefined
            (0, common_1.assertParamExists)('getAttachmentData', 'attachmentId', attachmentId);
            const localVarPath = `/task/{id}/attachment/{attachmentId}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"attachmentId"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the attachments for a task.
         * @param {string} id The id of the task to retrieve the attachments for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachments: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getAttachments', 'id', id);
            const localVarPath = `/task/{id}/attachment`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.TaskAttachmentApiAxiosParamCreator = TaskAttachmentApiAxiosParamCreator;
/**
 * TaskAttachmentApi - functional programming interface
 * @export
 */
const TaskAttachmentApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TaskAttachmentApiAxiosParamCreator)(configuration);
    return {
        /**
         * Creates an attachment for a task.
         * @param {string} id The id of the task to add the attachment to.
         * @param {string} [attachmentName] The name of the attachment.
         * @param {string} [attachmentDescription] The description of the attachment.
         * @param {string} [attachmentType] The type of the attachment.
         * @param {string} [url] The url to the remote content of the attachment.
         * @param {any} [content] The content of the attachment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAttachment(id, attachmentName, attachmentDescription, attachmentType, url, content, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAttachment(id, attachmentName, attachmentDescription, attachmentType, url, content, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Removes an attachment from a task by id.
         * @param {string} id The id of the task.
         * @param {string} attachmentId The id of the attachment to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAttachment(id, attachmentId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAttachment(id, attachmentId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves a task attachment by task id and attachment id.
         * @param {string} id The id of the task.
         * @param {string} attachmentId The id of the attachment to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAttachment(id, attachmentId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAttachment(id, attachmentId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves the binary content of a task attachment by task id and attachment id.
         * @param {string} id The id of the task.
         * @param {string} attachmentId The id of the attachment to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAttachmentData(id, attachmentId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAttachmentData(id, attachmentId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Gets the attachments for a task.
         * @param {string} id The id of the task to retrieve the attachments for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAttachments(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAttachments(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.TaskAttachmentApiFp = TaskAttachmentApiFp;
/**
 * TaskAttachmentApi - factory interface
 * @export
 */
const TaskAttachmentApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TaskAttachmentApiFp)(configuration);
    return {
        /**
         * Creates an attachment for a task.
         * @param {string} id The id of the task to add the attachment to.
         * @param {string} [attachmentName] The name of the attachment.
         * @param {string} [attachmentDescription] The description of the attachment.
         * @param {string} [attachmentType] The type of the attachment.
         * @param {string} [url] The url to the remote content of the attachment.
         * @param {any} [content] The content of the attachment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAttachment(id, attachmentName, attachmentDescription, attachmentType, url, content, options) {
            return localVarFp.addAttachment(id, attachmentName, attachmentDescription, attachmentType, url, content, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes an attachment from a task by id.
         * @param {string} id The id of the task.
         * @param {string} attachmentId The id of the attachment to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttachment(id, attachmentId, options) {
            return localVarFp.deleteAttachment(id, attachmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a task attachment by task id and attachment id.
         * @param {string} id The id of the task.
         * @param {string} attachmentId The id of the attachment to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachment(id, attachmentId, options) {
            return localVarFp.getAttachment(id, attachmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the binary content of a task attachment by task id and attachment id.
         * @param {string} id The id of the task.
         * @param {string} attachmentId The id of the attachment to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentData(id, attachmentId, options) {
            return localVarFp.getAttachmentData(id, attachmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the attachments for a task.
         * @param {string} id The id of the task to retrieve the attachments for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachments(id, options) {
            return localVarFp.getAttachments(id, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TaskAttachmentApiFactory = TaskAttachmentApiFactory;
/**
 * TaskAttachmentApi - object-oriented interface
 * @export
 * @class TaskAttachmentApi
 * @extends {BaseAPI}
 */
class TaskAttachmentApi extends base_1.BaseAPI {
    /**
     * Creates an attachment for a task.
     * @param {string} id The id of the task to add the attachment to.
     * @param {string} [attachmentName] The name of the attachment.
     * @param {string} [attachmentDescription] The description of the attachment.
     * @param {string} [attachmentType] The type of the attachment.
     * @param {string} [url] The url to the remote content of the attachment.
     * @param {any} [content] The content of the attachment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskAttachmentApi
     */
    addAttachment(id, attachmentName, attachmentDescription, attachmentType, url, content, options) {
        return (0, exports.TaskAttachmentApiFp)(this.configuration).addAttachment(id, attachmentName, attachmentDescription, attachmentType, url, content, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Removes an attachment from a task by id.
     * @param {string} id The id of the task.
     * @param {string} attachmentId The id of the attachment to be removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskAttachmentApi
     */
    deleteAttachment(id, attachmentId, options) {
        return (0, exports.TaskAttachmentApiFp)(this.configuration).deleteAttachment(id, attachmentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a task attachment by task id and attachment id.
     * @param {string} id The id of the task.
     * @param {string} attachmentId The id of the attachment to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskAttachmentApi
     */
    getAttachment(id, attachmentId, options) {
        return (0, exports.TaskAttachmentApiFp)(this.configuration).getAttachment(id, attachmentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the binary content of a task attachment by task id and attachment id.
     * @param {string} id The id of the task.
     * @param {string} attachmentId The id of the attachment to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskAttachmentApi
     */
    getAttachmentData(id, attachmentId, options) {
        return (0, exports.TaskAttachmentApiFp)(this.configuration).getAttachmentData(id, attachmentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets the attachments for a task.
     * @param {string} id The id of the task to retrieve the attachments for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskAttachmentApi
     */
    getAttachments(id, options) {
        return (0, exports.TaskAttachmentApiFp)(this.configuration).getAttachments(id, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TaskAttachmentApi = TaskAttachmentApi;
/**
 * TaskCommentApi - axios parameter creator
 * @export
 */
const TaskCommentApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates a comment for a task by id.
         * @param {string} id The id of the task to add the comment to.
         * @param {CommentDto} [commentDto] **Note:** Only the &#x60;message&#x60; property will be used. Every other property passed to this endpoint will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComment: async (id, commentDto, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('createComment', 'id', id);
            const localVarPath = `/task/{id}/comment/create`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(commentDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a task comment by task id and comment id.
         * @param {string} id The id of the task.
         * @param {string} commentId The id of the comment to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComment: async (id, commentId, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getComment', 'id', id);
            // verify required parameter 'commentId' is not null or undefined
            (0, common_1.assertParamExists)('getComment', 'commentId', commentId);
            const localVarPath = `/task/{id}/comment/{commentId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the comments for a task by id.
         * @param {string} id The id of the task to retrieve the comments for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComments: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getComments', 'id', id);
            const localVarPath = `/task/{id}/comment`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.TaskCommentApiAxiosParamCreator = TaskCommentApiAxiosParamCreator;
/**
 * TaskCommentApi - functional programming interface
 * @export
 */
const TaskCommentApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TaskCommentApiAxiosParamCreator)(configuration);
    return {
        /**
         * Creates a comment for a task by id.
         * @param {string} id The id of the task to add the comment to.
         * @param {CommentDto} [commentDto] **Note:** Only the &#x60;message&#x60; property will be used. Every other property passed to this endpoint will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createComment(id, commentDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createComment(id, commentDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves a task comment by task id and comment id.
         * @param {string} id The id of the task.
         * @param {string} commentId The id of the comment to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getComment(id, commentId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getComment(id, commentId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Gets the comments for a task by id.
         * @param {string} id The id of the task to retrieve the comments for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getComments(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getComments(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.TaskCommentApiFp = TaskCommentApiFp;
/**
 * TaskCommentApi - factory interface
 * @export
 */
const TaskCommentApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TaskCommentApiFp)(configuration);
    return {
        /**
         * Creates a comment for a task by id.
         * @param {string} id The id of the task to add the comment to.
         * @param {CommentDto} [commentDto] **Note:** Only the &#x60;message&#x60; property will be used. Every other property passed to this endpoint will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComment(id, commentDto, options) {
            return localVarFp.createComment(id, commentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a task comment by task id and comment id.
         * @param {string} id The id of the task.
         * @param {string} commentId The id of the comment to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComment(id, commentId, options) {
            return localVarFp.getComment(id, commentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the comments for a task by id.
         * @param {string} id The id of the task to retrieve the comments for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComments(id, options) {
            return localVarFp.getComments(id, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TaskCommentApiFactory = TaskCommentApiFactory;
/**
 * TaskCommentApi - object-oriented interface
 * @export
 * @class TaskCommentApi
 * @extends {BaseAPI}
 */
class TaskCommentApi extends base_1.BaseAPI {
    /**
     * Creates a comment for a task by id.
     * @param {string} id The id of the task to add the comment to.
     * @param {CommentDto} [commentDto] **Note:** Only the &#x60;message&#x60; property will be used. Every other property passed to this endpoint will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskCommentApi
     */
    createComment(id, commentDto, options) {
        return (0, exports.TaskCommentApiFp)(this.configuration).createComment(id, commentDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a task comment by task id and comment id.
     * @param {string} id The id of the task.
     * @param {string} commentId The id of the comment to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskCommentApi
     */
    getComment(id, commentId, options) {
        return (0, exports.TaskCommentApiFp)(this.configuration).getComment(id, commentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets the comments for a task by id.
     * @param {string} id The id of the task to retrieve the comments for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskCommentApi
     */
    getComments(id, options) {
        return (0, exports.TaskCommentApiFp)(this.configuration).getComments(id, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TaskCommentApi = TaskCommentApi;
/**
 * TaskIdentityLinkApi - axios parameter creator
 * @export
 */
const TaskIdentityLinkApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Adds an identity link to a task by id. Can be used to link any user or group to a task and specify a relation.
         * @param {string} id The id of the task to add a link to.
         * @param {IdentityLinkDto} [identityLinkDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addIdentityLink: async (id, identityLinkDto, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('addIdentityLink', 'id', id);
            const localVarPath = `/task/{id}/identity-links`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(identityLinkDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes an identity link from a task by id
         * @param {string} id The id of the task to remove a link from.
         * @param {IdentityLinkDto} [identityLinkDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentityLink: async (id, identityLinkDto, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteIdentityLink', 'id', id);
            const localVarPath = `/task/{id}/identity-links/delete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(identityLinkDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the identity links for a task by id, which are the users and groups that are in *some* relation to it (including assignee and owner).
         * @param {string} id The id of the task to retrieve the identity links for.
         * @param {string} [type] Filter by the type of links to include.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityLinks: async (id, type, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getIdentityLinks', 'id', id);
            const localVarPath = `/task/{id}/identity-links`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.TaskIdentityLinkApiAxiosParamCreator = TaskIdentityLinkApiAxiosParamCreator;
/**
 * TaskIdentityLinkApi - functional programming interface
 * @export
 */
const TaskIdentityLinkApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TaskIdentityLinkApiAxiosParamCreator)(configuration);
    return {
        /**
         * Adds an identity link to a task by id. Can be used to link any user or group to a task and specify a relation.
         * @param {string} id The id of the task to add a link to.
         * @param {IdentityLinkDto} [identityLinkDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addIdentityLink(id, identityLinkDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addIdentityLink(id, identityLinkDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Removes an identity link from a task by id
         * @param {string} id The id of the task to remove a link from.
         * @param {IdentityLinkDto} [identityLinkDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIdentityLink(id, identityLinkDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteIdentityLink(id, identityLinkDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Gets the identity links for a task by id, which are the users and groups that are in *some* relation to it (including assignee and owner).
         * @param {string} id The id of the task to retrieve the identity links for.
         * @param {string} [type] Filter by the type of links to include.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityLinks(id, type, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityLinks(id, type, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.TaskIdentityLinkApiFp = TaskIdentityLinkApiFp;
/**
 * TaskIdentityLinkApi - factory interface
 * @export
 */
const TaskIdentityLinkApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TaskIdentityLinkApiFp)(configuration);
    return {
        /**
         * Adds an identity link to a task by id. Can be used to link any user or group to a task and specify a relation.
         * @param {string} id The id of the task to add a link to.
         * @param {IdentityLinkDto} [identityLinkDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addIdentityLink(id, identityLinkDto, options) {
            return localVarFp.addIdentityLink(id, identityLinkDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes an identity link from a task by id
         * @param {string} id The id of the task to remove a link from.
         * @param {IdentityLinkDto} [identityLinkDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentityLink(id, identityLinkDto, options) {
            return localVarFp.deleteIdentityLink(id, identityLinkDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the identity links for a task by id, which are the users and groups that are in *some* relation to it (including assignee and owner).
         * @param {string} id The id of the task to retrieve the identity links for.
         * @param {string} [type] Filter by the type of links to include.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityLinks(id, type, options) {
            return localVarFp.getIdentityLinks(id, type, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TaskIdentityLinkApiFactory = TaskIdentityLinkApiFactory;
/**
 * TaskIdentityLinkApi - object-oriented interface
 * @export
 * @class TaskIdentityLinkApi
 * @extends {BaseAPI}
 */
class TaskIdentityLinkApi extends base_1.BaseAPI {
    /**
     * Adds an identity link to a task by id. Can be used to link any user or group to a task and specify a relation.
     * @param {string} id The id of the task to add a link to.
     * @param {IdentityLinkDto} [identityLinkDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskIdentityLinkApi
     */
    addIdentityLink(id, identityLinkDto, options) {
        return (0, exports.TaskIdentityLinkApiFp)(this.configuration).addIdentityLink(id, identityLinkDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Removes an identity link from a task by id
     * @param {string} id The id of the task to remove a link from.
     * @param {IdentityLinkDto} [identityLinkDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskIdentityLinkApi
     */
    deleteIdentityLink(id, identityLinkDto, options) {
        return (0, exports.TaskIdentityLinkApiFp)(this.configuration).deleteIdentityLink(id, identityLinkDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets the identity links for a task by id, which are the users and groups that are in *some* relation to it (including assignee and owner).
     * @param {string} id The id of the task to retrieve the identity links for.
     * @param {string} [type] Filter by the type of links to include.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskIdentityLinkApi
     */
    getIdentityLinks(id, type, options) {
        return (0, exports.TaskIdentityLinkApiFp)(this.configuration).getIdentityLinks(id, type, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TaskIdentityLinkApi = TaskIdentityLinkApi;
/**
 * TaskLocalVariableApi - axios parameter creator
 * @export
 */
const TaskLocalVariableApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Removes a local variable from a task by id.
         * @param {string} id The id of the task to delete the variable from.
         * @param {string} varName The name of the variable to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaskLocalVariable: async (id, varName, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteTaskLocalVariable', 'id', id);
            // verify required parameter 'varName' is not null or undefined
            (0, common_1.assertParamExists)('deleteTaskLocalVariable', 'varName', varName);
            const localVarPath = `/task/{id}/localVariables/{varName}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a variable from the context of a given task by id.
         * @param {string} id The id of the task to retrieve the variable from.
         * @param {string} varName The name of the variable to get
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskLocalVariable: async (id, varName, deserializeValue, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getTaskLocalVariable', 'id', id);
            // verify required parameter 'varName' is not null or undefined
            (0, common_1.assertParamExists)('getTaskLocalVariable', 'varName', varName);
            const localVarPath = `/task/{id}/localVariables/{varName}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (deserializeValue !== undefined) {
                localVarQueryParameter['deserializeValue'] = deserializeValue;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a binary variable from the context of a given task by id. Applicable for byte array and file variables.
         * @param {string} id The id of the task to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskLocalVariableBinary: async (id, varName, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getTaskLocalVariableBinary', 'id', id);
            // verify required parameter 'varName' is not null or undefined
            (0, common_1.assertParamExists)('getTaskLocalVariableBinary', 'varName', varName);
            const localVarPath = `/task/{id}/localVariables/{varName}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all variables of a given task by id.
         * @param {string} id The id of the task to retrieve the variables from.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskLocalVariables: async (id, deserializeValues, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getTaskLocalVariables', 'id', id);
            const localVarPath = `/task/{id}/localVariables`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (deserializeValues !== undefined) {
                localVarQueryParameter['deserializeValues'] = deserializeValues;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates or deletes the variables in the context of a task. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
         * @param {string} id The id of the task to set variables for.
         * @param {PatchVariablesDto} [patchVariablesDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyTaskLocalVariables: async (id, patchVariablesDto, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('modifyTaskLocalVariables', 'id', id);
            const localVarPath = `/task/{id}/localVariables`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(patchVariablesDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets a variable in the context of a given task.
         * @param {string} id The id of the task to set the variable for.
         * @param {string} varName The name of the variable to set.
         * @param {VariableValueDto} [variableValueDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTaskLocalVariable: async (id, varName, variableValueDto, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('putTaskLocalVariable', 'id', id);
            // verify required parameter 'varName' is not null or undefined
            (0, common_1.assertParamExists)('putTaskLocalVariable', 'varName', varName);
            const localVarPath = `/task/{id}/localVariables/{varName}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(variableValueDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the serialized value for a binary variable or the binary value for a file variable.
         * @param {string} id The id of the task to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {any} [data] The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory.
         * @param {string} [valueType] The name of the variable type. Either Bytes for a byte array variable or File for a file variable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBinaryTaskLocalVariable: async (id, varName, data, valueType, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('setBinaryTaskLocalVariable', 'id', id);
            // verify required parameter 'varName' is not null or undefined
            (0, common_1.assertParamExists)('setBinaryTaskLocalVariable', 'varName', varName);
            const localVarPath = `/task/{id}/localVariables/{varName}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            if (data !== undefined) {
                localVarFormParams.append('data', data);
            }
            if (valueType !== undefined) {
                localVarFormParams.append('valueType', valueType);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.TaskLocalVariableApiAxiosParamCreator = TaskLocalVariableApiAxiosParamCreator;
/**
 * TaskLocalVariableApi - functional programming interface
 * @export
 */
const TaskLocalVariableApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TaskLocalVariableApiAxiosParamCreator)(configuration);
    return {
        /**
         * Removes a local variable from a task by id.
         * @param {string} id The id of the task to delete the variable from.
         * @param {string} varName The name of the variable to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTaskLocalVariable(id, varName, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTaskLocalVariable(id, varName, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves a variable from the context of a given task by id.
         * @param {string} id The id of the task to retrieve the variable from.
         * @param {string} varName The name of the variable to get
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskLocalVariable(id, varName, deserializeValue, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskLocalVariable(id, varName, deserializeValue, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves a binary variable from the context of a given task by id. Applicable for byte array and file variables.
         * @param {string} id The id of the task to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskLocalVariableBinary(id, varName, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskLocalVariableBinary(id, varName, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves all variables of a given task by id.
         * @param {string} id The id of the task to retrieve the variables from.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskLocalVariables(id, deserializeValues, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskLocalVariables(id, deserializeValues, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Updates or deletes the variables in the context of a task. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
         * @param {string} id The id of the task to set variables for.
         * @param {PatchVariablesDto} [patchVariablesDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyTaskLocalVariables(id, patchVariablesDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyTaskLocalVariables(id, patchVariablesDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Sets a variable in the context of a given task.
         * @param {string} id The id of the task to set the variable for.
         * @param {string} varName The name of the variable to set.
         * @param {VariableValueDto} [variableValueDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putTaskLocalVariable(id, varName, variableValueDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putTaskLocalVariable(id, varName, variableValueDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Sets the serialized value for a binary variable or the binary value for a file variable.
         * @param {string} id The id of the task to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {any} [data] The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory.
         * @param {string} [valueType] The name of the variable type. Either Bytes for a byte array variable or File for a file variable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setBinaryTaskLocalVariable(id, varName, data, valueType, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setBinaryTaskLocalVariable(id, varName, data, valueType, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.TaskLocalVariableApiFp = TaskLocalVariableApiFp;
/**
 * TaskLocalVariableApi - factory interface
 * @export
 */
const TaskLocalVariableApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TaskLocalVariableApiFp)(configuration);
    return {
        /**
         * Removes a local variable from a task by id.
         * @param {string} id The id of the task to delete the variable from.
         * @param {string} varName The name of the variable to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaskLocalVariable(id, varName, options) {
            return localVarFp.deleteTaskLocalVariable(id, varName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a variable from the context of a given task by id.
         * @param {string} id The id of the task to retrieve the variable from.
         * @param {string} varName The name of the variable to get
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskLocalVariable(id, varName, deserializeValue, options) {
            return localVarFp.getTaskLocalVariable(id, varName, deserializeValue, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a binary variable from the context of a given task by id. Applicable for byte array and file variables.
         * @param {string} id The id of the task to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskLocalVariableBinary(id, varName, options) {
            return localVarFp.getTaskLocalVariableBinary(id, varName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all variables of a given task by id.
         * @param {string} id The id of the task to retrieve the variables from.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskLocalVariables(id, deserializeValues, options) {
            return localVarFp.getTaskLocalVariables(id, deserializeValues, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates or deletes the variables in the context of a task. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
         * @param {string} id The id of the task to set variables for.
         * @param {PatchVariablesDto} [patchVariablesDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyTaskLocalVariables(id, patchVariablesDto, options) {
            return localVarFp.modifyTaskLocalVariables(id, patchVariablesDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets a variable in the context of a given task.
         * @param {string} id The id of the task to set the variable for.
         * @param {string} varName The name of the variable to set.
         * @param {VariableValueDto} [variableValueDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTaskLocalVariable(id, varName, variableValueDto, options) {
            return localVarFp.putTaskLocalVariable(id, varName, variableValueDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the serialized value for a binary variable or the binary value for a file variable.
         * @param {string} id The id of the task to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {any} [data] The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory.
         * @param {string} [valueType] The name of the variable type. Either Bytes for a byte array variable or File for a file variable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBinaryTaskLocalVariable(id, varName, data, valueType, options) {
            return localVarFp.setBinaryTaskLocalVariable(id, varName, data, valueType, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TaskLocalVariableApiFactory = TaskLocalVariableApiFactory;
/**
 * TaskLocalVariableApi - object-oriented interface
 * @export
 * @class TaskLocalVariableApi
 * @extends {BaseAPI}
 */
class TaskLocalVariableApi extends base_1.BaseAPI {
    /**
     * Removes a local variable from a task by id.
     * @param {string} id The id of the task to delete the variable from.
     * @param {string} varName The name of the variable to be removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskLocalVariableApi
     */
    deleteTaskLocalVariable(id, varName, options) {
        return (0, exports.TaskLocalVariableApiFp)(this.configuration).deleteTaskLocalVariable(id, varName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a variable from the context of a given task by id.
     * @param {string} id The id of the task to retrieve the variable from.
     * @param {string} varName The name of the variable to get
     * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskLocalVariableApi
     */
    getTaskLocalVariable(id, varName, deserializeValue, options) {
        return (0, exports.TaskLocalVariableApiFp)(this.configuration).getTaskLocalVariable(id, varName, deserializeValue, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a binary variable from the context of a given task by id. Applicable for byte array and file variables.
     * @param {string} id The id of the task to retrieve the variable for.
     * @param {string} varName The name of the variable to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskLocalVariableApi
     */
    getTaskLocalVariableBinary(id, varName, options) {
        return (0, exports.TaskLocalVariableApiFp)(this.configuration).getTaskLocalVariableBinary(id, varName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves all variables of a given task by id.
     * @param {string} id The id of the task to retrieve the variables from.
     * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskLocalVariableApi
     */
    getTaskLocalVariables(id, deserializeValues, options) {
        return (0, exports.TaskLocalVariableApiFp)(this.configuration).getTaskLocalVariables(id, deserializeValues, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates or deletes the variables in the context of a task. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
     * @param {string} id The id of the task to set variables for.
     * @param {PatchVariablesDto} [patchVariablesDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskLocalVariableApi
     */
    modifyTaskLocalVariables(id, patchVariablesDto, options) {
        return (0, exports.TaskLocalVariableApiFp)(this.configuration).modifyTaskLocalVariables(id, patchVariablesDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets a variable in the context of a given task.
     * @param {string} id The id of the task to set the variable for.
     * @param {string} varName The name of the variable to set.
     * @param {VariableValueDto} [variableValueDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskLocalVariableApi
     */
    putTaskLocalVariable(id, varName, variableValueDto, options) {
        return (0, exports.TaskLocalVariableApiFp)(this.configuration).putTaskLocalVariable(id, varName, variableValueDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets the serialized value for a binary variable or the binary value for a file variable.
     * @param {string} id The id of the task to retrieve the variable for.
     * @param {string} varName The name of the variable to retrieve.
     * @param {any} [data] The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory.
     * @param {string} [valueType] The name of the variable type. Either Bytes for a byte array variable or File for a file variable.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskLocalVariableApi
     */
    setBinaryTaskLocalVariable(id, varName, data, valueType, options) {
        return (0, exports.TaskLocalVariableApiFp)(this.configuration).setBinaryTaskLocalVariable(id, varName, data, valueType, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TaskLocalVariableApi = TaskLocalVariableApi;
/**
 * TaskVariableApi - axios parameter creator
 * @export
 */
const TaskVariableApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Removes a variable that is visible to a task. A variable is visible to a task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to delete the variable from.
         * @param {string} varName The name of the variable to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaskVariable: async (id, varName, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteTaskVariable', 'id', id);
            // verify required parameter 'varName' is not null or undefined
            (0, common_1.assertParamExists)('deleteTaskVariable', 'varName', varName);
            const localVarPath = `/task/{id}/variables/{varName}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a variable from the context of a given task. The variable must be visible from the task. It is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to retrieve the variable from.
         * @param {string} varName The name of the variable to get.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskVariable: async (id, varName, deserializeValue, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getTaskVariable', 'id', id);
            // verify required parameter 'varName' is not null or undefined
            (0, common_1.assertParamExists)('getTaskVariable', 'varName', varName);
            const localVarPath = `/task/{id}/variables/{varName}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (deserializeValue !== undefined) {
                localVarQueryParameter['deserializeValue'] = deserializeValue;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a binary variable from the context of a given task. Applicable for byte array and file variables. The variable must be visible from the task. It is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskVariableBinary: async (id, varName, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getTaskVariableBinary', 'id', id);
            // verify required parameter 'varName' is not null or undefined
            (0, common_1.assertParamExists)('getTaskVariableBinary', 'varName', varName);
            const localVarPath = `/task/{id}/variables/{varName}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all variables visible from the task. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to retrieve the variables from.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;). If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskVariables: async (id, deserializeValue, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getTaskVariables', 'id', id);
            const localVarPath = `/task/{id}/variables`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (deserializeValue !== undefined) {
                localVarQueryParameter['deserializeValue'] = deserializeValue;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates or deletes the variables visible from the task. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to set variables for.
         * @param {PatchVariablesDto} [patchVariablesDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyTaskVariables: async (id, patchVariablesDto, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('modifyTaskVariables', 'id', id);
            const localVarPath = `/task/{id}/variables`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(patchVariablesDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a process variable that is visible from the Task scope. A variable is visible from the task if it is a local task variable, or declared in a parent scope of the task. See the documentation on [variable scopes and visibility](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables#variable-scopes-and-variable-visibility).  **Note**: If a variable doesn\'t exist, the variable is created in the top-most scope visible from the task.
         * @param {string} id The id of the task to set the variable for.
         * @param {string} varName The name of the variable to set.
         * @param {VariableValueDto} [variableValueDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTaskVariable: async (id, varName, variableValueDto, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('putTaskVariable', 'id', id);
            // verify required parameter 'varName' is not null or undefined
            (0, common_1.assertParamExists)('putTaskVariable', 'varName', varName);
            const localVarPath = `/task/{id}/variables/{varName}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(variableValueDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the serialized value for a binary variable or the binary value for a file variable visible from the task. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {any} [data] The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory.
         * @param {string} [valueType] The name of the variable type. Either Bytes for a byte array variable or File for a file variable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBinaryTaskVariable: async (id, varName, data, valueType, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('setBinaryTaskVariable', 'id', id);
            // verify required parameter 'varName' is not null or undefined
            (0, common_1.assertParamExists)('setBinaryTaskVariable', 'varName', varName);
            const localVarPath = `/task/{id}/variables/{varName}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            if (data !== undefined) {
                localVarFormParams.append('data', data);
            }
            if (valueType !== undefined) {
                localVarFormParams.append('valueType', valueType);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.TaskVariableApiAxiosParamCreator = TaskVariableApiAxiosParamCreator;
/**
 * TaskVariableApi - functional programming interface
 * @export
 */
const TaskVariableApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TaskVariableApiAxiosParamCreator)(configuration);
    return {
        /**
         * Removes a variable that is visible to a task. A variable is visible to a task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to delete the variable from.
         * @param {string} varName The name of the variable to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTaskVariable(id, varName, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTaskVariable(id, varName, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves a variable from the context of a given task. The variable must be visible from the task. It is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to retrieve the variable from.
         * @param {string} varName The name of the variable to get.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskVariable(id, varName, deserializeValue, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskVariable(id, varName, deserializeValue, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves a binary variable from the context of a given task. Applicable for byte array and file variables. The variable must be visible from the task. It is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskVariableBinary(id, varName, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskVariableBinary(id, varName, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves all variables visible from the task. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to retrieve the variables from.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;). If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskVariables(id, deserializeValue, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskVariables(id, deserializeValue, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Updates or deletes the variables visible from the task. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to set variables for.
         * @param {PatchVariablesDto} [patchVariablesDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyTaskVariables(id, patchVariablesDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyTaskVariables(id, patchVariablesDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Updates a process variable that is visible from the Task scope. A variable is visible from the task if it is a local task variable, or declared in a parent scope of the task. See the documentation on [variable scopes and visibility](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables#variable-scopes-and-variable-visibility).  **Note**: If a variable doesn\'t exist, the variable is created in the top-most scope visible from the task.
         * @param {string} id The id of the task to set the variable for.
         * @param {string} varName The name of the variable to set.
         * @param {VariableValueDto} [variableValueDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putTaskVariable(id, varName, variableValueDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putTaskVariable(id, varName, variableValueDto, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Sets the serialized value for a binary variable or the binary value for a file variable visible from the task. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {any} [data] The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory.
         * @param {string} [valueType] The name of the variable type. Either Bytes for a byte array variable or File for a file variable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setBinaryTaskVariable(id, varName, data, valueType, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setBinaryTaskVariable(id, varName, data, valueType, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.TaskVariableApiFp = TaskVariableApiFp;
/**
 * TaskVariableApi - factory interface
 * @export
 */
const TaskVariableApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TaskVariableApiFp)(configuration);
    return {
        /**
         * Removes a variable that is visible to a task. A variable is visible to a task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to delete the variable from.
         * @param {string} varName The name of the variable to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaskVariable(id, varName, options) {
            return localVarFp.deleteTaskVariable(id, varName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a variable from the context of a given task. The variable must be visible from the task. It is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to retrieve the variable from.
         * @param {string} varName The name of the variable to get.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskVariable(id, varName, deserializeValue, options) {
            return localVarFp.getTaskVariable(id, varName, deserializeValue, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a binary variable from the context of a given task. Applicable for byte array and file variables. The variable must be visible from the task. It is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskVariableBinary(id, varName, options) {
            return localVarFp.getTaskVariableBinary(id, varName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all variables visible from the task. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to retrieve the variables from.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;). If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskVariables(id, deserializeValue, options) {
            return localVarFp.getTaskVariables(id, deserializeValue, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates or deletes the variables visible from the task. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to set variables for.
         * @param {PatchVariablesDto} [patchVariablesDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyTaskVariables(id, patchVariablesDto, options) {
            return localVarFp.modifyTaskVariables(id, patchVariablesDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a process variable that is visible from the Task scope. A variable is visible from the task if it is a local task variable, or declared in a parent scope of the task. See the documentation on [variable scopes and visibility](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables#variable-scopes-and-variable-visibility).  **Note**: If a variable doesn\'t exist, the variable is created in the top-most scope visible from the task.
         * @param {string} id The id of the task to set the variable for.
         * @param {string} varName The name of the variable to set.
         * @param {VariableValueDto} [variableValueDto]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTaskVariable(id, varName, variableValueDto, options) {
            return localVarFp.putTaskVariable(id, varName, variableValueDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the serialized value for a binary variable or the binary value for a file variable visible from the task. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {any} [data] The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory.
         * @param {string} [valueType] The name of the variable type. Either Bytes for a byte array variable or File for a file variable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBinaryTaskVariable(id, varName, data, valueType, options) {
            return localVarFp.setBinaryTaskVariable(id, varName, data, valueType, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TaskVariableApiFactory = TaskVariableApiFactory;
/**
 * TaskVariableApi - object-oriented interface
 * @export
 * @class TaskVariableApi
 * @extends {BaseAPI}
 */
class TaskVariableApi extends base_1.BaseAPI {
    /**
     * Removes a variable that is visible to a task. A variable is visible to a task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
     * @param {string} id The id of the task to delete the variable from.
     * @param {string} varName The name of the variable to be removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskVariableApi
     */
    deleteTaskVariable(id, varName, options) {
        return (0, exports.TaskVariableApiFp)(this.configuration).deleteTaskVariable(id, varName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a variable from the context of a given task. The variable must be visible from the task. It is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
     * @param {string} id The id of the task to retrieve the variable from.
     * @param {string} varName The name of the variable to get.
     * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskVariableApi
     */
    getTaskVariable(id, varName, deserializeValue, options) {
        return (0, exports.TaskVariableApiFp)(this.configuration).getTaskVariable(id, varName, deserializeValue, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a binary variable from the context of a given task. Applicable for byte array and file variables. The variable must be visible from the task. It is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
     * @param {string} id The id of the task to retrieve the variable for.
     * @param {string} varName The name of the variable to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskVariableApi
     */
    getTaskVariableBinary(id, varName, options) {
        return (0, exports.TaskVariableApiFp)(this.configuration).getTaskVariableBinary(id, varName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves all variables visible from the task. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
     * @param {string} id The id of the task to retrieve the variables from.
     * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;). If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskVariableApi
     */
    getTaskVariables(id, deserializeValue, options) {
        return (0, exports.TaskVariableApiFp)(this.configuration).getTaskVariables(id, deserializeValue, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates or deletes the variables visible from the task. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
     * @param {string} id The id of the task to set variables for.
     * @param {PatchVariablesDto} [patchVariablesDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskVariableApi
     */
    modifyTaskVariables(id, patchVariablesDto, options) {
        return (0, exports.TaskVariableApiFp)(this.configuration).modifyTaskVariables(id, patchVariablesDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates a process variable that is visible from the Task scope. A variable is visible from the task if it is a local task variable, or declared in a parent scope of the task. See the documentation on [variable scopes and visibility](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables#variable-scopes-and-variable-visibility).  **Note**: If a variable doesn\'t exist, the variable is created in the top-most scope visible from the task.
     * @param {string} id The id of the task to set the variable for.
     * @param {string} varName The name of the variable to set.
     * @param {VariableValueDto} [variableValueDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskVariableApi
     */
    putTaskVariable(id, varName, variableValueDto, options) {
        return (0, exports.TaskVariableApiFp)(this.configuration).putTaskVariable(id, varName, variableValueDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets the serialized value for a binary variable or the binary value for a file variable visible from the task. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
     * @param {string} id The id of the task to retrieve the variable for.
     * @param {string} varName The name of the variable to retrieve.
     * @param {any} [data] The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory.
     * @param {string} [valueType] The name of the variable type. Either Bytes for a byte array variable or File for a file variable.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskVariableApi
     */
    setBinaryTaskVariable(id, varName, data, valueType, options) {
        return (0, exports.TaskVariableApiFp)(this.configuration).setBinaryTaskVariable(id, varName, data, valueType, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TaskVariableApi = TaskVariableApi;
/**
 * VersionApi - axios parameter creator
 * @export
 */
const VersionApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves the version of the Rest API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRestAPIVersion: async (options = {}) => {
            const localVarPath = `/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.VersionApiAxiosParamCreator = VersionApiAxiosParamCreator;
/**
 * VersionApi - functional programming interface
 * @export
 */
const VersionApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.VersionApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieves the version of the Rest API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRestAPIVersion(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRestAPIVersion(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.VersionApiFp = VersionApiFp;
/**
 * VersionApi - factory interface
 * @export
 */
const VersionApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.VersionApiFp)(configuration);
    return {
        /**
         * Retrieves the version of the Rest API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRestAPIVersion(options) {
            return localVarFp.getRestAPIVersion(options).then((request) => request(axios, basePath));
        },
    };
};
exports.VersionApiFactory = VersionApiFactory;
/**
 * VersionApi - object-oriented interface
 * @export
 * @class VersionApi
 * @extends {BaseAPI}
 */
class VersionApi extends base_1.BaseAPI {
    /**
     * Retrieves the version of the Rest API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionApi
     */
    getRestAPIVersion(options) {
        return (0, exports.VersionApiFp)(this.configuration).getRestAPIVersion(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.VersionApi = VersionApi;
