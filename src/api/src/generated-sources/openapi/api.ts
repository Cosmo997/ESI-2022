/* tslint:disable */
/* eslint-disable */
/**
 * Camunda Platform REST API
 * OpenApi Spec for Camunda Platform REST API.
 *
 * The version of the OpenAPI document: 7.13.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * A JSON object corresponding to the Activity Instance tree of the given process instance.
 * @export
 * @interface ActivityInstanceDto
 */
export interface ActivityInstanceDto {
    /**
     * The id of the activity instance.
     * @type {string}
     * @memberof ActivityInstanceDto
     */
    'id'?: string;
    /**
     * The id of the parent activity instance, for example a sub process instance.
     * @type {string}
     * @memberof ActivityInstanceDto
     */
    'parentActivityInstanceId'?: string;
    /**
     * The id of the activity.
     * @type {string}
     * @memberof ActivityInstanceDto
     */
    'activityId'?: string;
    /**
     * The name of the activity
     * @type {string}
     * @memberof ActivityInstanceDto
     */
    'activityName'?: string;
    /**
     * The type of activity (corresponds to the XML element name in the BPMN 2.0, e.g., \'userTask\')
     * @type {string}
     * @memberof ActivityInstanceDto
     */
    'activityType'?: string;
    /**
     * The id of the process instance this activity instance is part of.
     * @type {string}
     * @memberof ActivityInstanceDto
     */
    'processInstanceId'?: string;
    /**
     * The id of the process definition.
     * @type {string}
     * @memberof ActivityInstanceDto
     */
    'processDefinitionId'?: string;
    /**
     * A list of child activity instances.
     * @type {Array<ActivityInstanceDto>}
     * @memberof ActivityInstanceDto
     */
    'childActivityInstances'?: Array<ActivityInstanceDto>;
    /**
     * A list of child transition instances. A transition instance represents an execution waiting in an asynchronous continuation.
     * @type {Array<TransitionInstanceDto>}
     * @memberof ActivityInstanceDto
     */
    'childTransitionInstances'?: Array<TransitionInstanceDto>;
    /**
     * A list of execution ids.
     * @type {Array<string>}
     * @memberof ActivityInstanceDto
     */
    'executionIds'?: Array<string>;
    /**
     * A list of incident ids.
     * @type {Array<string>}
     * @memberof ActivityInstanceDto
     */
    'incidentIds'?: Array<string>;
    /**
     * A list of JSON objects containing incident specific properties: * `id`: the id of the incident * `activityId`: the activity id in which the incident occurred
     * @type {Array<ActivityInstanceIncidentDto>}
     * @memberof ActivityInstanceDto
     */
    'incidents'?: Array<ActivityInstanceIncidentDto>;
}
/**
 * An activity instance, incident pair.
 * @export
 * @interface ActivityInstanceIncidentDto
 */
export interface ActivityInstanceIncidentDto {
    /**
     * The id of the incident.
     * @type {string}
     * @memberof ActivityInstanceIncidentDto
     */
    'id'?: string;
    /**
     * The activity id in which the incident happened.
     * @type {string}
     * @memberof ActivityInstanceIncidentDto
     */
    'parentActivityInstanceId'?: string;
}
/**
 * 
 * @export
 * @interface ActivityStatisticsResultDto
 */
export interface ActivityStatisticsResultDto {
    /**
     * The id of the activity the results are aggregated for.
     * @type {string}
     * @memberof ActivityStatisticsResultDto
     */
    'id'?: string;
    /**
     * The total number of running process instances of this activity.
     * @type {number}
     * @memberof ActivityStatisticsResultDto
     */
    'instances'?: number;
    /**
     * The total number of failed jobs for the running instances. **Note**: Will be `0` (not `null`), if failed jobs were excluded.
     * @type {number}
     * @memberof ActivityStatisticsResultDto
     */
    'failedJobs'?: number;
    /**
     * Each item in the resulting array is an object which contains `incidentType` and `incidentCount`. **Note**: Will be an empty array, if `incidents` or `incidentsForType` were excluded. Furthermore, the array will be also empty if no incidents were found.
     * @type {Array<IncidentStatisticsResultDto>}
     * @memberof ActivityStatisticsResultDto
     */
    'incidents'?: Array<IncidentStatisticsResultDto>;
}
/**
 * 
 * @export
 * @interface AtomLink
 */
export interface AtomLink {
    /**
     * The relation of the link to the object that belogs to.
     * @type {string}
     * @memberof AtomLink
     */
    'rel'?: string;
    /**
     * The url of the link.
     * @type {string}
     * @memberof AtomLink
     */
    'href'?: string;
    /**
     * The http method.
     * @type {string}
     * @memberof AtomLink
     */
    'method'?: string;
}
/**
 * 
 * @export
 * @interface AttachmentDto
 */
export interface AttachmentDto {
    /**
     * The id of the task attachment.
     * @type {string}
     * @memberof AttachmentDto
     */
    'id'?: string;
    /**
     * The name of the task attachment.
     * @type {string}
     * @memberof AttachmentDto
     */
    'name'?: string;
    /**
     * The description of the task attachment.
     * @type {string}
     * @memberof AttachmentDto
     */
    'description'?: string;
    /**
     * The id of the task to which the attachment belongs.
     * @type {string}
     * @memberof AttachmentDto
     */
    'taskId'?: string;
    /**
     * Indication of the type of content that this attachment refers to. Can be MIME type or any other indication.
     * @type {string}
     * @memberof AttachmentDto
     */
    'type'?: string;
    /**
     * The url to the remote content of the task attachment.
     * @type {string}
     * @memberof AttachmentDto
     */
    'url'?: string;
    /**
     * The time the variable was inserted. [Default format](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/) `yyyy-MM-dd\'T\'HH:mm:ss.SSSZ`.
     * @type {string}
     * @memberof AttachmentDto
     */
    'createTime'?: string;
    /**
     * The time after which the attachment should be removed by the History Cleanup job. [Default format](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/) `yyyy-MM-dd\'T\'HH:mm:ss.SSSZ`.
     * @type {string}
     * @memberof AttachmentDto
     */
    'removalTime'?: string | null;
    /**
     * The process instance id of the root process instance that initiated the process containing the task.
     * @type {string}
     * @memberof AttachmentDto
     */
    'rootProcessInstanceId'?: string;
    /**
     * The links associated to this resource, with `method`, `href` and `rel`.
     * @type {Array<AtomLink>}
     * @memberof AttachmentDto
     */
    'links'?: Array<AtomLink>;
}
/**
 * 
 * @export
 * @interface AttachmentDtoAllOf
 */
export interface AttachmentDtoAllOf {
    /**
     * The id of the task attachment.
     * @type {string}
     * @memberof AttachmentDtoAllOf
     */
    'id'?: string;
    /**
     * The name of the task attachment.
     * @type {string}
     * @memberof AttachmentDtoAllOf
     */
    'name'?: string;
    /**
     * The description of the task attachment.
     * @type {string}
     * @memberof AttachmentDtoAllOf
     */
    'description'?: string;
    /**
     * The id of the task to which the attachment belongs.
     * @type {string}
     * @memberof AttachmentDtoAllOf
     */
    'taskId'?: string;
    /**
     * Indication of the type of content that this attachment refers to. Can be MIME type or any other indication.
     * @type {string}
     * @memberof AttachmentDtoAllOf
     */
    'type'?: string;
    /**
     * The url to the remote content of the task attachment.
     * @type {string}
     * @memberof AttachmentDtoAllOf
     */
    'url'?: string;
    /**
     * The time the variable was inserted. [Default format](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/) `yyyy-MM-dd\'T\'HH:mm:ss.SSSZ`.
     * @type {string}
     * @memberof AttachmentDtoAllOf
     */
    'createTime'?: string;
    /**
     * The time after which the attachment should be removed by the History Cleanup job. [Default format](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/) `yyyy-MM-dd\'T\'HH:mm:ss.SSSZ`.
     * @type {string}
     * @memberof AttachmentDtoAllOf
     */
    'removalTime'?: string | null;
    /**
     * The process instance id of the root process instance that initiated the process containing the task.
     * @type {string}
     * @memberof AttachmentDtoAllOf
     */
    'rootProcessInstanceId'?: string;
}
/**
 * 
 * @export
 * @interface AuthorizationExceptionDto
 */
export interface AuthorizationExceptionDto {
    /**
     * The id of the user that does not have expected permissions
     * @type {string}
     * @memberof AuthorizationExceptionDto
     */
    'userId'?: string;
    /**
     * 
     * @type {Array<MissingAuthorizationDto>}
     * @memberof AuthorizationExceptionDto
     */
    'missingAuthorizations'?: Array<MissingAuthorizationDto>;
    /**
     * An exception class indicating the occurred error.
     * @type {string}
     * @memberof AuthorizationExceptionDto
     */
    'type'?: string;
    /**
     * A detailed message of the error.
     * @type {string}
     * @memberof AuthorizationExceptionDto
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface AuthorizationExceptionDtoAllOf
 */
export interface AuthorizationExceptionDtoAllOf {
    /**
     * The id of the user that does not have expected permissions
     * @type {string}
     * @memberof AuthorizationExceptionDtoAllOf
     */
    'userId'?: string;
    /**
     * 
     * @type {Array<MissingAuthorizationDto>}
     * @memberof AuthorizationExceptionDtoAllOf
     */
    'missingAuthorizations'?: Array<MissingAuthorizationDto>;
}
/**
 * 
 * @export
 * @interface BatchDto
 */
export interface BatchDto {
    /**
     * The id of the batch.
     * @type {string}
     * @memberof BatchDto
     */
    'id'?: string;
    /**
     * The type of the batch.
     * @type {string}
     * @memberof BatchDto
     */
    'type'?: string;
    /**
     * The total jobs of a batch is the number of batch execution jobs required to complete the batch.
     * @type {number}
     * @memberof BatchDto
     */
    'totalJobs'?: number;
    /**
     * The number of batch execution jobs already created by the seed job.
     * @type {number}
     * @memberof BatchDto
     */
    'jobsCreated'?: number;
    /**
     * The number of batch execution jobs created per seed job invocation. The batch seed job is invoked until it has created all batch execution jobs required by the batch (see totalJobs property).
     * @type {number}
     * @memberof BatchDto
     */
    'batchJobsPerSeed'?: number;
    /**
     * Every batch execution job invokes the command executed by the batch invocationsPerBatchJob times. E.g., for a process instance migration batch this specifies the number of process instances which are migrated per batch execution job.
     * @type {number}
     * @memberof BatchDto
     */
    'invocationsPerBatchJob'?: number;
    /**
     * The job definition id for the seed jobs of this batch.
     * @type {string}
     * @memberof BatchDto
     */
    'seedJobDefinitionId'?: string;
    /**
     * The job definition id for the monitor jobs of this batch.
     * @type {string}
     * @memberof BatchDto
     */
    'monitorJobDefinitionId'?: string;
    /**
     * The job definition id for the batch execution jobs of this batch.
     * @type {string}
     * @memberof BatchDto
     */
    'batchJobDefinitionId'?: string;
    /**
     * Indicates whether this batch is suspended or not.
     * @type {boolean}
     * @memberof BatchDto
     */
    'suspended'?: boolean;
    /**
     * The tenant id of the batch.
     * @type {string}
     * @memberof BatchDto
     */
    'tenantId'?: string;
    /**
     * The id of the user that created the batch.
     * @type {string}
     * @memberof BatchDto
     */
    'createUserId'?: string;
}
/**
 * 
 * @export
 * @interface CaseDefinitionDto
 */
export interface CaseDefinitionDto {
    /**
     * The id of the case definition
     * @type {string}
     * @memberof CaseDefinitionDto
     */
    'id'?: string;
    /**
     * The key of the case definition, i.e., the id of the CMMN 2.0 XML case definition.
     * @type {string}
     * @memberof CaseDefinitionDto
     */
    'key'?: string;
    /**
     * The category of the case definition.
     * @type {string}
     * @memberof CaseDefinitionDto
     */
    'category'?: string;
    /**
     * The name of the case definition.
     * @type {string}
     * @memberof CaseDefinitionDto
     */
    'name'?: string;
    /**
     * The version of the case definition that the engine assigned to it.
     * @type {number}
     * @memberof CaseDefinitionDto
     */
    'version'?: number;
    /**
     * The file name of the case definition.
     * @type {string}
     * @memberof CaseDefinitionDto
     */
    'resource'?: string;
    /**
     * The deployment id of the case definition.
     * @type {string}
     * @memberof CaseDefinitionDto
     */
    'deploymentId'?: string;
    /**
     * The tenant id of the case definition.
     * @type {string}
     * @memberof CaseDefinitionDto
     */
    'tenantId'?: string;
    /**
     * History time to live value of the case definition. Is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
     * @type {number}
     * @memberof CaseDefinitionDto
     */
    'historyTimeToLive'?: number | null;
}
/**
 * 
 * @export
 * @interface CommentDto
 */
export interface CommentDto {
    /**
     * The id of the task comment.
     * @type {string}
     * @memberof CommentDto
     */
    'id'?: string;
    /**
     * The id of the user who created the comment.
     * @type {string}
     * @memberof CommentDto
     */
    'userId'?: string;
    /**
     * The id of the task to which the comment belongs.
     * @type {string}
     * @memberof CommentDto
     */
    'taskId'?: string;
    /**
     * The time when the comment was created. [Default format]($(docsUrl)/reference/rest/overview/date-format/) `yyyy-MM-dd\'T\'HH:mm:ss.SSSZ`.
     * @type {string}
     * @memberof CommentDto
     */
    'time'?: string;
    /**
     * The content of the comment.
     * @type {string}
     * @memberof CommentDto
     */
    'message'?: string;
    /**
     * The time after which the comment should be removed by the History Cleanup job. [Default format]($(docsUrl)/reference/rest/overview/date-format/) `yyyy-MM-dd\'T\'HH:mm:ss.SSSZ`.
     * @type {string}
     * @memberof CommentDto
     */
    'removalTime'?: string | null;
    /**
     * The process instance id of the root process instance that initiated the process containing the task.
     * @type {string}
     * @memberof CommentDto
     */
    'rootProcessInstanceId'?: string;
    /**
     * The links associated to this resource, with `method`, `href` and `rel`.
     * @type {Array<AtomLink>}
     * @memberof CommentDto
     */
    'links'?: Array<AtomLink>;
}
/**
 * 
 * @export
 * @interface CommentDtoAllOf
 */
export interface CommentDtoAllOf {
    /**
     * The id of the task comment.
     * @type {string}
     * @memberof CommentDtoAllOf
     */
    'id'?: string;
    /**
     * The id of the user who created the comment.
     * @type {string}
     * @memberof CommentDtoAllOf
     */
    'userId'?: string;
    /**
     * The id of the task to which the comment belongs.
     * @type {string}
     * @memberof CommentDtoAllOf
     */
    'taskId'?: string;
    /**
     * The time when the comment was created. [Default format]($(docsUrl)/reference/rest/overview/date-format/) `yyyy-MM-dd\'T\'HH:mm:ss.SSSZ`.
     * @type {string}
     * @memberof CommentDtoAllOf
     */
    'time'?: string;
    /**
     * The content of the comment.
     * @type {string}
     * @memberof CommentDtoAllOf
     */
    'message'?: string;
    /**
     * The time after which the comment should be removed by the History Cleanup job. [Default format]($(docsUrl)/reference/rest/overview/date-format/) `yyyy-MM-dd\'T\'HH:mm:ss.SSSZ`.
     * @type {string}
     * @memberof CommentDtoAllOf
     */
    'removalTime'?: string | null;
    /**
     * The process instance id of the root process instance that initiated the process containing the task.
     * @type {string}
     * @memberof CommentDtoAllOf
     */
    'rootProcessInstanceId'?: string;
}
/**
 * 
 * @export
 * @interface CompleteExternalTaskDto
 */
export interface CompleteExternalTaskDto {
    /**
     * The id of the worker that completes the task. Must match the id of the worker who has most recently locked the task.
     * @type {string}
     * @memberof CompleteExternalTaskDto
     */
    'workerId'?: string;
    /**
     * A JSON object containing variable key-value pairs. Each key is a variable name and each value a JSON variable value object with the following properties:
     * @type {{ [key: string]: VariableValueDto; }}
     * @memberof CompleteExternalTaskDto
     */
    'variables'?: { [key: string]: VariableValueDto; };
    /**
     * A JSON object containing local variable key-value pairs. Local variables are set only in the scope of external task. Each key is a variable name and each value a JSON variable value object with the following properties:
     * @type {{ [key: string]: VariableValueDto; }}
     * @memberof CompleteExternalTaskDto
     */
    'localVariables'?: { [key: string]: VariableValueDto; };
}
/**
 * 
 * @export
 * @interface CompleteTaskDto
 */
export interface CompleteTaskDto {
    /**
     * A JSON object containing variable key-value pairs.
     * @type {{ [key: string]: VariableValueDto; }}
     * @memberof CompleteTaskDto
     */
    'variables'?: { [key: string]: VariableValueDto; };
    /**
     * Indicates whether the response should contain the process variables or not. The default is `false` with a response code of `204`. If set to `true` the response contains the process variables and has a response code of `200`. If the task is not associated with a process instance (e.g. if it\'s part of a case instance) no variables will be returned.
     * @type {boolean}
     * @memberof CompleteTaskDto
     */
    'withVariablesInReturn'?: boolean | null;
}
/**
 * 
 * @export
 * @interface CorrelationMessageDto
 */
export interface CorrelationMessageDto {
    /**
     * The name of the message to deliver.
     * @type {string}
     * @memberof CorrelationMessageDto
     */
    'messageName'?: string;
    /**
     * Used for correlation of process instances that wait for incoming messages. Will only correlate to executions that belong to a process instance with the provided business key.
     * @type {string}
     * @memberof CorrelationMessageDto
     */
    'businessKey'?: string;
    /**
     * Used to correlate the message for a tenant with the given id. Will only correlate to executions and process definitions which belong to the tenant. Must not be supplied in conjunction with a `withoutTenantId`.
     * @type {string}
     * @memberof CorrelationMessageDto
     */
    'tenantId'?: string;
    /**
     * A Boolean value that indicates whether the message should only be correlated to executions and process definitions which belong to no tenant or not. Value may only be `true`, as `false` is the default behavior. Must not be supplied in conjunction with a `tenantId`.
     * @type {boolean}
     * @memberof CorrelationMessageDto
     */
    'withoutTenantId'?: boolean | null;
    /**
     * Used to correlate the message to the process instance with the given id.
     * @type {string}
     * @memberof CorrelationMessageDto
     */
    'processInstanceId'?: string;
    /**
     * Used for correlation of process instances that wait for incoming messages. Has to be a JSON object containing key-value pairs that are matched against process instance variables during correlation. Each key is a variable name and each value a JSON variable value object with the following properties.
     * @type {{ [key: string]: VariableValueDto; }}
     * @memberof CorrelationMessageDto
     */
    'correlationKeys'?: { [key: string]: VariableValueDto; };
    /**
     * Local variables used for correlation of executions (process instances) that wait for incoming messages. Has to be a JSON object containing key-value pairs that are matched against local variables during correlation. Each key is a variable name and each value a JSON variable value object with the following properties.
     * @type {{ [key: string]: VariableValueDto; }}
     * @memberof CorrelationMessageDto
     */
    'localCorrelationKeys'?: { [key: string]: VariableValueDto; };
    /**
     * A map of variables that is injected into the triggered execution or process instance after the message has been delivered. Each key is a variable name and each value a JSON variable value object with the following properties.
     * @type {{ [key: string]: VariableValueDto; }}
     * @memberof CorrelationMessageDto
     */
    'processVariables'?: { [key: string]: VariableValueDto; };
    /**
     * A map of local variables that is injected into the triggered execution or process instance after the message has been delivered. Each key is a variable name and each value a JSON variable value object with the following properties.
     * @type {{ [key: string]: VariableValueDto; }}
     * @memberof CorrelationMessageDto
     */
    'processVariablesLocal'?: { [key: string]: VariableValueDto; };
    /**
     * A Boolean value that indicates whether the message should be correlated to exactly one entity or multiple entities. If the value is set to `false`, the message will be correlated to exactly one entity (execution or process definition). If the value is set to `true`, the message will be correlated to multiple executions and a process definition that can be instantiated by this message in one go.
     * @type {boolean}
     * @memberof CorrelationMessageDto
     */
    'all'?: boolean | null;
    /**
     * A Boolean value that indicates whether the result of the correlation should be returned or not. If this property is set to `true`, there will be returned a list of message correlation result objects. Depending on the all property, there will be either one ore more returned results in the list.  The default value is `false`, which means no result will be returned.
     * @type {boolean}
     * @memberof CorrelationMessageDto
     */
    'resultEnabled'?: boolean | null;
    /**
     * A Boolean value that indicates whether the result of the correlation should contain process variables or not. The parameter resultEnabled should be set to `true` in order to use this it.  The default value is `false`, which means the variables will not be returned.
     * @type {boolean}
     * @memberof CorrelationMessageDto
     */
    'variablesInResultEnabled'?: boolean | null;
}
/**
 * 
 * @export
 * @interface CountResultDto
 */
export interface CountResultDto {
    /**
     * The number of matching instances.
     * @type {number}
     * @memberof CountResultDto
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface DecisionDefinitionDto
 */
export interface DecisionDefinitionDto {
    /**
     * The id of the decision definition
     * @type {string}
     * @memberof DecisionDefinitionDto
     */
    'id'?: string;
    /**
     * The key of the decision definition, i.e., the id of the DMN 1.0 XML decision definition.
     * @type {string}
     * @memberof DecisionDefinitionDto
     */
    'key'?: string;
    /**
     * The category of the decision definition.
     * @type {string}
     * @memberof DecisionDefinitionDto
     */
    'category'?: string;
    /**
     * The name of the decision definition.
     * @type {string}
     * @memberof DecisionDefinitionDto
     */
    'name'?: string;
    /**
     * The version of the decision definition that the engine assigned to it.
     * @type {number}
     * @memberof DecisionDefinitionDto
     */
    'version'?: number;
    /**
     * The file name of the decision definition.
     * @type {string}
     * @memberof DecisionDefinitionDto
     */
    'resource'?: string;
    /**
     * The deployment id of the decision definition.
     * @type {string}
     * @memberof DecisionDefinitionDto
     */
    'deploymentId'?: string;
    /**
     * The tenant id of the decision definition.
     * @type {string}
     * @memberof DecisionDefinitionDto
     */
    'tenantId'?: string;
    /**
     * The id of the decision requirements definition this decision definition belongs to.
     * @type {string}
     * @memberof DecisionDefinitionDto
     */
    'decisionRequirementsDefinitionId'?: string;
    /**
     * The key of the decision requirements definition this decision definition belongs to.
     * @type {string}
     * @memberof DecisionDefinitionDto
     */
    'decisionRequirementsDefinitionKey'?: string;
    /**
     * History time to live value of the decision definition. Is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
     * @type {number}
     * @memberof DecisionDefinitionDto
     */
    'historyTimeToLive'?: number | null;
    /**
     * The version tag of the decision definition.
     * @type {string}
     * @memberof DecisionDefinitionDto
     */
    'versionTag'?: string;
}
/**
 * 
 * @export
 * @interface DecisionRequirementsDefinitionDto
 */
export interface DecisionRequirementsDefinitionDto {
    /**
     * The id of the decision requirements definition
     * @type {string}
     * @memberof DecisionRequirementsDefinitionDto
     */
    'id'?: string;
    /**
     * The key of the decision requirements definition, i.e., the id of the DMN 1.0 XML decision definition.
     * @type {string}
     * @memberof DecisionRequirementsDefinitionDto
     */
    'key'?: string;
    /**
     * The name of the decision requirements definition.
     * @type {string}
     * @memberof DecisionRequirementsDefinitionDto
     */
    'name'?: string;
    /**
     * The category of the decision requirements definition.
     * @type {string}
     * @memberof DecisionRequirementsDefinitionDto
     */
    'category'?: string;
    /**
     * The version of the decision requirements definition that the engine assigned to it.
     * @type {number}
     * @memberof DecisionRequirementsDefinitionDto
     */
    'version'?: number;
    /**
     * The file name of the decision requirements definition.
     * @type {string}
     * @memberof DecisionRequirementsDefinitionDto
     */
    'resource'?: string;
    /**
     * The deployment id of the decision requirements definition.
     * @type {string}
     * @memberof DecisionRequirementsDefinitionDto
     */
    'deploymentId'?: string;
    /**
     * The tenant id of the decisionrequirements definition.
     * @type {string}
     * @memberof DecisionRequirementsDefinitionDto
     */
    'tenantId'?: string;
}
/**
 * 
 * @export
 * @interface DeleteProcessInstancesDto
 */
export interface DeleteProcessInstancesDto {
    /**
     * A list process instance ids to delete.
     * @type {Array<string>}
     * @memberof DeleteProcessInstancesDto
     */
    'processInstanceIds'?: Array<string>;
    /**
     * A string with delete reason.
     * @type {string}
     * @memberof DeleteProcessInstancesDto
     */
    'deleteReason'?: string;
    /**
     * Skip execution listener invocation for activities that are started or ended as part of this request.
     * @type {boolean}
     * @memberof DeleteProcessInstancesDto
     */
    'skipCustomListeners'?: boolean | null;
    /**
     * Skip deletion of the subprocesses related to deleted processes as part of this request.
     * @type {boolean}
     * @memberof DeleteProcessInstancesDto
     */
    'skipSubprocesses'?: boolean | null;
    /**
     * 
     * @type {ProcessInstanceQueryDto}
     * @memberof DeleteProcessInstancesDto
     */
    'processInstanceQuery'?: ProcessInstanceQueryDto;
    /**
     * 
     * @type {HistoricProcessInstanceQueryDto}
     * @memberof DeleteProcessInstancesDto
     */
    'historicProcessInstanceQuery'?: HistoricProcessInstanceQueryDto;
}
/**
 * 
 * @export
 * @interface DeploymentDto
 */
export interface DeploymentDto {
    /**
     * The id of the deployment.
     * @type {string}
     * @memberof DeploymentDto
     */
    'id'?: string;
    /**
     * The tenant id of the deployment.
     * @type {string}
     * @memberof DeploymentDto
     */
    'tenantId'?: string;
    /**
     * The time when the deployment was created.
     * @type {string}
     * @memberof DeploymentDto
     */
    'deploymentTime'?: string;
    /**
     * The source of the deployment.
     * @type {string}
     * @memberof DeploymentDto
     */
    'source'?: string;
    /**
     * The name of the deployment.
     * @type {string}
     * @memberof DeploymentDto
     */
    'name'?: string;
    /**
     * The links associated to this resource, with `method`, `href` and `rel`.
     * @type {Array<AtomLink>}
     * @memberof DeploymentDto
     */
    'links'?: Array<AtomLink>;
}
/**
 * 
 * @export
 * @interface DeploymentDtoAllOf
 */
export interface DeploymentDtoAllOf {
    /**
     * The id of the deployment.
     * @type {string}
     * @memberof DeploymentDtoAllOf
     */
    'id'?: string;
    /**
     * The tenant id of the deployment.
     * @type {string}
     * @memberof DeploymentDtoAllOf
     */
    'tenantId'?: string;
    /**
     * The time when the deployment was created.
     * @type {string}
     * @memberof DeploymentDtoAllOf
     */
    'deploymentTime'?: string;
    /**
     * The source of the deployment.
     * @type {string}
     * @memberof DeploymentDtoAllOf
     */
    'source'?: string;
    /**
     * The name of the deployment.
     * @type {string}
     * @memberof DeploymentDtoAllOf
     */
    'name'?: string;
}
/**
 * A JSON object corresponding to the `Resource` interface in the engine. Its properties are as follows:
 * @export
 * @interface DeploymentResourceDto
 */
export interface DeploymentResourceDto {
    /**
     * The id of the deployment resource.
     * @type {string}
     * @memberof DeploymentResourceDto
     */
    'id'?: string;
    /**
     * The name of the deployment resource
     * @type {string}
     * @memberof DeploymentResourceDto
     */
    'name'?: string;
    /**
     * The id of the deployment.
     * @type {string}
     * @memberof DeploymentResourceDto
     */
    'deploymentId'?: string;
}
/**
 * 
 * @export
 * @interface DeploymentWithDefinitionsDto
 */
export interface DeploymentWithDefinitionsDto {
    /**
     * A JSON Object containing a property for each of the process definitions, which are successfully deployed with that deployment. The key is the process definition id, the value is a JSON Object corresponding to the process definition.
     * @type {{ [key: string]: ProcessDefinitionDto; }}
     * @memberof DeploymentWithDefinitionsDto
     */
    'deployedProcessDefinitions'?: { [key: string]: ProcessDefinitionDto; };
    /**
     * A JSON Object containing a property for each of the decision definitions, which are successfully deployed with that deployment. The key is the decision definition id, the value is a JSON Object corresponding to the decision definition.
     * @type {{ [key: string]: DecisionDefinitionDto; }}
     * @memberof DeploymentWithDefinitionsDto
     */
    'deployedDecisionDefinitions'?: { [key: string]: DecisionDefinitionDto; };
    /**
     * A JSON Object containing a property for each of the decision requirements definitions, which are successfully deployed with that deployment. The key is the decision requirements definition id, the value is a JSON Object corresponding to the decision requirements definition.
     * @type {{ [key: string]: DecisionRequirementsDefinitionDto; }}
     * @memberof DeploymentWithDefinitionsDto
     */
    'deployedDecisionRequirementsDefinitions'?: { [key: string]: DecisionRequirementsDefinitionDto; };
    /**
     * A JSON Object containing a property for each of the case definitions, which are successfully deployed with that deployment. The key is the case definition id, the value is a JSON Object corresponding to the case definition.
     * @type {{ [key: string]: CaseDefinitionDto; }}
     * @memberof DeploymentWithDefinitionsDto
     */
    'deployedCaseDefinitions'?: { [key: string]: CaseDefinitionDto; };
    /**
     * The id of the deployment.
     * @type {string}
     * @memberof DeploymentWithDefinitionsDto
     */
    'id'?: string;
    /**
     * The tenant id of the deployment.
     * @type {string}
     * @memberof DeploymentWithDefinitionsDto
     */
    'tenantId'?: string;
    /**
     * The time when the deployment was created.
     * @type {string}
     * @memberof DeploymentWithDefinitionsDto
     */
    'deploymentTime'?: string;
    /**
     * The source of the deployment.
     * @type {string}
     * @memberof DeploymentWithDefinitionsDto
     */
    'source'?: string;
    /**
     * The name of the deployment.
     * @type {string}
     * @memberof DeploymentWithDefinitionsDto
     */
    'name'?: string;
    /**
     * The links associated to this resource, with `method`, `href` and `rel`.
     * @type {Array<AtomLink>}
     * @memberof DeploymentWithDefinitionsDto
     */
    'links'?: Array<AtomLink>;
}
/**
 * 
 * @export
 * @interface DeploymentWithDefinitionsDtoAllOf
 */
export interface DeploymentWithDefinitionsDtoAllOf {
    /**
     * A JSON Object containing a property for each of the process definitions, which are successfully deployed with that deployment. The key is the process definition id, the value is a JSON Object corresponding to the process definition.
     * @type {{ [key: string]: ProcessDefinitionDto; }}
     * @memberof DeploymentWithDefinitionsDtoAllOf
     */
    'deployedProcessDefinitions'?: { [key: string]: ProcessDefinitionDto; };
    /**
     * A JSON Object containing a property for each of the decision definitions, which are successfully deployed with that deployment. The key is the decision definition id, the value is a JSON Object corresponding to the decision definition.
     * @type {{ [key: string]: DecisionDefinitionDto; }}
     * @memberof DeploymentWithDefinitionsDtoAllOf
     */
    'deployedDecisionDefinitions'?: { [key: string]: DecisionDefinitionDto; };
    /**
     * A JSON Object containing a property for each of the decision requirements definitions, which are successfully deployed with that deployment. The key is the decision requirements definition id, the value is a JSON Object corresponding to the decision requirements definition.
     * @type {{ [key: string]: DecisionRequirementsDefinitionDto; }}
     * @memberof DeploymentWithDefinitionsDtoAllOf
     */
    'deployedDecisionRequirementsDefinitions'?: { [key: string]: DecisionRequirementsDefinitionDto; };
    /**
     * A JSON Object containing a property for each of the case definitions, which are successfully deployed with that deployment. The key is the case definition id, the value is a JSON Object corresponding to the case definition.
     * @type {{ [key: string]: CaseDefinitionDto; }}
     * @memberof DeploymentWithDefinitionsDtoAllOf
     */
    'deployedCaseDefinitions'?: { [key: string]: CaseDefinitionDto; };
}
/**
 * 
 * @export
 * @interface EvaluationConditionDto
 */
export interface EvaluationConditionDto {
    /**
     * A map of variables which are used for evaluation of the conditions and are injected into the process instances which have been triggered. Each key is a variable name and each value a JSON variable value object with the following properties.
     * @type {{ [key: string]: VariableValueDto; }}
     * @memberof EvaluationConditionDto
     */
    'variables'?: { [key: string]: VariableValueDto; };
    /**
     * Used for the process instances that have been triggered after the evaluation.
     * @type {string}
     * @memberof EvaluationConditionDto
     */
    'businessKey'?: string;
    /**
     * Used to evaluate a condition for a tenant with the given id. Will only evaluate conditions of process definitions which belong to the tenant.
     * @type {string}
     * @memberof EvaluationConditionDto
     */
    'tenantId'?: string;
    /**
     * A Boolean value that indicates whether the conditions should only be evaluated of process definitions which belong to no tenant or not. Value may only be true, as false is the default behavior.
     * @type {boolean}
     * @memberof EvaluationConditionDto
     */
    'withoutTenantId'?: boolean | null;
    /**
     * Used to evaluate conditions of the process definition with the given id.
     * @type {string}
     * @memberof EvaluationConditionDto
     */
    'processDefinitionId'?: string;
}
/**
 * 
 * @export
 * @interface EventSubscriptionDto
 */
export interface EventSubscriptionDto {
    /**
     * The id of the event subscription.
     * @type {string}
     * @memberof EventSubscriptionDto
     */
    'id'?: string;
    /**
     * The type of the event subscription.
     * @type {string}
     * @memberof EventSubscriptionDto
     */
    'eventType'?: string;
    /**
     * The name of the event this subscription belongs to as defined in the process model.
     * @type {string}
     * @memberof EventSubscriptionDto
     */
    'eventName'?: string;
    /**
     * The execution that is subscribed on the referenced event.
     * @type {string}
     * @memberof EventSubscriptionDto
     */
    'executionId'?: string;
    /**
     * The process instance this subscription belongs to.
     * @type {string}
     * @memberof EventSubscriptionDto
     */
    'processInstanceId'?: string;
    /**
     * The identifier of the activity that this event subscription belongs to. This could for example be the id of a receive task.
     * @type {string}
     * @memberof EventSubscriptionDto
     */
    'activityId'?: string;
    /**
     * The time this event subscription was created.
     * @type {string}
     * @memberof EventSubscriptionDto
     */
    'createdDate'?: string | null;
    /**
     * The id of the tenant this event subscription belongs to. Can be `null` if the subscription belongs to no single tenant.
     * @type {string}
     * @memberof EventSubscriptionDto
     */
    'tenantId'?: string;
}
/**
 * A event subscription query which retrieves a list of event subscriptions
 * @export
 * @interface EventSubscriptionQueryDto
 */
export interface EventSubscriptionQueryDto {
    /**
     * The id of the event subscription.
     * @type {string}
     * @memberof EventSubscriptionQueryDto
     */
    'eventSubscriptionId'?: string;
    /**
     * The name of the event this subscription belongs to as defined in the process model.
     * @type {string}
     * @memberof EventSubscriptionQueryDto
     */
    'eventName'?: string;
    /**
     * The type of the event subscription.
     * @type {string}
     * @memberof EventSubscriptionQueryDto
     */
    'eventType'?: EventSubscriptionQueryDtoEventTypeEnum;
    /**
     * The execution that is subscribed on the referenced event.
     * @type {string}
     * @memberof EventSubscriptionQueryDto
     */
    'executionId'?: string;
    /**
     * The process instance this subscription belongs to.
     * @type {string}
     * @memberof EventSubscriptionQueryDto
     */
    'processInstanceId'?: string;
    /**
     * The identifier of the activity that this event subscription belongs to. This could for example be the id of a receive task.
     * @type {string}
     * @memberof EventSubscriptionQueryDto
     */
    'activityId'?: string;
    /**
     * Filter by a comma-separated list of tenant ids. Only select subscriptions that belong to one of the given tenant ids.
     * @type {Array<string>}
     * @memberof EventSubscriptionQueryDto
     */
    'tenantIdIn'?: Array<string>;
    /**
     * Only select subscriptions which have no tenant id. Value may only be `true`, as `false` is the default behavior.
     * @type {boolean}
     * @memberof EventSubscriptionQueryDto
     */
    'withoutTenantId'?: boolean | null;
    /**
     * Select event subscriptions which have no tenant id. Can be used in combination with tenantIdIn parameter. Value may only be `true`, as `false` is the default behavior.
     * @type {boolean}
     * @memberof EventSubscriptionQueryDto
     */
    'includeEventSubscriptionsWithoutTenantId'?: boolean | null;
    /**
     * Apply sorting of the result
     * @type {Array<EventSubscriptionQueryDtoSorting>}
     * @memberof EventSubscriptionQueryDto
     */
    'sorting'?: Array<EventSubscriptionQueryDtoSorting>;
}

export const EventSubscriptionQueryDtoEventTypeEnum = {
    Message: 'message',
    Signal: 'signal',
    Compensate: 'compensate',
    Conditional: 'conditional'
} as const;

export type EventSubscriptionQueryDtoEventTypeEnum = typeof EventSubscriptionQueryDtoEventTypeEnum[keyof typeof EventSubscriptionQueryDtoEventTypeEnum];

/**
 * 
 * @export
 * @interface EventSubscriptionQueryDtoSorting
 */
export interface EventSubscriptionQueryDtoSorting {
    /**
     * Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @type {string}
     * @memberof EventSubscriptionQueryDtoSorting
     */
    'sortBy'?: EventSubscriptionQueryDtoSortingSortByEnum;
    /**
     * Sort the results in a given order. Values may be `asc` for ascending order or `desc` for descending order. Must be used in conjunction with the sortBy parameter.
     * @type {string}
     * @memberof EventSubscriptionQueryDtoSorting
     */
    'sortOrder'?: EventSubscriptionQueryDtoSortingSortOrderEnum;
}

export const EventSubscriptionQueryDtoSortingSortByEnum = {
    Created: 'created',
    TenantId: 'tenantId'
} as const;

export type EventSubscriptionQueryDtoSortingSortByEnum = typeof EventSubscriptionQueryDtoSortingSortByEnum[keyof typeof EventSubscriptionQueryDtoSortingSortByEnum];
export const EventSubscriptionQueryDtoSortingSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type EventSubscriptionQueryDtoSortingSortOrderEnum = typeof EventSubscriptionQueryDtoSortingSortOrderEnum[keyof typeof EventSubscriptionQueryDtoSortingSortOrderEnum];

/**
 * 
 * @export
 * @interface ExceptionDto
 */
export interface ExceptionDto {
    /**
     * An exception class indicating the occurred error.
     * @type {string}
     * @memberof ExceptionDto
     */
    'type'?: string;
    /**
     * A detailed message of the error.
     * @type {string}
     * @memberof ExceptionDto
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ExecutionDto
 */
export interface ExecutionDto {
    /**
     * The id of the Execution.
     * @type {string}
     * @memberof ExecutionDto
     */
    'id'?: string;
    /**
     * The id of the root of the execution tree representing the process instance.
     * @type {string}
     * @memberof ExecutionDto
     */
    'processInstanceId'?: string;
    /**
     * Indicates if the execution is ended.
     * @type {boolean}
     * @memberof ExecutionDto
     */
    'ended'?: boolean;
    /**
     * The id of the tenant this execution belongs to. Can be `null` if the execution belongs to no single tenant.
     * @type {string}
     * @memberof ExecutionDto
     */
    'tenantId'?: string;
}
/**
 * 
 * @export
 * @interface ExtendLockOnExternalTaskDto
 */
export interface ExtendLockOnExternalTaskDto {
    /**
     * The ID of a worker who is locking the external task.
     * @type {string}
     * @memberof ExtendLockOnExternalTaskDto
     */
    'workerId'?: string;
    /**
     * An amount of time (in milliseconds). This is the new lock duration starting from the current moment.
     * @type {number}
     * @memberof ExtendLockOnExternalTaskDto
     */
    'newDuration'?: number;
}
/**
 * 
 * @export
 * @interface ExternalTaskBpmnError
 */
export interface ExternalTaskBpmnError {
    /**
     * The id of the worker that reports the failure. Must match the id of the worker who has most recently locked the task.
     * @type {string}
     * @memberof ExternalTaskBpmnError
     */
    'workerId'?: string;
    /**
     * An error code that indicates the predefined error. It is used to identify the BPMN error handler.
     * @type {string}
     * @memberof ExternalTaskBpmnError
     */
    'errorCode'?: string;
    /**
     * An error message that describes the error.
     * @type {string}
     * @memberof ExternalTaskBpmnError
     */
    'errorMessage'?: string;
    /**
     * A JSON object containing variable key-value pairs.
     * @type {{ [key: string]: VariableValueDto; }}
     * @memberof ExternalTaskBpmnError
     */
    'variables'?: { [key: string]: VariableValueDto; };
}
/**
 * 
 * @export
 * @interface ExternalTaskBpmnErrorAllOf
 */
export interface ExternalTaskBpmnErrorAllOf {
    /**
     * The id of the worker that reports the failure. Must match the id of the worker who has most recently locked the task.
     * @type {string}
     * @memberof ExternalTaskBpmnErrorAllOf
     */
    'workerId'?: string;
}
/**
 * An External Task object with the following properties
 * @export
 * @interface ExternalTaskDto
 */
export interface ExternalTaskDto {
    /**
     * The id of the activity that this external task belongs to.
     * @type {string}
     * @memberof ExternalTaskDto
     */
    'activityId'?: string;
    /**
     * The id of the activity instance that the external task belongs to.
     * @type {string}
     * @memberof ExternalTaskDto
     */
    'activityInstanceId'?: string;
    /**
     * The full error message submitted with the latest reported failure executing this task; `null` if no failure was reported previously or if no error message was submitted
     * @type {string}
     * @memberof ExternalTaskDto
     */
    'errorMessage'?: string;
    /**
     * The id of the execution that the external task belongs to.
     * @type {string}
     * @memberof ExternalTaskDto
     */
    'executionId'?: string;
    /**
     * The id of the external task.
     * @type {string}
     * @memberof ExternalTaskDto
     */
    'id'?: string;
    /**
     * The date that the task\'s most recent lock expires or has expired.
     * @type {string}
     * @memberof ExternalTaskDto
     */
    'lockExpirationTime'?: string | null;
    /**
     * The id of the process definition the external task is defined in.
     * @type {string}
     * @memberof ExternalTaskDto
     */
    'processDefinitionId'?: string;
    /**
     * The key of the process definition the external task is defined in.
     * @type {string}
     * @memberof ExternalTaskDto
     */
    'processDefinitionKey'?: string;
    /**
     * The version tag of the process definition the external task is defined in.
     * @type {string}
     * @memberof ExternalTaskDto
     */
    'processDefinitionVersionTag'?: string;
    /**
     * The id of the process instance the external task belongs to.
     * @type {string}
     * @memberof ExternalTaskDto
     */
    'processInstanceId'?: string;
    /**
     * The id of the tenant the external task belongs to.
     * @type {string}
     * @memberof ExternalTaskDto
     */
    'tenantId'?: string;
    /**
     * The number of retries the task currently has left.
     * @type {number}
     * @memberof ExternalTaskDto
     */
    'retries'?: number | null;
    /**
     * A flag indicating whether the external task is suspended or not.
     * @type {boolean}
     * @memberof ExternalTaskDto
     */
    'suspended'?: boolean | null;
    /**
     * The id of the worker that posesses or posessed the most recent lock.
     * @type {string}
     * @memberof ExternalTaskDto
     */
    'workerId'?: string;
    /**
     * The topic name of the external task.
     * @type {string}
     * @memberof ExternalTaskDto
     */
    'topicName'?: string;
    /**
     * The priority of the external task.
     * @type {number}
     * @memberof ExternalTaskDto
     */
    'priority'?: number | null;
    /**
     * The business key of the process instance the external task belongs to.
     * @type {string}
     * @memberof ExternalTaskDto
     */
    'businessKey'?: string;
}
/**
 * 
 * @export
 * @interface ExternalTaskFailureDto
 */
export interface ExternalTaskFailureDto {
    /**
     * The id of the worker that reports the failure. Must match the id of the worker who has most recently locked the task.
     * @type {string}
     * @memberof ExternalTaskFailureDto
     */
    'workerId'?: string;
    /**
     * An message indicating the reason of the failure.
     * @type {string}
     * @memberof ExternalTaskFailureDto
     */
    'errorMessage'?: string;
    /**
     * A detailed error description.
     * @type {string}
     * @memberof ExternalTaskFailureDto
     */
    'errorDetails'?: string;
    /**
     * A number of how often the task should be retried. Must be >= 0. If this is 0, an incident is created and the task cannot be fetched anymore unless the retries are increased again. The incident\'s message is set to the `errorMessage` parameter.
     * @type {number}
     * @memberof ExternalTaskFailureDto
     */
    'retries'?: number;
    /**
     * A timeout in milliseconds before the external task becomes available again for fetching. Must be >= 0.
     * @type {number}
     * @memberof ExternalTaskFailureDto
     */
    'retryTimeout'?: number;
}
/**
 * A JSON object with the following properties:
 * @export
 * @interface ExternalTaskQueryDto
 */
export interface ExternalTaskQueryDto {
    /**
     * Filter by an external task\'s id.
     * @type {string}
     * @memberof ExternalTaskQueryDto
     */
    'externalTaskId'?: string;
    /**
     * Filter by the comma-separated list of external task ids.
     * @type {Array<string>}
     * @memberof ExternalTaskQueryDto
     */
    'externalTaskIdIn'?: Array<string>;
    /**
     * Filter by an external task topic.
     * @type {string}
     * @memberof ExternalTaskQueryDto
     */
    'topicName'?: string;
    /**
     * Filter by the id of the worker that the task was most recently locked by.
     * @type {string}
     * @memberof ExternalTaskQueryDto
     */
    'workerId'?: string;
    /**
     * Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be `true`, as `false` matches any external task.
     * @type {boolean}
     * @memberof ExternalTaskQueryDto
     */
    'locked'?: boolean | null;
    /**
     * Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be `true`, as `false` matches any external task.
     * @type {boolean}
     * @memberof ExternalTaskQueryDto
     */
    'notLocked'?: boolean | null;
    /**
     * Only include external tasks that have a positive (&gt; 0) number of retries (or `null`). Value may only be `true`, as `false` matches any external task.
     * @type {boolean}
     * @memberof ExternalTaskQueryDto
     */
    'withRetriesLeft'?: boolean | null;
    /**
     * Only include external tasks that have 0 retries. Value may only be `true`, as `false` matches any external task.
     * @type {boolean}
     * @memberof ExternalTaskQueryDto
     */
    'noRetriesLeft'?: boolean | null;
    /**
     * Restrict to external tasks that have a lock that expires after a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format `yyyy-MM-dd\'T\'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.000+0200`.
     * @type {string}
     * @memberof ExternalTaskQueryDto
     */
    'lockExpirationAfter'?: string | null;
    /**
     * Restrict to external tasks that have a lock that expires before a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format `yyyy-MM-dd\'T\'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.000+0200`.
     * @type {string}
     * @memberof ExternalTaskQueryDto
     */
    'lockExpirationBefore'?: string | null;
    /**
     * Filter by the id of the activity that an external task is created for.
     * @type {string}
     * @memberof ExternalTaskQueryDto
     */
    'activityId'?: string;
    /**
     * Filter by the comma-separated list of ids of the activities that an external task is created for.
     * @type {Array<string>}
     * @memberof ExternalTaskQueryDto
     */
    'activityIdIn'?: Array<string>;
    /**
     * Filter by the id of the execution that an external task belongs to.
     * @type {string}
     * @memberof ExternalTaskQueryDto
     */
    'executionId'?: string;
    /**
     * Filter by the id of the process instance that an external task belongs to.
     * @type {string}
     * @memberof ExternalTaskQueryDto
     */
    'processInstanceId'?: string;
    /**
     * Filter by a comma-separated list of process instance ids that an external task may belong to.
     * @type {Array<string>}
     * @memberof ExternalTaskQueryDto
     */
    'processInstanceIdIn'?: Array<string>;
    /**
     * Filter by the id of the process definition that an external task belongs to.
     * @type {string}
     * @memberof ExternalTaskQueryDto
     */
    'processDefinitionId'?: string;
    /**
     * Filter by a comma-separated list of tenant ids. An external task must have one of the given tenant ids.
     * @type {Array<string>}
     * @memberof ExternalTaskQueryDto
     */
    'tenantIdIn'?: Array<string>;
    /**
     * Only include active tasks. Value may only be `true`, as `false` matches any external task.
     * @type {boolean}
     * @memberof ExternalTaskQueryDto
     */
    'active'?: boolean | null;
    /**
     * Only include suspended tasks. Value may only be `true`, as `false` matches any external task.
     * @type {boolean}
     * @memberof ExternalTaskQueryDto
     */
    'suspended'?: boolean | null;
    /**
     * Only include jobs with a priority higher than or equal to the given value. Value must be a valid `long` value.
     * @type {number}
     * @memberof ExternalTaskQueryDto
     */
    'priorityHigherThanOrEquals'?: number | null;
    /**
     * Only include jobs with a priority lower than or equal to the given value. Value must be a valid `long` value.
     * @type {number}
     * @memberof ExternalTaskQueryDto
     */
    'priorityLowerThanOrEquals'?: number | null;
    /**
     * A JSON array of criteria to sort the result by. Each element of the array is a JSON object that                     specifies one ordering. The position in the array identifies the rank of an ordering, i.e., whether                     it is primary, secondary, etc. The ordering objects have the following properties:                      **Note:** The `sorting` properties will not be applied to the External Task count query.
     * @type {Array<ExternalTaskQueryDtoSorting>}
     * @memberof ExternalTaskQueryDto
     */
    'sorting'?: Array<ExternalTaskQueryDtoSorting>;
}
/**
 * 
 * @export
 * @interface ExternalTaskQueryDtoSorting
 */
export interface ExternalTaskQueryDtoSorting {
    /**
     * Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @type {string}
     * @memberof ExternalTaskQueryDtoSorting
     */
    'sortBy'?: ExternalTaskQueryDtoSortingSortByEnum;
    /**
     * Sort the results in a given order. Values may be `asc` for ascending order or `desc` for descending order. Must be used in conjunction with the sortBy parameter.
     * @type {string}
     * @memberof ExternalTaskQueryDtoSorting
     */
    'sortOrder'?: ExternalTaskQueryDtoSortingSortOrderEnum;
}

export const ExternalTaskQueryDtoSortingSortByEnum = {
    Id: 'id',
    LockExpirationTime: 'lockExpirationTime',
    ProcessInstanceId: 'processInstanceId',
    ProcessDefinitionId: 'processDefinitionId',
    ProcessDefinitionKey: 'processDefinitionKey',
    TaskPriority: 'taskPriority',
    TenantId: 'tenantId'
} as const;

export type ExternalTaskQueryDtoSortingSortByEnum = typeof ExternalTaskQueryDtoSortingSortByEnum[keyof typeof ExternalTaskQueryDtoSortingSortByEnum];
export const ExternalTaskQueryDtoSortingSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type ExternalTaskQueryDtoSortingSortOrderEnum = typeof ExternalTaskQueryDtoSortingSortOrderEnum[keyof typeof ExternalTaskQueryDtoSortingSortOrderEnum];

/**
 * 
 * @export
 * @interface FetchExternalTaskTopicDto
 */
export interface FetchExternalTaskTopicDto {
    /**
     * **Mandatory.** The topic\'s name.
     * @type {string}
     * @memberof FetchExternalTaskTopicDto
     */
    'topicName': string;
    /**
     * **Mandatory.** The duration to lock the external tasks for in milliseconds.
     * @type {number}
     * @memberof FetchExternalTaskTopicDto
     */
    'lockDuration': number | null;
    /**
     * A JSON array of `String` values that represent variable names. For each result task belonging to this topic, the given variables are returned as well if they are accessible from the external task\'s execution. If not provided - all variables will be fetched.
     * @type {Array<string>}
     * @memberof FetchExternalTaskTopicDto
     */
    'variables'?: Array<string>;
    /**
     * If `true` only local variables will be fetched.
     * @type {boolean}
     * @memberof FetchExternalTaskTopicDto
     */
    'localVariables'?: boolean | null;
    /**
     * A `String` value which enables the filtering of tasks based on process instance business key.
     * @type {string}
     * @memberof FetchExternalTaskTopicDto
     */
    'businessKey'?: string;
    /**
     * Filter tasks based on process definition id.
     * @type {string}
     * @memberof FetchExternalTaskTopicDto
     */
    'processDefinitionId'?: string;
    /**
     * Filter tasks based on process definition ids.
     * @type {Array<string>}
     * @memberof FetchExternalTaskTopicDto
     */
    'processDefinitionIdIn'?: Array<string>;
    /**
     * Filter tasks based on process definition key.
     * @type {string}
     * @memberof FetchExternalTaskTopicDto
     */
    'processDefinitionKey'?: string;
    /**
     * Filter tasks based on process definition keys.
     * @type {Array<string>}
     * @memberof FetchExternalTaskTopicDto
     */
    'processDefinitionKeyIn'?: Array<string>;
    /**
     * Filter tasks based on process definition version tag.
     * @type {string}
     * @memberof FetchExternalTaskTopicDto
     */
    'processDefinitionVersionTag'?: string;
    /**
     * Filter tasks without tenant id.
     * @type {boolean}
     * @memberof FetchExternalTaskTopicDto
     */
    'withoutTenantId'?: boolean | null;
    /**
     * Filter tasks based on tenant ids.
     * @type {Array<string>}
     * @memberof FetchExternalTaskTopicDto
     */
    'tenantIdIn'?: Array<string>;
    /**
     * A `JSON` object used for filtering tasks based on process instance variable values. A property name of the object represents a process variable name, while the property value represents the process variable value to filter tasks by.
     * @type {{ [key: string]: object; }}
     * @memberof FetchExternalTaskTopicDto
     */
    'processVariables'?: { [key: string]: object; };
    /**
     * Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default `false`).  If set to `true`, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\'s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\'s classpath.  If set to `false`, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.
     * @type {boolean}
     * @memberof FetchExternalTaskTopicDto
     */
    'deserializeValues'?: boolean | null;
}
/**
 * 
 * @export
 * @interface FetchExternalTasksDto
 */
export interface FetchExternalTasksDto {
    /**
     * **Mandatory.** The id of the worker on which behalf tasks are fetched. The returned tasks are locked for that worker and can only be completed when providing the same worker id.
     * @type {string}
     * @memberof FetchExternalTasksDto
     */
    'workerId': string;
    /**
     * **Mandatory.** The maximum number of tasks to return.
     * @type {number}
     * @memberof FetchExternalTasksDto
     */
    'maxTasks': number | null;
    /**
     * A `boolean` value, which indicates whether the task should be fetched based on its priority or arbitrarily.
     * @type {boolean}
     * @memberof FetchExternalTasksDto
     */
    'usePriority'?: boolean | null;
    /**
     * The [Long Polling](https://docs.camunda.org/manual/7.13/user-guide/process-engine/external-tasks/#long-polling-to-fetch-and-lock-external-tasks) timeout in milliseconds.  **Note:** The value cannot be set larger than 1.800.000 milliseconds (corresponds to 30 minutes).
     * @type {number}
     * @memberof FetchExternalTasksDto
     */
    'asyncResponseTimeout'?: number | null;
    /**
     * A JSON array of topic objects for which external tasks should be fetched. The returned tasks may be arbitrarily distributed among these topics. Each topic object has the following properties:
     * @type {Array<FetchExternalTaskTopicDto>}
     * @memberof FetchExternalTasksDto
     */
    'topics'?: Array<FetchExternalTaskTopicDto>;
}
/**
 * 
 * @export
 * @interface FormDto
 */
export interface FormDto {
    /**
     * The form key.
     * @type {string}
     * @memberof FormDto
     */
    'key'?: string;
    /**
     * The context path of the process application. If the task (or the process definition) does not belong to a process application deployment or a process definition at all, this property is not set.
     * @type {string}
     * @memberof FormDto
     */
    'contextPath'?: string;
}
/**
 * A historic process instance query which defines a group of historic process instances
 * @export
 * @interface HistoricProcessInstanceQueryDto
 */
export interface HistoricProcessInstanceQueryDto {
    /**
     * Filter by process instance id.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'processInstanceId'?: string;
    /**
     * Filter by process instance ids. Must be a JSON array process instance ids.
     * @type {Array<string>}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'processInstanceIds'?: Array<string>;
    /**
     * Filter by the process definition the instances run on.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'processDefinitionId'?: string;
    /**
     * Filter by the key of the process definition the instances run on.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'processDefinitionKey'?: string;
    /**
     * Filter by a list of process definition keys. A process instance must have one of the given process definition keys. Must be a JSON array of Strings.
     * @type {Array<string>}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'processDefinitionKeyIn'?: Array<string>;
    /**
     * Filter by the name of the process definition the instances run on.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'processDefinitionName'?: string;
    /**
     * Filter by process definition names that the parameter is a substring of.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'processDefinitionNameLike'?: string;
    /**
     * Exclude instances that belong to a set of process definitions. Must be a JSON array of process definition keys.
     * @type {Array<string>}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'processDefinitionKeyNotIn'?: Array<string>;
    /**
     * Filter by process instance business key.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'processInstanceBusinessKey'?: string;
    /**
     * Filter by process instance business key that the parameter is a substring of.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'processInstanceBusinessKeyLike'?: string;
    /**
     * Restrict the query to all process instances that are top level process instances.
     * @type {boolean}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'rootProcessInstances'?: boolean | null;
    /**
     * Only include finished process instances. Value may only be true, as false is the default behavior.
     * @type {boolean}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'finished'?: boolean | null;
    /**
     * Only include unfinished process instances. Value may only be true, as false is the default behavior.
     * @type {boolean}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'unfinished'?: boolean | null;
    /**
     * Only include process instances which have an incident. Value may only be true, as false is the default behavior.
     * @type {boolean}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'withIncidents'?: boolean | null;
    /**
     * Only include process instances which have a root incident. Value may only be true, as false is the default behavior.
     * @type {boolean}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'withRootIncidents'?: boolean | null;
    /**
     * Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types. 
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'incidentType'?: string;
    /**
     * Only include process instances which have an incident in status either open or resolved. To get all process instances, use the query parameter withIncidents.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'incidentStatus'?: HistoricProcessInstanceQueryDtoIncidentStatusEnum;
    /**
     * Filter by the incident message. Exact match.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'incidentMessage'?: string;
    /**
     * Filter by the incident message that the parameter is a substring of.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'incidentMessageLike'?: string;
    /**
     * Restrict to instances that were started before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format yyyy-MM-dd\'T\'HH:mm:ss.SSSZ, e.g., 2013-01-23T14:42:45.000+0200.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'startedBefore'?: string | null;
    /**
     * Restrict to instances that were started after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format yyyy-MM-dd\'T\'HH:mm:ss.SSSZ, e.g., 2013-01-23T14:42:45.000+0200.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'startedAfter'?: string | null;
    /**
     * Restrict to instances that were finished before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format yyyy-MM-dd\'T\'HH:mm:ss.SSSZ, e.g., 2013-01-23T14:42:45.000+0200.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'finishedBefore'?: string | null;
    /**
     * Restrict to instances that were finished after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format yyyy-MM-dd\'T\'HH:mm:ss.SSSZ, e.g., 2013-01-23T14:42:45.000+0200.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'finishedAfter'?: string | null;
    /**
     * Restrict to instances that executed an activity after the given date (inclusive). By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format yyyy-MM-dd\'T\'HH:mm:ss.SSSZ, e.g., 2013-01-23T14:42:45.000+0200.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'executedActivityAfter'?: string | null;
    /**
     * Restrict to instances that executed an activity before the given date (inclusive). By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format yyyy-MM-dd\'T\'HH:mm:ss.SSSZ, e.g., 2013-01-23T14:42:45.000+0200.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'executedActivityBefore'?: string | null;
    /**
     * Restrict to instances that executed an job after the given date (inclusive). By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format yyyy-MM-dd\'T\'HH:mm:ss.SSSZ, e.g., 2013-01-23T14:42:45.000+0200.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'executedJobAfter'?: string | null;
    /**
     * Restrict to instances that executed an job before the given date (inclusive). By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format yyyy-MM-dd\'T\'HH:mm:ss.SSSZ, e.g., 2013-01-23T14:42:45.000+0200.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'executedJobBefore'?: string | null;
    /**
     * Only include process instances that were started by the given user.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'startedBy'?: string;
    /**
     * Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'superProcessInstanceId'?: string;
    /**
     * Restrict query to one process instance that has a sub process instance with the given id.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'subProcessInstanceId'?: string;
    /**
     * Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'superCaseInstanceId'?: string;
    /**
     * Restrict query to one process instance that has a sub case instance with the given id.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'subCaseInstanceId'?: string;
    /**
     * Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'caseInstanceId'?: string;
    /**
     * Filter by a list of tenant ids. A process instance must have one of the given tenant ids. Must be a JSON array of Strings.
     * @type {Array<string>}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'tenantIdIn'?: Array<string>;
    /**
     * Only include historic process instances which belong to no tenant. Value may only be true, as false is the default behavior.
     * @type {boolean}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'withoutTenantId'?: boolean | null;
    /**
     * Restrict to instances that executed an activity with one of given ids.
     * @type {Array<string>}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'executedActivityIdIn'?: Array<string>;
    /**
     * Restrict to instances that have an active activity with one of given ids.
     * @type {Array<string>}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'activeActivityIdIn'?: Array<string>;
    /**
     * Restrict to instances that are active.
     * @type {boolean}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'active'?: boolean | null;
    /**
     * Restrict to instances that are suspended.
     * @type {boolean}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'suspended'?: boolean | null;
    /**
     * Restrict to instances that are completed.
     * @type {boolean}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'completed'?: boolean | null;
    /**
     * Restrict to instances that are externallyTerminated.
     * @type {boolean}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'externallyTerminated'?: boolean | null;
    /**
     * Restrict to instances that are internallyTerminated.
     * @type {boolean}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'internallyTerminated'?: boolean | null;
    /**
     * A JSON array to only include process instances that have/had variables with certain values. The array consists of objects with the three properties `name`, `operator` and `value`. `name` (String) is the variable name, `operator` (String) is the comparison operator to be used and `value` the variable value. `value` may be String, Number or Boolean. Valid operator values are: `eq` - equal to; `neq` - not equal to; `gt` - greater than; `gteq` - greater than or equal to; `lt` - lower than; `lteq` - lower than or equal to; `like`.
     * @type {Array<VariableQueryParameterDto>}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'variables'?: Array<VariableQueryParameterDto>;
    /**
     * Match all variable names provided in variables case-insensitively. If set to true variableName and variablename are treated as equal.
     * @type {boolean}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'variableNamesIgnoreCase'?: boolean | null;
    /**
     * Match all variable values provided in variables case-insensitively. If set to true variableValue and variablevalue are treated as equal.
     * @type {boolean}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'variableValuesIgnoreCase'?: boolean | null;
    /**
     * A JSON array of nested historic process instance queries with OR semantics. A process instance matches a nested query if it fulfills at least one of the query\'s predicates. With multiple nested queries, a process instance must fulfill at least one predicate of each query (Conjunctive Normal Form). All process instance query properties can be used except for: sorting See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-engine-api/#or-queries) for more information about OR queries.
     * @type {Array<HistoricProcessInstanceQueryDto>}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'orQueries'?: Array<HistoricProcessInstanceQueryDto>;
    /**
     * Apply sorting of the result
     * @type {Array<HistoricProcessInstanceQueryDtoSorting>}
     * @memberof HistoricProcessInstanceQueryDto
     */
    'sorting'?: Array<HistoricProcessInstanceQueryDtoSorting>;
}

export const HistoricProcessInstanceQueryDtoIncidentStatusEnum = {
    Open: 'open',
    Resolved: 'resolved'
} as const;

export type HistoricProcessInstanceQueryDtoIncidentStatusEnum = typeof HistoricProcessInstanceQueryDtoIncidentStatusEnum[keyof typeof HistoricProcessInstanceQueryDtoIncidentStatusEnum];

/**
 * 
 * @export
 * @interface HistoricProcessInstanceQueryDtoSorting
 */
export interface HistoricProcessInstanceQueryDtoSorting {
    /**
     * Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDtoSorting
     */
    'sortBy'?: HistoricProcessInstanceQueryDtoSortingSortByEnum;
    /**
     * Sort the results in a given order. Values may be `asc` for ascending order or `desc` for descending order. Must be used in conjunction with the sortBy parameter.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDtoSorting
     */
    'sortOrder'?: HistoricProcessInstanceQueryDtoSortingSortOrderEnum;
}

export const HistoricProcessInstanceQueryDtoSortingSortByEnum = {
    InstanceId: 'instanceId',
    DefinitionId: 'definitionId',
    DefinitionKey: 'definitionKey',
    DefinitionName: 'definitionName',
    DefinitionVersion: 'definitionVersion',
    BusinessKey: 'businessKey',
    StartTime: 'startTime',
    EndTime: 'endTime',
    Duration: 'duration',
    TenantId: 'tenantId'
} as const;

export type HistoricProcessInstanceQueryDtoSortingSortByEnum = typeof HistoricProcessInstanceQueryDtoSortingSortByEnum[keyof typeof HistoricProcessInstanceQueryDtoSortingSortByEnum];
export const HistoricProcessInstanceQueryDtoSortingSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type HistoricProcessInstanceQueryDtoSortingSortOrderEnum = typeof HistoricProcessInstanceQueryDtoSortingSortOrderEnum[keyof typeof HistoricProcessInstanceQueryDtoSortingSortOrderEnum];

/**
 * 
 * @export
 * @interface HistoryTimeToLiveDto
 */
export interface HistoryTimeToLiveDto {
    /**
     * New value for historyTimeToLive field of the definition. Can be `null`. Can not be negative.
     * @type {number}
     * @memberof HistoryTimeToLiveDto
     */
    'historyTimeToLive'?: number | null;
}
/**
 * 
 * @export
 * @interface IdentityLinkDto
 */
export interface IdentityLinkDto {
    /**
     * The id of the user participating in this link. Either `userId` or `groupId` is set.
     * @type {string}
     * @memberof IdentityLinkDto
     */
    'userId'?: string;
    /**
     * The id of the group participating in this link. Either `groupId` or `userId` is set.
     * @type {string}
     * @memberof IdentityLinkDto
     */
    'groupId'?: string;
    /**
     * The type of the identity link. The value of the this property can be user-defined. The Process Engine provides three pre-defined Identity Link `type`s:  * `candidate` * `assignee` - reserved for the task assignee * `owner` - reserved for the task owner  **Note**: When adding or removing an Identity Link, the `type` property must be defined.
     * @type {string}
     * @memberof IdentityLinkDto
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface IncidentStatisticsResultDto
 */
export interface IncidentStatisticsResultDto {
    /**
     * The type of the incident the number of incidents is aggregated for. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @type {string}
     * @memberof IncidentStatisticsResultDto
     */
    'incidentType'?: string;
    /**
     * The total number of incidents for the corresponding incident type.
     * @type {number}
     * @memberof IncidentStatisticsResultDto
     */
    'incidentCount'?: number;
}
/**
 * 
 * @export
 * @interface LinkableDto
 */
export interface LinkableDto {
    /**
     * The links associated to this resource, with `method`, `href` and `rel`.
     * @type {Array<AtomLink>}
     * @memberof LinkableDto
     */
    'links'?: Array<AtomLink>;
}
/**
 * 
 * @export
 * @interface LockedExternalTaskDto
 */
export interface LockedExternalTaskDto {
    /**
     * The id of the activity that this external task belongs to.
     * @type {string}
     * @memberof LockedExternalTaskDto
     */
    'activityId'?: string;
    /**
     * The id of the activity instance that the external task belongs to.
     * @type {string}
     * @memberof LockedExternalTaskDto
     */
    'activityInstanceId'?: string;
    /**
     * The full error message submitted with the latest reported failure executing this task;`null` if no failure was reported previously or if no error message was submitted
     * @type {string}
     * @memberof LockedExternalTaskDto
     */
    'errorMessage'?: string;
    /**
     * The error details submitted with the latest reported failure executing this task.`null` if no failure was reported previously or if no error details was submitted
     * @type {string}
     * @memberof LockedExternalTaskDto
     */
    'errorDetails'?: string;
    /**
     * The id of the execution that the external task belongs to.
     * @type {string}
     * @memberof LockedExternalTaskDto
     */
    'executionId'?: string;
    /**
     * The id of the external task.
     * @type {string}
     * @memberof LockedExternalTaskDto
     */
    'id'?: string;
    /**
     * The date that the task\'s most recent lock expires or has expired.
     * @type {string}
     * @memberof LockedExternalTaskDto
     */
    'lockExpirationTime'?: string | null;
    /**
     * The id of the process definition the external task is defined in.
     * @type {string}
     * @memberof LockedExternalTaskDto
     */
    'processDefinitionId'?: string;
    /**
     * The key of the process definition the external task is defined in.
     * @type {string}
     * @memberof LockedExternalTaskDto
     */
    'processDefinitionKey'?: string;
    /**
     * The version tag of the process definition the external task is defined in.
     * @type {string}
     * @memberof LockedExternalTaskDto
     */
    'processDefinitionVersionTag'?: string;
    /**
     * The id of the process instance the external task belongs to.
     * @type {string}
     * @memberof LockedExternalTaskDto
     */
    'processInstanceId'?: string;
    /**
     * The id of the tenant the external task belongs to.
     * @type {string}
     * @memberof LockedExternalTaskDto
     */
    'tenantId'?: string;
    /**
     * The number of retries the task currently has left.
     * @type {number}
     * @memberof LockedExternalTaskDto
     */
    'retries'?: number | null;
    /**
     * Whether the process instance the external task belongs to is suspended.
     * @type {boolean}
     * @memberof LockedExternalTaskDto
     */
    'suspended'?: boolean | null;
    /**
     * The id of the worker that posesses or posessed the most recent lock.
     * @type {string}
     * @memberof LockedExternalTaskDto
     */
    'workerId'?: string;
    /**
     * The priority of the external task.
     * @type {number}
     * @memberof LockedExternalTaskDto
     */
    'priority'?: number | null;
    /**
     * The topic name of the external task.
     * @type {string}
     * @memberof LockedExternalTaskDto
     */
    'topicName'?: string;
    /**
     * The business key of the process instance the external task belongs to.
     * @type {string}
     * @memberof LockedExternalTaskDto
     */
    'businessKey'?: string;
    /**
     * A JSON object containing a property for each of the requested variables. The key is the variable name, the value is a JSON object of serialized variable values with the following properties:
     * @type {{ [key: string]: VariableValueDto; }}
     * @memberof LockedExternalTaskDto
     */
    'variables'?: { [key: string]: VariableValueDto; };
}
/**
 * The `processInstance` property only has a value if the resultType is set to `ProcessDefinition`. The processInstance with the properties as described in the [get single instance](https://docs.camunda.org/manual/7.13/reference/rest/process-instance/get/) method.  The `execution` property only has a value if the resultType is set to `Execution`. The execution with the properties as described in the [get single execution](https://docs.camunda.org/manual/7.13/reference/rest/execution/get/) method.
 * @export
 * @interface MessageCorrelationResultWithVariableDto
 */
export interface MessageCorrelationResultWithVariableDto {
    /**
     * Indicates if the message was correlated to a message start event or an  intermediate message catching event. In the first case, the resultType is  `ProcessDefinition` and otherwise `Execution`.
     * @type {string}
     * @memberof MessageCorrelationResultWithVariableDto
     */
    'resultType'?: MessageCorrelationResultWithVariableDtoResultTypeEnum;
    /**
     * 
     * @type {ProcessInstanceDto}
     * @memberof MessageCorrelationResultWithVariableDto
     */
    'processInstance'?: ProcessInstanceDto;
    /**
     * 
     * @type {ExecutionDto}
     * @memberof MessageCorrelationResultWithVariableDto
     */
    'execution'?: ExecutionDto;
    /**
     * This property is returned if the `variablesInResultEnabled` is set to `true`. Contains a list of the process variables. 
     * @type {{ [key: string]: VariableValueDto; }}
     * @memberof MessageCorrelationResultWithVariableDto
     */
    'variables'?: { [key: string]: VariableValueDto; };
}

export const MessageCorrelationResultWithVariableDtoResultTypeEnum = {
    Execution: 'Execution',
    ProcessDefinition: 'ProcessDefinition'
} as const;

export type MessageCorrelationResultWithVariableDtoResultTypeEnum = typeof MessageCorrelationResultWithVariableDtoResultTypeEnum[keyof typeof MessageCorrelationResultWithVariableDtoResultTypeEnum];

/**
 * 
 * @export
 * @interface MetricsIntervalResultDto
 */
export interface MetricsIntervalResultDto {
    /**
     * The interval timestamp.
     * @type {string}
     * @memberof MetricsIntervalResultDto
     */
    'timestamp'?: string;
    /**
     * The name of the metric.
     * @type {string}
     * @memberof MetricsIntervalResultDto
     */
    'name'?: string;
    /**
     * The reporter of the metric. `null` if the metrics are aggregated by reporter.
     * @type {string}
     * @memberof MetricsIntervalResultDto
     */
    'reporter'?: string;
    /**
     * The value of the metric aggregated by the interval.
     * @type {number}
     * @memberof MetricsIntervalResultDto
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface MetricsResultDto
 */
export interface MetricsResultDto {
    /**
     * The current sum (count) for the selected metric.
     * @type {number}
     * @memberof MetricsResultDto
     */
    'result'?: number;
}
/**
 * 
 * @export
 * @interface MissingAuthorizationDto
 */
export interface MissingAuthorizationDto {
    /**
     * The permission name that the user is missing.
     * @type {string}
     * @memberof MissingAuthorizationDto
     */
    'permissionName'?: string;
    /**
     * The name of the resource that the user is missing permission for.
     * @type {string}
     * @memberof MissingAuthorizationDto
     */
    'resourceName'?: string;
    /**
     * The id of the resource that the user is missing permission for.
     * @type {string}
     * @memberof MissingAuthorizationDto
     */
    'resourceId'?: string;
}
/**
 * 
 * @export
 * @interface ParseExceptionDto
 */
export interface ParseExceptionDto {
    /**
     * A JSON Object containing list of errors and warnings occurred during deployment.
     * @type {{ [key: string]: ResourceReportDto; }}
     * @memberof ParseExceptionDto
     */
    'details'?: { [key: string]: ResourceReportDto; };
    /**
     * An exception class indicating the occurred error.
     * @type {string}
     * @memberof ParseExceptionDto
     */
    'type'?: string;
    /**
     * A detailed message of the error.
     * @type {string}
     * @memberof ParseExceptionDto
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ParseExceptionDtoAllOf
 */
export interface ParseExceptionDtoAllOf {
    /**
     * A JSON Object containing list of errors and warnings occurred during deployment.
     * @type {{ [key: string]: ResourceReportDto; }}
     * @memberof ParseExceptionDtoAllOf
     */
    'details'?: { [key: string]: ResourceReportDto; };
}
/**
 * 
 * @export
 * @interface PatchVariablesDto
 */
export interface PatchVariablesDto {
    /**
     * A JSON object containing variable key-value pairs.
     * @type {{ [key: string]: VariableValueDto; }}
     * @memberof PatchVariablesDto
     */
    'modifications'?: { [key: string]: VariableValueDto; };
    /**
     * An array of String keys of variables to be deleted.
     * @type {Array<string>}
     * @memberof PatchVariablesDto
     */
    'deletions'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PriorityDto
 */
export interface PriorityDto {
    /**
     * The priority of the resource.
     * @type {number}
     * @memberof PriorityDto
     */
    'priority'?: number | null;
}
/**
 * 
 * @export
 * @interface ProblemDto
 */
export interface ProblemDto {
    /**
     * The message of the problem.
     * @type {string}
     * @memberof ProblemDto
     */
    'message'?: string;
    /**
     * The line where the problem occurred.
     * @type {number}
     * @memberof ProblemDto
     */
    'line'?: number | null;
    /**
     * The column where the problem occurred.
     * @type {number}
     * @memberof ProblemDto
     */
    'column'?: number | null;
    /**
     * The main element id where the problem occurred.
     * @type {string}
     * @memberof ProblemDto
     */
    'mainElementId'?: string;
    /**
     * A list of element id affected by the problem.
     * @type {Array<string>}
     * @memberof ProblemDto
     */
    'elementIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ProcessDefinitionDiagramDto
 */
export interface ProcessDefinitionDiagramDto {
    /**
     * The id of the process definition.
     * @type {string}
     * @memberof ProcessDefinitionDiagramDto
     */
    'id'?: string;
    /**
     * An escaped XML string containing the XML that this definition was deployed with. Carriage returns, line feeds and quotation marks are escaped.
     * @type {string}
     * @memberof ProcessDefinitionDiagramDto
     */
    'bpmn20Xml'?: string;
}
/**
 * 
 * @export
 * @interface ProcessDefinitionDto
 */
export interface ProcessDefinitionDto {
    /**
     * The id of the process definition
     * @type {string}
     * @memberof ProcessDefinitionDto
     */
    'id'?: string;
    /**
     * The key of the process definition, i.e., the id of the BPMN 2.0 XML process definition.
     * @type {string}
     * @memberof ProcessDefinitionDto
     */
    'key'?: string;
    /**
     * The category of the process definition.
     * @type {string}
     * @memberof ProcessDefinitionDto
     */
    'category'?: string;
    /**
     * The description of the process definition.
     * @type {string}
     * @memberof ProcessDefinitionDto
     */
    'description'?: string;
    /**
     * The name of the process definition.
     * @type {string}
     * @memberof ProcessDefinitionDto
     */
    'name'?: string;
    /**
     * The version of the process definition that the engine assigned to it.
     * @type {number}
     * @memberof ProcessDefinitionDto
     */
    'version'?: number;
    /**
     * The file name of the process definition.
     * @type {string}
     * @memberof ProcessDefinitionDto
     */
    'resource'?: string;
    /**
     * The deployment id of the process definition.
     * @type {string}
     * @memberof ProcessDefinitionDto
     */
    'deploymentId'?: string;
    /**
     * The file name of the process definition diagram, if it exists.
     * @type {string}
     * @memberof ProcessDefinitionDto
     */
    'diagram'?: string;
    /**
     * A flag indicating whether the definition is suspended or not.
     * @type {boolean}
     * @memberof ProcessDefinitionDto
     */
    'suspended'?: boolean;
    /**
     * The tenant id of the process definition.
     * @type {string}
     * @memberof ProcessDefinitionDto
     */
    'tenantId'?: string;
    /**
     * The version tag of the process definition.
     * @type {string}
     * @memberof ProcessDefinitionDto
     */
    'versionTag'?: string;
    /**
     * History time to live value of the process definition. Is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
     * @type {number}
     * @memberof ProcessDefinitionDto
     */
    'historyTimeToLive'?: number | null;
    /**
     * A flag indicating whether the process definition is startable in Tasklist or not.
     * @type {boolean}
     * @memberof ProcessDefinitionDto
     */
    'startableInTasklist'?: boolean;
}
/**
 * 
 * @export
 * @interface ProcessDefinitionStatisticsResultDto
 */
export interface ProcessDefinitionStatisticsResultDto {
    /**
     * The id of the process definition the results are aggregated for.
     * @type {string}
     * @memberof ProcessDefinitionStatisticsResultDto
     */
    'id'?: string;
    /**
     * The total number of running process instances of this process definition.
     * @type {number}
     * @memberof ProcessDefinitionStatisticsResultDto
     */
    'instances'?: number;
    /**
     * The total number of failed jobs for the running instances. **Note**: Will be `0` (not `null`), if failed jobs were excluded.
     * @type {number}
     * @memberof ProcessDefinitionStatisticsResultDto
     */
    'failedJobs'?: number;
    /**
     * Each item in the resulting array is an object which contains `incidentType` and `incidentCount`. **Note**: Will be an empty array, if `incidents` or `incidentsForType` were excluded. Furthermore, the array will be also empty if no incidents were found.
     * @type {Array<IncidentStatisticsResultDto>}
     * @memberof ProcessDefinitionStatisticsResultDto
     */
    'incidents'?: Array<IncidentStatisticsResultDto>;
    /**
     * 
     * @type {ProcessDefinitionDto}
     * @memberof ProcessDefinitionStatisticsResultDto
     */
    'definition'?: ProcessDefinitionDto;
}
/**
 * 
 * @export
 * @interface ProcessDefinitionSuspensionStateDto
 */
export interface ProcessDefinitionSuspensionStateDto {
    /**
     * A `Boolean` value which indicates whether to activate or suspend all process definitions with the given key. When the value is set to `true`, all process definitions with the given key will be suspended and when the value is set to `false`, all process definitions with the given key will be activated.
     * @type {boolean}
     * @memberof ProcessDefinitionSuspensionStateDto
     */
    'suspended'?: boolean | null;
    /**
     * The id of the process definitions to activate or suspend.
     * @type {string}
     * @memberof ProcessDefinitionSuspensionStateDto
     */
    'processDefinitionId'?: string;
    /**
     *  The key of the process definitions to activate or suspend.
     * @type {string}
     * @memberof ProcessDefinitionSuspensionStateDto
     */
    'processDefinitionKey'?: string;
    /**
     * A `Boolean` value which indicates whether to activate or suspend also all process instances of  the process definitions with the given key. When the value is set to `true`, all process instances of the process definitions with the given key will be activated or suspended and when the value is set to `false`, the suspension state of  all process instances of the process definitions with the given key will not be updated.
     * @type {boolean}
     * @memberof ProcessDefinitionSuspensionStateDto
     */
    'includeProcessInstances'?: boolean | null;
    /**
     * The date on which all process definitions with the given key will be activated or suspended. If `null`, the suspension state of all process definitions with the given key is updated immediately. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format yyyy-MM-dd\'T\'HH:mm:ss.SSSZ, e.g., 2013-01-23T14:42:45.000+0200.
     * @type {string}
     * @memberof ProcessDefinitionSuspensionStateDto
     */
    'executionDate'?: string | null;
}
/**
 * 
 * @export
 * @interface ProcessEngineDto
 */
export interface ProcessEngineDto {
    /**
     * The name of the process engine.
     * @type {string}
     * @memberof ProcessEngineDto
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ProcessInstanceDto
 */
export interface ProcessInstanceDto {
    /**
     * The id of the process instance.
     * @type {string}
     * @memberof ProcessInstanceDto
     */
    'id'?: string;
    /**
     * The id of the process definition that this process instance belongs to.
     * @type {string}
     * @memberof ProcessInstanceDto
     */
    'definitionId'?: string;
    /**
     * The business key of the process instance.
     * @type {string}
     * @memberof ProcessInstanceDto
     */
    'businessKey'?: string;
    /**
     * The id of the case instance associated with the process instance.
     * @type {string}
     * @memberof ProcessInstanceDto
     */
    'caseInstanceId'?: string;
    /**
     * A flag indicating whether the process instance has ended or not. Deprecated: will always be false!
     * @type {boolean}
     * @memberof ProcessInstanceDto
     * @deprecated
     */
    'ended'?: boolean;
    /**
     * A flag indicating whether the process instance is suspended or not.
     * @type {boolean}
     * @memberof ProcessInstanceDto
     */
    'suspended'?: boolean;
    /**
     * The tenant id of the process instance.
     * @type {string}
     * @memberof ProcessInstanceDto
     */
    'tenantId'?: string;
    /**
     * The links associated to this resource, with `method`, `href` and `rel`.
     * @type {Array<AtomLink>}
     * @memberof ProcessInstanceDto
     */
    'links'?: Array<AtomLink>;
}
/**
 * 
 * @export
 * @interface ProcessInstanceDtoAllOf
 */
export interface ProcessInstanceDtoAllOf {
    /**
     * The id of the process instance.
     * @type {string}
     * @memberof ProcessInstanceDtoAllOf
     */
    'id'?: string;
    /**
     * The id of the process definition that this process instance belongs to.
     * @type {string}
     * @memberof ProcessInstanceDtoAllOf
     */
    'definitionId'?: string;
    /**
     * The business key of the process instance.
     * @type {string}
     * @memberof ProcessInstanceDtoAllOf
     */
    'businessKey'?: string;
    /**
     * The id of the case instance associated with the process instance.
     * @type {string}
     * @memberof ProcessInstanceDtoAllOf
     */
    'caseInstanceId'?: string;
    /**
     * A flag indicating whether the process instance has ended or not. Deprecated: will always be false!
     * @type {boolean}
     * @memberof ProcessInstanceDtoAllOf
     * @deprecated
     */
    'ended'?: boolean;
    /**
     * A flag indicating whether the process instance is suspended or not.
     * @type {boolean}
     * @memberof ProcessInstanceDtoAllOf
     */
    'suspended'?: boolean;
    /**
     * The tenant id of the process instance.
     * @type {string}
     * @memberof ProcessInstanceDtoAllOf
     */
    'tenantId'?: string;
}
/**
 * 
 * @export
 * @interface ProcessInstanceModificationDto
 */
export interface ProcessInstanceModificationDto {
    /**
     * Skip execution listener invocation for activities that are started or ended as part of this request.
     * @type {boolean}
     * @memberof ProcessInstanceModificationDto
     */
    'skipCustomListeners'?: boolean | null;
    /**
     * Skip execution of [input/output variable mappings](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/#input-output-variable-mapping) for activities that are started or ended as part of this request.
     * @type {boolean}
     * @memberof ProcessInstanceModificationDto
     */
    'skipIoMappings'?: boolean | null;
    /**
     * JSON array of modification instructions. The instructions are executed in the order they are in.
     * @type {Array<ProcessInstanceModificationInstructionDto>}
     * @memberof ProcessInstanceModificationDto
     */
    'instructions'?: Array<ProcessInstanceModificationInstructionDto>;
    /**
     * An arbitrary text annotation set by a user for auditing reasons.
     * @type {string}
     * @memberof ProcessInstanceModificationDto
     */
    'annotation'?: string;
}
/**
 * 
 * @export
 * @interface ProcessInstanceModificationInstructionDto
 */
export interface ProcessInstanceModificationInstructionDto {
    /**
     * **Mandatory**. One of the following values: `cancel`, `startBeforeActivity`, `startAfterActivity`, `startTransition`.  * A cancel instruction requests cancellation of a single activity instance or all instances of one activity. * A startBeforeActivity instruction requests to enter a given activity. * A startAfterActivity instruction requests to execute the single outgoing sequence flow of a given activity. * A startTransition instruction requests to execute a specific sequence flow.
     * @type {string}
     * @memberof ProcessInstanceModificationInstructionDto
     */
    'type': ProcessInstanceModificationInstructionDtoTypeEnum;
    /**
     * 
     * @type {TriggerVariableValueDto}
     * @memberof ProcessInstanceModificationInstructionDto
     */
    'variables'?: TriggerVariableValueDto;
    /**
     * Can be used with instructions of types `startTransition`. Specifies the sequence flow to start.
     * @type {string}
     * @memberof ProcessInstanceModificationInstructionDto
     */
    'activityId'?: string;
    /**
     * Can be used with instructions of types `startTransition`. Specifies the sequence flow to start.
     * @type {string}
     * @memberof ProcessInstanceModificationInstructionDto
     */
    'transitionId'?: string;
    /**
     * Can be used with instructions of type `cancel`. Specifies the activity instance to cancel. Valid values are the activity instance IDs supplied by the [Get Activity Instance request](https://docs.camunda.org/manual/7.13/reference/rest/process-instance/get-activity-instances/).
     * @type {string}
     * @memberof ProcessInstanceModificationInstructionDto
     */
    'activityInstanceId'?: string;
    /**
     * Can be used with instructions of type `cancel`. Specifies the transition instance to cancel. Valid values are the transition instance IDs supplied by the [Get Activity Instance request](https://docs.camunda.org/manual/7.13/reference/rest/process-instance/get-activity-instances/).
     * @type {string}
     * @memberof ProcessInstanceModificationInstructionDto
     */
    'transitionInstanceId'?: string;
    /**
     * Can be used with instructions of type `startBeforeActivity`, `startAfterActivity`, and `startTransition`. Valid values are the activity instance IDs supplied by the Get Activity Instance request. If there are multiple parent activity instances of the targeted activity, this specifies the ancestor scope in which hierarchy the activity/transition is to be instantiated.  Example: When there are two instances of a subprocess and an activity contained in the subprocess is to be started, this parameter allows to specifiy under which subprocess instance the activity should be started.
     * @type {string}
     * @memberof ProcessInstanceModificationInstructionDto
     */
    'ancestorActivityInstanceId'?: string;
    /**
     * Can be used with instructions of type cancel. Prevents the deletion of new created activity instances.
     * @type {boolean}
     * @memberof ProcessInstanceModificationInstructionDto
     */
    'cancelCurrentActiveActivityInstances'?: boolean | null;
}

export const ProcessInstanceModificationInstructionDtoTypeEnum = {
    Cancel: 'cancel',
    StartBeforeActivity: 'startBeforeActivity',
    StartAfterActivity: 'startAfterActivity',
    StartTransition: 'startTransition'
} as const;

export type ProcessInstanceModificationInstructionDtoTypeEnum = typeof ProcessInstanceModificationInstructionDtoTypeEnum[keyof typeof ProcessInstanceModificationInstructionDtoTypeEnum];

/**
 * A process instance query which defines a group of process instances
 * @export
 * @interface ProcessInstanceQueryDto
 */
export interface ProcessInstanceQueryDto {
    /**
     * Filter by the deployment the id belongs to.
     * @type {string}
     * @memberof ProcessInstanceQueryDto
     */
    'deploymentId'?: string;
    /**
     * Filter by the process definition the instances run on.
     * @type {string}
     * @memberof ProcessInstanceQueryDto
     */
    'processDefinitionId'?: string;
    /**
     * Filter by the key of the process definition the instances run on.
     * @type {string}
     * @memberof ProcessInstanceQueryDto
     */
    'processDefinitionKey'?: string;
    /**
     * Filter by a list of process definition keys. A process instance must have one of the given process definition keys. Must be a JSON array of Strings.
     * @type {Array<string>}
     * @memberof ProcessInstanceQueryDto
     */
    'processDefinitionKeyIn'?: Array<string>;
    /**
     * Exclude instances by a list of process definition keys. A process instance must not have one of the given process definition keys. Must be a JSON array of Strings.
     * @type {Array<string>}
     * @memberof ProcessInstanceQueryDto
     */
    'processDefinitionKeyNotIn'?: Array<string>;
    /**
     * Filter by process instance business key.
     * @type {string}
     * @memberof ProcessInstanceQueryDto
     */
    'businessKey'?: string;
    /**
     * Filter by process instance business key that the parameter is a substring of.
     * @type {string}
     * @memberof ProcessInstanceQueryDto
     */
    'businessKeyLike'?: string;
    /**
     * Filter by case instance id.
     * @type {string}
     * @memberof ProcessInstanceQueryDto
     */
    'caseInstanceId'?: string;
    /**
     * Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id.
     * @type {string}
     * @memberof ProcessInstanceQueryDto
     */
    'superProcessInstance'?: string;
    /**
     * Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id.
     * @type {string}
     * @memberof ProcessInstanceQueryDto
     */
    'subProcessInstance'?: string;
    /**
     * Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.
     * @type {string}
     * @memberof ProcessInstanceQueryDto
     */
    'superCaseInstance'?: string;
    /**
     * Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id.
     * @type {string}
     * @memberof ProcessInstanceQueryDto
     */
    'subCaseInstance'?: string;
    /**
     * Only include active process instances. Value may only be true, as false is the default behavior.
     * @type {boolean}
     * @memberof ProcessInstanceQueryDto
     */
    'active'?: boolean | null;
    /**
     * Only include suspended process instances. Value may only be true, as false is the default behavior.
     * @type {boolean}
     * @memberof ProcessInstanceQueryDto
     */
    'suspended'?: boolean | null;
    /**
     * Filter by a list of process instance ids. Must be a JSON array of Strings.
     * @type {Array<string>}
     * @memberof ProcessInstanceQueryDto
     */
    'processInstanceIds'?: Array<string>;
    /**
     * Filter by presence of incidents. Selects only process instances that have an incident.
     * @type {boolean}
     * @memberof ProcessInstanceQueryDto
     */
    'withIncident'?: boolean | null;
    /**
     * Filter by the incident id.
     * @type {string}
     * @memberof ProcessInstanceQueryDto
     */
    'incidentId'?: string;
    /**
     * Filter by the incident type. See the User Guide for a list of incident types.
     * @type {string}
     * @memberof ProcessInstanceQueryDto
     */
    'incidentType'?: string;
    /**
     * Filter by the incident message. Exact match.
     * @type {string}
     * @memberof ProcessInstanceQueryDto
     */
    'incidentMessage'?: string;
    /**
     * Filter by the incident message that the parameter is a substring of.
     * @type {string}
     * @memberof ProcessInstanceQueryDto
     */
    'incidentMessageLike'?: string;
    /**
     * Filter by a list of tenant ids. A process instance must have one of the given tenant ids. Must be a JSON array of Strings.
     * @type {Array<string>}
     * @memberof ProcessInstanceQueryDto
     */
    'tenantIdIn'?: Array<string>;
    /**
     * Only include process instances which belong to no tenant. Value may only be true, as false is the default behavior.
     * @type {boolean}
     * @memberof ProcessInstanceQueryDto
     */
    'withoutTenantId'?: boolean | null;
    /**
     * Only include process instances which process definition has no tenant id.
     * @type {boolean}
     * @memberof ProcessInstanceQueryDto
     */
    'processDefinitionWithoutTenantId'?: boolean | null;
    /**
     * Filter by a list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids.
     * @type {Array<string>}
     * @memberof ProcessInstanceQueryDto
     */
    'activityIdIn'?: Array<string>;
    /**
     * Restrict the query to all process instances that are top level process instances.
     * @type {boolean}
     * @memberof ProcessInstanceQueryDto
     */
    'rootProcessInstances'?: boolean | null;
    /**
     * Restrict the query to all process instances that are leaf instances. (i.e. don\'t have any sub instances)
     * @type {boolean}
     * @memberof ProcessInstanceQueryDto
     */
    'leafProcessInstances'?: boolean | null;
    /**
     * A JSON array to only include process instances that have variables with certain values. The array consists of objects with the three properties `name`, `operator` and `value`. `name` (String) is the variable name, `operator` (String) is the comparison operator to be used and `value` the variable value. The `value` may be String, Number or Boolean.  Valid operator values are: `eq` - equal to; `neq` - not equal to; `gt` - greater than; `gteq` - greater than or equal to; `lt` - lower than; `lteq` - lower than or equal to; `like`.
     * @type {Array<VariableQueryParameterDto>}
     * @memberof ProcessInstanceQueryDto
     */
    'variables'?: Array<VariableQueryParameterDto>;
    /**
     * Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal.
     * @type {boolean}
     * @memberof ProcessInstanceQueryDto
     */
    'variableNamesIgnoreCase'?: boolean | null;
    /**
     * Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal.
     * @type {boolean}
     * @memberof ProcessInstanceQueryDto
     */
    'variableValuesIgnoreCase'?: boolean | null;
    /**
     * A JSON array of nested process instance queries with OR semantics. A process instance matches a nested query if it fulfills at least one of the query\'s predicates. With multiple nested queries, a process instance must fulfill at least one predicate of each query (Conjunctive Normal Form). All process instance query properties can be used except for: `sorting` See the [User guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-engine-api/#or-queries) for more information about OR queries.
     * @type {Array<ProcessInstanceQueryDto>}
     * @memberof ProcessInstanceQueryDto
     */
    'orQueries'?: Array<ProcessInstanceQueryDto>;
    /**
     * Apply sorting of the result
     * @type {Array<ProcessInstanceQueryDtoSorting>}
     * @memberof ProcessInstanceQueryDto
     */
    'sorting'?: Array<ProcessInstanceQueryDtoSorting>;
}
/**
 * 
 * @export
 * @interface ProcessInstanceQueryDtoSorting
 */
export interface ProcessInstanceQueryDtoSorting {
    /**
     * Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @type {string}
     * @memberof ProcessInstanceQueryDtoSorting
     */
    'sortBy'?: ProcessInstanceQueryDtoSortingSortByEnum;
    /**
     * Sort the results in a given order. Values may be `asc` for ascending order or `desc` for descending order. Must be used in conjunction with the sortBy parameter.
     * @type {string}
     * @memberof ProcessInstanceQueryDtoSorting
     */
    'sortOrder'?: ProcessInstanceQueryDtoSortingSortOrderEnum;
}

export const ProcessInstanceQueryDtoSortingSortByEnum = {
    InstanceId: 'instanceId',
    DefinitionId: 'definitionId',
    DefinitionKey: 'definitionKey',
    BusinessKey: 'businessKey',
    TenantId: 'tenantId'
} as const;

export type ProcessInstanceQueryDtoSortingSortByEnum = typeof ProcessInstanceQueryDtoSortingSortByEnum[keyof typeof ProcessInstanceQueryDtoSortingSortByEnum];
export const ProcessInstanceQueryDtoSortingSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type ProcessInstanceQueryDtoSortingSortOrderEnum = typeof ProcessInstanceQueryDtoSortingSortOrderEnum[keyof typeof ProcessInstanceQueryDtoSortingSortOrderEnum];

/**
 * 
 * @export
 * @interface ProcessInstanceSuspensionStateAsyncDto
 */
export interface ProcessInstanceSuspensionStateAsyncDto {
    /**
     * A Boolean value which indicates whether to activate or suspend a given process instance. When the value is set to true, the given process instance will be suspended and when the value is set to false, the given process instance will be activated.
     * @type {boolean}
     * @memberof ProcessInstanceSuspensionStateAsyncDto
     */
    'suspended'?: boolean | null;
    /**
     * A list of process instance ids which defines a group of process instances which will be activated or suspended by the operation.
     * @type {Array<string>}
     * @memberof ProcessInstanceSuspensionStateAsyncDto
     */
    'processInstanceIds'?: Array<string>;
    /**
     * 
     * @type {ProcessInstanceQueryDto}
     * @memberof ProcessInstanceSuspensionStateAsyncDto
     */
    'processInstanceQuery'?: ProcessInstanceQueryDto;
    /**
     * 
     * @type {HistoricProcessInstanceQueryDto}
     * @memberof ProcessInstanceSuspensionStateAsyncDto
     */
    'historicProcessInstanceQuery'?: HistoricProcessInstanceQueryDto;
}
/**
 * 
 * @export
 * @interface ProcessInstanceSuspensionStateDto
 */
export interface ProcessInstanceSuspensionStateDto {
    /**
     * A `Boolean` value which indicates whether to activate or suspend a given process instance. When the value is set to `true`, the given process instance will be suspended and when the value is set to `false`, the given process instance will be activated.
     * @type {boolean}
     * @memberof ProcessInstanceSuspensionStateDto
     */
    'suspended'?: boolean | null;
    /**
     * The process definition id of the process instances to activate or suspend.  **Note**: This parameter can be used only with combination of `suspended`.
     * @type {string}
     * @memberof ProcessInstanceSuspensionStateDto
     */
    'processDefinitionId'?: string;
    /**
     * The process definition key of the process instances to activate or suspend.  **Note**: This parameter can be used only with combination of `suspended`, `processDefinitionTenantId`, and `processDefinitionWithoutTenantId`.
     * @type {string}
     * @memberof ProcessInstanceSuspensionStateDto
     */
    'processDefinitionKey'?: string;
    /**
     * Only activate or suspend process instances of a process definition which belongs to a tenant with the given id.  **Note**: This parameter can be used only with combination of `suspended`, `processDefinitionKey`, and `processDefinitionWithoutTenantId`.
     * @type {string}
     * @memberof ProcessInstanceSuspensionStateDto
     */
    'processDefinitionTenantId'?: string;
    /**
     * Only activate or suspend process instances of a process definition which belongs to no tenant. Value may only be true, as false is the default behavior.  **Note**: This parameter can be used only with combination of `suspended`, `processDefinitionKey`, and `processDefinitionTenantId`.
     * @type {boolean}
     * @memberof ProcessInstanceSuspensionStateDto
     */
    'processDefinitionWithoutTenantId'?: boolean | null;
    /**
     * A list of process instance ids which defines a group of process instances which will be activated or suspended by the operation.  **Note**: This parameter can be used only with combination of `suspended`, `processInstanceQuery`, and `historicProcessInstanceQuery`.
     * @type {Array<string>}
     * @memberof ProcessInstanceSuspensionStateDto
     */
    'processInstanceIds'?: Array<string>;
    /**
     * 
     * @type {ProcessInstanceQueryDto}
     * @memberof ProcessInstanceSuspensionStateDto
     */
    'processInstanceQuery'?: ProcessInstanceQueryDto;
    /**
     * 
     * @type {HistoricProcessInstanceQueryDto}
     * @memberof ProcessInstanceSuspensionStateDto
     */
    'historicProcessInstanceQuery'?: HistoricProcessInstanceQueryDto;
}
/**
 * 
 * @export
 * @interface ProcessInstanceWithVariablesDto
 */
export interface ProcessInstanceWithVariablesDto {
    /**
     * The id of the process instance.
     * @type {{ [key: string]: VariableValueDto; }}
     * @memberof ProcessInstanceWithVariablesDto
     */
    'variables'?: { [key: string]: VariableValueDto; };
    /**
     * The id of the process instance.
     * @type {string}
     * @memberof ProcessInstanceWithVariablesDto
     */
    'id'?: string;
    /**
     * The id of the process definition that this process instance belongs to.
     * @type {string}
     * @memberof ProcessInstanceWithVariablesDto
     */
    'definitionId'?: string;
    /**
     * The business key of the process instance.
     * @type {string}
     * @memberof ProcessInstanceWithVariablesDto
     */
    'businessKey'?: string;
    /**
     * The id of the case instance associated with the process instance.
     * @type {string}
     * @memberof ProcessInstanceWithVariablesDto
     */
    'caseInstanceId'?: string;
    /**
     * A flag indicating whether the process instance has ended or not. Deprecated: will always be false!
     * @type {boolean}
     * @memberof ProcessInstanceWithVariablesDto
     * @deprecated
     */
    'ended'?: boolean;
    /**
     * A flag indicating whether the process instance is suspended or not.
     * @type {boolean}
     * @memberof ProcessInstanceWithVariablesDto
     */
    'suspended'?: boolean;
    /**
     * The tenant id of the process instance.
     * @type {string}
     * @memberof ProcessInstanceWithVariablesDto
     */
    'tenantId'?: string;
    /**
     * The links associated to this resource, with `method`, `href` and `rel`.
     * @type {Array<AtomLink>}
     * @memberof ProcessInstanceWithVariablesDto
     */
    'links'?: Array<AtomLink>;
}
/**
 * 
 * @export
 * @interface ProcessInstanceWithVariablesDtoAllOf
 */
export interface ProcessInstanceWithVariablesDtoAllOf {
    /**
     * The id of the process instance.
     * @type {{ [key: string]: VariableValueDto; }}
     * @memberof ProcessInstanceWithVariablesDtoAllOf
     */
    'variables'?: { [key: string]: VariableValueDto; };
}
/**
 * A JSON object with the following properties:
 * @export
 * @interface RedeploymentDto
 */
export interface RedeploymentDto {
    /**
     * A list of deployment resource ids to re-deploy.
     * @type {Array<string>}
     * @memberof RedeploymentDto
     */
    'resourceIds'?: Array<string>;
    /**
     * A list of deployment resource names to re-deploy.
     * @type {Array<string>}
     * @memberof RedeploymentDto
     */
    'resourceNames'?: Array<string>;
    /**
     * Sets the source of the deployment.
     * @type {string}
     * @memberof RedeploymentDto
     */
    'source'?: string;
}
/**
 * 
 * @export
 * @interface ResourceReportDto
 */
export interface ResourceReportDto {
    /**
     * A list of errors occurred during parsing.
     * @type {Array<ProblemDto>}
     * @memberof ResourceReportDto
     */
    'errors'?: Array<ProblemDto>;
    /**
     * A list of warnings occurred during parsing.
     * @type {Array<ProblemDto>}
     * @memberof ResourceReportDto
     */
    'warnings'?: Array<ProblemDto>;
}
/**
 * 
 * @export
 * @interface RestartProcessInstanceDto
 */
export interface RestartProcessInstanceDto {
    /**
     * A list of process instance ids to restart.
     * @type {Array<string>}
     * @memberof RestartProcessInstanceDto
     */
    'processInstanceIds'?: Array<string>;
    /**
     * 
     * @type {HistoricProcessInstanceQueryDto}
     * @memberof RestartProcessInstanceDto
     */
    'historicProcessInstanceQuery'?: HistoricProcessInstanceQueryDto;
    /**
     * Skip execution listener invocation for activities that are started as part of this request.
     * @type {boolean}
     * @memberof RestartProcessInstanceDto
     */
    'skipCustomListeners'?: boolean | null;
    /**
     * Skip execution of [input/output variable mappings](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/#input-output-variable-mapping) for activities that are started as part of this request.
     * @type {boolean}
     * @memberof RestartProcessInstanceDto
     */
    'skipIoMappings'?: boolean | null;
    /**
     * Set the initial set of variables during restart. By default, the last set of variables is used.
     * @type {boolean}
     * @memberof RestartProcessInstanceDto
     */
    'initialVariables'?: boolean | null;
    /**
     * Do not take over the business key of the historic process instance.
     * @type {boolean}
     * @memberof RestartProcessInstanceDto
     */
    'withoutBusinessKey'?: boolean | null;
    /**
     * **Optional**. A JSON array of instructions that specify which activities to start the process instance at. If this property is omitted, the process instance starts at its default blank start event.
     * @type {Array<RestartProcessInstanceModificationInstructionDto>}
     * @memberof RestartProcessInstanceDto
     */
    'instructions'?: Array<RestartProcessInstanceModificationInstructionDto>;
}
/**
 * 
 * @export
 * @interface RestartProcessInstanceModificationInstructionDto
 */
export interface RestartProcessInstanceModificationInstructionDto {
    /**
     * **Mandatory**. One of the following values: `startBeforeActivity`, `startAfterActivity`, `startTransition`.  * A `startBeforeActivity` instruction requests to enter a given activity. * A `startAfterActivity` instruction requests to execute the single outgoing sequence flow of a given activity. * A `startTransition` instruction requests to execute a specific sequence flow.
     * @type {string}
     * @memberof RestartProcessInstanceModificationInstructionDto
     */
    'type': RestartProcessInstanceModificationInstructionDtoTypeEnum;
    /**
     * **Can be used with instructions of types** `startBeforeActivity` and `startAfterActivity`. Specifies the sequence flow to start.
     * @type {string}
     * @memberof RestartProcessInstanceModificationInstructionDto
     */
    'activityId'?: string;
    /**
     * **Can be used with instructions of types** `startTransition`. Specifies the sequence flow to start.
     * @type {string}
     * @memberof RestartProcessInstanceModificationInstructionDto
     */
    'transitionId'?: string;
}

export const RestartProcessInstanceModificationInstructionDtoTypeEnum = {
    StartBeforeActivity: 'startBeforeActivity',
    StartAfterActivity: 'startAfterActivity',
    StartTransition: 'startTransition'
} as const;

export type RestartProcessInstanceModificationInstructionDtoTypeEnum = typeof RestartProcessInstanceModificationInstructionDtoTypeEnum[keyof typeof RestartProcessInstanceModificationInstructionDtoTypeEnum];

/**
 * 
 * @export
 * @interface RetriesDto
 */
export interface RetriesDto {
    /**
     * The number of retries to set for the resource.  Must be >= 0. If this is 0, an incident is created and the task, or job, cannot be fetched, or acquired anymore unless the retries are increased again. Can not be null.
     * @type {number}
     * @memberof RetriesDto
     */
    'retries'?: number | null;
}
/**
 * 
 * @export
 * @interface SchemaLogEntryDto
 */
export interface SchemaLogEntryDto {
    /**
     * The id of the schema log entry.
     * @type {string}
     * @memberof SchemaLogEntryDto
     */
    'id'?: string;
    /**
     * The date and time of the schema update.
     * @type {string}
     * @memberof SchemaLogEntryDto
     */
    'timestamp'?: string;
    /**
     * The version of the schema.
     * @type {string}
     * @memberof SchemaLogEntryDto
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface SchemaLogQueryDto
 */
export interface SchemaLogQueryDto {
    /**
     * The version of the schema.
     * @type {string}
     * @memberof SchemaLogQueryDto
     */
    'version'?: string;
    /**
     * A JSON array of criteria to sort the result by. Each element of the array is                       a JSON object that specifies one ordering. The position in the array                       identifies the rank of an ordering, i.e., whether it is primary, secondary,                       etc. 
     * @type {Array<SchemaLogQueryDtoSorting>}
     * @memberof SchemaLogQueryDto
     */
    'sorting'?: Array<SchemaLogQueryDtoSorting>;
}
/**
 * 
 * @export
 * @interface SchemaLogQueryDtoSorting
 */
export interface SchemaLogQueryDtoSorting {
    /**
     * Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @type {string}
     * @memberof SchemaLogQueryDtoSorting
     */
    'sortBy'?: SchemaLogQueryDtoSortingSortByEnum;
    /**
     * Sort the results in a given order. Values may be `asc` for ascending order or `desc` for descending order. Must be used in conjunction with the sortBy parameter.
     * @type {string}
     * @memberof SchemaLogQueryDtoSorting
     */
    'sortOrder'?: SchemaLogQueryDtoSortingSortOrderEnum;
}

export const SchemaLogQueryDtoSortingSortByEnum = {
    Timestamp: 'timestamp'
} as const;

export type SchemaLogQueryDtoSortingSortByEnum = typeof SchemaLogQueryDtoSortingSortByEnum[keyof typeof SchemaLogQueryDtoSortingSortByEnum];
export const SchemaLogQueryDtoSortingSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type SchemaLogQueryDtoSortingSortOrderEnum = typeof SchemaLogQueryDtoSortingSortOrderEnum[keyof typeof SchemaLogQueryDtoSortingSortOrderEnum];

/**
 * 
 * @export
 * @interface SetJobRetriesByProcessDto
 */
export interface SetJobRetriesByProcessDto {
    /**
     * A list of process instance ids to fetch jobs, for which retries will be set.
     * @type {Array<string>}
     * @memberof SetJobRetriesByProcessDto
     */
    'processInstances'?: Array<string>;
    /**
     * An integer representing the number of retries. Please note that the value cannot be negative or null.
     * @type {number}
     * @memberof SetJobRetriesByProcessDto
     */
    'retries'?: number | null;
    /**
     * 
     * @type {ProcessInstanceQueryDto}
     * @memberof SetJobRetriesByProcessDto
     */
    'processInstanceQuery'?: ProcessInstanceQueryDto;
    /**
     * 
     * @type {HistoricProcessInstanceQueryDto}
     * @memberof SetJobRetriesByProcessDto
     */
    'historicProcessInstanceQuery'?: HistoricProcessInstanceQueryDto;
}
/**
 * 
 * @export
 * @interface SetRetriesForExternalTasksDto
 */
export interface SetRetriesForExternalTasksDto {
    /**
     * The number of retries to set for the external task.  Must be >= 0. If this is 0, an incident is created and the task cannot be fetched anymore unless the retries are increased again. Can not be null.
     * @type {number}
     * @memberof SetRetriesForExternalTasksDto
     */
    'retries'?: number | null;
    /**
     * The ids of the external tasks to set the number of retries for.
     * @type {Array<string>}
     * @memberof SetRetriesForExternalTasksDto
     */
    'externalTaskIds'?: Array<string>;
    /**
     * The ids of process instances containing the tasks to set the number of retries for.
     * @type {Array<string>}
     * @memberof SetRetriesForExternalTasksDto
     */
    'processInstanceIds'?: Array<string>;
    /**
     * 
     * @type {ExternalTaskQueryDto}
     * @memberof SetRetriesForExternalTasksDto
     */
    'externalTaskQuery'?: ExternalTaskQueryDto;
    /**
     * 
     * @type {ProcessInstanceQueryDto}
     * @memberof SetRetriesForExternalTasksDto
     */
    'processInstanceQuery'?: ProcessInstanceQueryDto;
    /**
     * 
     * @type {HistoricProcessInstanceQueryDto}
     * @memberof SetRetriesForExternalTasksDto
     */
    'historicProcessInstanceQuery'?: HistoricProcessInstanceQueryDto;
}
/**
 * 
 * @export
 * @interface SignalDto
 */
export interface SignalDto {
    /**
     * The name of the signal to deliver.  **Note**: This property is mandatory.
     * @type {string}
     * @memberof SignalDto
     */
    'name'?: string;
    /**
     * Optionally specifies a single execution which is notified by the signal.  **Note**: If no execution id is defined the signal is broadcasted to all subscribed handlers. 
     * @type {string}
     * @memberof SignalDto
     */
    'executionId'?: string;
    /**
     * A JSON object containing variable key-value pairs. Each key is a variable name and each value a JSON variable value object.
     * @type {{ [key: string]: VariableValueDto; }}
     * @memberof SignalDto
     */
    'variables'?: { [key: string]: VariableValueDto; };
    /**
     * Specifies a tenant to deliver the signal. The signal can only be received on executions or process definitions which belongs to the given tenant.  **Note**: Cannot be used in combination with executionId.
     * @type {string}
     * @memberof SignalDto
     */
    'tenantId'?: string;
    /**
     * If true the signal can only be received on executions or process definitions which belongs to no tenant. Value may not be false as this is the default behavior.  **Note**: Cannot be used in combination with `executionId`.
     * @type {boolean}
     * @memberof SignalDto
     */
    'withoutTenantId'?: boolean | null;
}
/**
 * Mandatory when `sortBy` is one of the following values: `processVariable`, `executionVariable`, `taskVariable`, `caseExecutionVariable` or `caseInstanceVariable`. Must be a JSON object with the properties `variable` and `type` where `variable` is a variable name and `type` is the name of a variable value type.
 * @export
 * @interface SortTaskQueryParametersDto
 */
export interface SortTaskQueryParametersDto {
    /**
     * The name of the variable to sort by.
     * @type {string}
     * @memberof SortTaskQueryParametersDto
     */
    'variable'?: string;
    /**
     * The name of the type of the variable value.
     * @type {string}
     * @memberof SortTaskQueryParametersDto
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface StartProcessInstanceDto
 */
export interface StartProcessInstanceDto {
    /**
     * The business key of the process instance.
     * @type {string}
     * @memberof StartProcessInstanceDto
     */
    'businessKey'?: string;
    /**
     * 
     * @type {{ [key: string]: VariableValueDto; }}
     * @memberof StartProcessInstanceDto
     */
    'variables'?: { [key: string]: VariableValueDto; };
    /**
     * The case instance id the process instance is to be initialized with.
     * @type {string}
     * @memberof StartProcessInstanceDto
     */
    'caseInstanceId'?: string;
    /**
     * **Optional**. A JSON array of instructions that specify which activities to start the process instance at. If this property is omitted, the process instance starts at its default blank start event.
     * @type {Array<ProcessInstanceModificationInstructionDto>}
     * @memberof StartProcessInstanceDto
     */
    'startInstructions'?: Array<ProcessInstanceModificationInstructionDto>;
    /**
     * Skip execution listener invocation for activities that are started or ended as part of this request. **Note**: This option is currently only respected when start instructions are submitted via the `startInstructions` property.
     * @type {boolean}
     * @memberof StartProcessInstanceDto
     */
    'skipCustomListeners'?: boolean | null;
    /**
     * Skip execution of [input/output variable mappings](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/#input-output-variable-mapping) for activities that are started or ended as part of this request. **Note**: This option is currently only respected when start instructions are submitted via the `startInstructions` property.
     * @type {boolean}
     * @memberof StartProcessInstanceDto
     */
    'skipIoMappings'?: boolean | null;
    /**
     * Indicates if the variables, which was used by the process instance during execution, should be returned. Default value: `false`
     * @type {boolean}
     * @memberof StartProcessInstanceDto
     */
    'withVariablesInReturn'?: boolean | null;
}
/**
 * 
 * @export
 * @interface StartProcessInstanceFormDto
 */
export interface StartProcessInstanceFormDto {
    /**
     * 
     * @type {{ [key: string]: VariableValueDto; }}
     * @memberof StartProcessInstanceFormDto
     */
    'variables'?: { [key: string]: VariableValueDto; };
    /**
     * The business key the process instance is to be initialized with. The business key uniquely identifies the process instance in the context of the given process definition.
     * @type {string}
     * @memberof StartProcessInstanceFormDto
     */
    'businessKey'?: string;
}
/**
 * 
 * @export
 * @interface SuspensionStateDto
 */
export interface SuspensionStateDto {
    /**
     * A Boolean value which indicates whether to activate or suspend a given process instance. When the value is set to true, the given process instance will be suspended and when the value is set to false, the given process instance will be activated.
     * @type {boolean}
     * @memberof SuspensionStateDto
     */
    'suspended'?: boolean;
}
/**
 * 
 * @export
 * @interface TaskBpmnErrorDto
 */
export interface TaskBpmnErrorDto {
    /**
     * An error code that indicates the predefined error. It is used to identify the BPMN error handler.
     * @type {string}
     * @memberof TaskBpmnErrorDto
     */
    'errorCode'?: string;
    /**
     * An error message that describes the error.
     * @type {string}
     * @memberof TaskBpmnErrorDto
     */
    'errorMessage'?: string;
    /**
     * A JSON object containing variable key-value pairs.
     * @type {{ [key: string]: VariableValueDto; }}
     * @memberof TaskBpmnErrorDto
     */
    'variables'?: { [key: string]: VariableValueDto; };
}
/**
 * 
 * @export
 * @interface TaskDto
 */
export interface TaskDto {
    /**
     * The task id.
     * @type {string}
     * @memberof TaskDto
     */
    'id'?: string;
    /**
     * The task name.
     * @type {string}
     * @memberof TaskDto
     */
    'name'?: string;
    /**
     * The assignee\'s id.
     * @type {string}
     * @memberof TaskDto
     */
    'assignee'?: string;
    /**
     * The owner\'s id.
     * @type {string}
     * @memberof TaskDto
     */
    'owner'?: string;
    /**
     * The date the task was created on. [Default format](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/) `yyyy-MM-dd\'T\'HH:mm:ss.SSSZ`.
     * @type {string}
     * @memberof TaskDto
     */
    'created'?: string;
    /**
     * The task\'s due date. [Default format](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/) `yyyy-MM-dd\'T\'HH:mm:ss.SSSZ`.
     * @type {string}
     * @memberof TaskDto
     */
    'due'?: string | null;
    /**
     * The follow-up date for the task. [Default format](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/) `yyyy-MM-dd\'T\'HH:mm:ss.SSSZ`.
     * @type {string}
     * @memberof TaskDto
     */
    'followUp'?: string | null;
    /**
     * The task\'s delegation state. Possible values are `PENDING` and `RESOLVED`.
     * @type {string}
     * @memberof TaskDto
     */
    'delegationState'?: TaskDtoDelegationStateEnum;
    /**
     * The task\'s description.
     * @type {string}
     * @memberof TaskDto
     */
    'description'?: string;
    /**
     * The id of the execution the task belongs to.
     * @type {string}
     * @memberof TaskDto
     */
    'executionId'?: string;
    /**
     * The id the parent task, if this task is a subtask.
     * @type {string}
     * @memberof TaskDto
     */
    'parentTaskId'?: string;
    /**
     * The task\'s priority.
     * @type {number}
     * @memberof TaskDto
     */
    'priority'?: number | null;
    /**
     * The id of the process definition the task belongs to.
     * @type {string}
     * @memberof TaskDto
     */
    'processDefinitionId'?: string;
    /**
     * The id of the process instance the task belongs to.
     * @type {string}
     * @memberof TaskDto
     */
    'processInstanceId'?: string;
    /**
     * The id of the case execution the task belongs to.
     * @type {string}
     * @memberof TaskDto
     */
    'caseExecutionId'?: string;
    /**
     * The id of the case definition the task belongs to.
     * @type {string}
     * @memberof TaskDto
     */
    'caseDefinitionId'?: string;
    /**
     * The id of the case instance the task belongs to.
     * @type {string}
     * @memberof TaskDto
     */
    'caseInstanceId'?: string;
    /**
     * The task\'s key.
     * @type {string}
     * @memberof TaskDto
     */
    'taskDefinitionKey'?: string;
    /**
     * Whether the task belongs to a process instance that is suspended.
     * @type {boolean}
     * @memberof TaskDto
     */
    'suspended'?: boolean | null;
    /**
     * If not `null`, the form key for the task.
     * @type {string}
     * @memberof TaskDto
     */
    'formKey'?: string;
    /**
     * If not `null`, the tenant id of the task.
     * @type {string}
     * @memberof TaskDto
     */
    'tenantId'?: string;
}

export const TaskDtoDelegationStateEnum = {
    Pending: 'PENDING',
    Resolved: 'RESOLVED'
} as const;

export type TaskDtoDelegationStateEnum = typeof TaskDtoDelegationStateEnum[keyof typeof TaskDtoDelegationStateEnum];

/**
 * 
 * @export
 * @interface TaskEscalationDto
 */
export interface TaskEscalationDto {
    /**
     * An escalation code that indicates the predefined escalation. It is used to identify the BPMN escalation handler.
     * @type {string}
     * @memberof TaskEscalationDto
     */
    'escalationCode'?: string;
    /**
     * A JSON object containing variable key-value pairs.
     * @type {{ [key: string]: VariableValueDto; }}
     * @memberof TaskEscalationDto
     */
    'variables'?: { [key: string]: VariableValueDto; };
}
/**
 * A Task query which defines a group of Tasks.
 * @export
 * @interface TaskQueryDto
 */
export interface TaskQueryDto {
    /**
     * Restrict to tasks that belong to process instances with the given id.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'processInstanceId'?: string;
    /**
     * Restrict to tasks that belong to process instances with the given ids.
     * @type {Array<string>}
     * @memberof TaskQueryDto
     */
    'processInstanceIdIn'?: Array<string>;
    /**
     * Restrict to tasks that belong to process instances with the given business key.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'processInstanceBusinessKey'?: string;
    /**
     * Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'processInstanceBusinessKeyExpression'?: string;
    /**
     * Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
     * @type {Array<string>}
     * @memberof TaskQueryDto
     */
    'processInstanceBusinessKeyIn'?: Array<string>;
    /**
     * Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'processInstanceBusinessKeyLike'?: string;
    /**
     * Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'processInstanceBusinessKeyLikeExpression'?: string;
    /**
     * Restrict to tasks that belong to a process definition with the given id.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'processDefinitionId'?: string;
    /**
     * Restrict to tasks that belong to a process definition with the given key.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'processDefinitionKey'?: string;
    /**
     * Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
     * @type {Array<string>}
     * @memberof TaskQueryDto
     */
    'processDefinitionKeyIn'?: Array<string>;
    /**
     * Restrict to tasks that belong to a process definition with the given name.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'processDefinitionName'?: string;
    /**
     * Restrict to tasks that have a process definition name that has the parameter value as  a substring.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'processDefinitionNameLike'?: string;
    /**
     * Restrict to tasks that belong to an execution with the given id.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'executionId'?: string;
    /**
     * Restrict to tasks that belong to case instances with the given id.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'caseInstanceId'?: string;
    /**
     * Restrict to tasks that belong to case instances with the given business key.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'caseInstanceBusinessKey'?: string;
    /**
     * Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'caseInstanceBusinessKeyLike'?: string;
    /**
     * Restrict to tasks that belong to a case definition with the given id.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'caseDefinitionId'?: string;
    /**
     * Restrict to tasks that belong to a case definition with the given key.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'caseDefinitionKey'?: string;
    /**
     * Restrict to tasks that belong to a case definition with the given name.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'caseDefinitionName'?: string;
    /**
     * Restrict to tasks that have a case definition name that has the parameter value as a  substring.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'caseDefinitionNameLike'?: string;
    /**
     * Restrict to tasks that belong to a case execution with the given id.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'caseExecutionId'?: string;
    /**
     * Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
     * @type {Array<string>}
     * @memberof TaskQueryDto
     */
    'activityInstanceIdIn'?: Array<string>;
    /**
     * Only include tasks which belong to one of the passed and comma-separated  tenant ids.
     * @type {Array<string>}
     * @memberof TaskQueryDto
     */
    'tenantIdIn'?: Array<string>;
    /**
     * Only include tasks which belong to no tenant. Value may only be `true`,  as `false` is the default behavior.
     * @type {boolean}
     * @memberof TaskQueryDto
     */
    'withoutTenantId'?: boolean | null;
    /**
     * Restrict to tasks that the given user is assigned to.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'assignee'?: string;
    /**
     * Restrict to tasks that the user described by the given expression is assigned to. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'assigneeExpression'?: string;
    /**
     * Restrict to tasks that have an assignee that has the parameter  value as a substring.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'assigneeLike'?: string;
    /**
     * Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'assigneeLikeExpression'?: string;
    /**
     * Only include tasks which are assigned to one of the passed and comma-separated user ids.
     * @type {Array<string>}
     * @memberof TaskQueryDto
     */
    'assigneeIn'?: Array<string>;
    /**
     * Restrict to tasks that the given user owns.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'owner'?: string;
    /**
     * Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'ownerExpression'?: string;
    /**
     * Only include tasks that are offered to the given group.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'candidateGroup'?: string;
    /**
     * Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'candidateGroupExpression'?: string;
    /**
     * Only include tasks that are offered to the given user or to one of his groups.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'candidateUser'?: string;
    /**
     * Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'candidateUserExpression'?: string;
    /**
     * Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
     * @type {boolean}
     * @memberof TaskQueryDto
     */
    'includeAssignedTasks'?: boolean | null;
    /**
     * Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
     * @type {string}
     * @memberof TaskQueryDto
     */
    'involvedUser'?: string;
    /**
     * Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'involvedUserExpression'?: string;
    /**
     * If set to `true`, restricts the query to all tasks that are assigned.
     * @type {boolean}
     * @memberof TaskQueryDto
     */
    'assigned'?: boolean | null;
    /**
     * If set to `true`, restricts the query to all tasks that are unassigned.
     * @type {boolean}
     * @memberof TaskQueryDto
     */
    'unassigned'?: boolean | null;
    /**
     * Restrict to tasks that have the given key.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'taskDefinitionKey'?: string;
    /**
     * Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
     * @type {Array<string>}
     * @memberof TaskQueryDto
     */
    'taskDefinitionKeyIn'?: Array<string>;
    /**
     * Restrict to tasks that have a key that has the parameter value as a substring.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'taskDefinitionKeyLike'?: string;
    /**
     * Restrict to tasks that have the given name.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'name'?: string;
    /**
     * Restrict to tasks that do not have the given name.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'nameNotEqual'?: string;
    /**
     * Restrict to tasks that have a name with the given parameter value as substring.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'nameLike'?: string;
    /**
     * Restrict to tasks that do not have a name with the given parameter value as substring.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'nameNotLike'?: string;
    /**
     * Restrict to tasks that have the given description.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'description'?: string;
    /**
     * Restrict to tasks that have a description that has the parameter value as a substring.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'descriptionLike'?: string;
    /**
     * Restrict to tasks that have the given priority.
     * @type {number}
     * @memberof TaskQueryDto
     */
    'priority'?: number | null;
    /**
     * Restrict to tasks that have a lower or equal priority.
     * @type {number}
     * @memberof TaskQueryDto
     */
    'maxPriority'?: number | null;
    /**
     * Restrict to tasks that have a higher or equal priority.
     * @type {number}
     * @memberof TaskQueryDto
     */
    'minPriority'?: number | null;
    /**
     * Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format `yyyy-MM-dd\'T\'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.546+0200`.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'dueDate'?: string | null;
    /**
     * Restrict to tasks that are due on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a `java.util.Date` or `org.joda.time.DateTime` object.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'dueDateExpression'?: string;
    /**
     * Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format `yyyy-MM-dd\'T\'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.435+0200`.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'dueAfter'?: string | null;
    /**
     * Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a `java.util.Date` or `org.joda.time.DateTime` object.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'dueAfterExpression'?: string;
    /**
     * Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format `yyyy-MM-dd\'T\'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.243+0200`.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'dueBefore'?: string | null;
    /**
     * Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a `java.util.Date` or `org.joda.time.DateTime` object.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'dueBeforeExpression'?: string;
    /**
     * Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format `yyyy-MM-dd\'T\'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.342+0200`.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'followUpDate'?: string | null;
    /**
     * Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a `java.util.Date` or `org.joda.time.DateTime` object.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'followUpDateExpression'?: string;
    /**
     * Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format `yyyy-MM-dd\'T\'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.542+0200`.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'followUpAfter'?: string | null;
    /**
     * Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a `java.util.Date` or `org.joda.time.DateTime` object.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'followUpAfterExpression'?: string;
    /**
     * Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format `yyyy-MM-dd\'T\'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.234+0200`.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'followUpBefore'?: string;
    /**
     * Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a `java.util.Date` or `org.joda.time.DateTime` object.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'followUpBeforeExpression'?: string;
    /**
     * Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format `yyyy-MM-dd\'T\'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.432+0200`. The typical use case is to query all `active` tasks for a user for a given date.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'followUpBeforeOrNotExistent'?: string | null;
    /**
     * Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a `java.util.Date` or `org.joda.time.DateTime` object.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'followUpBeforeOrNotExistentExpression'?: string;
    /**
     * Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format `yyyy-MM-dd\'T\'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.324+0200`.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'createdOn'?: string | null;
    /**
     * Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a `java.util.Date` or `org.joda.time.DateTime` object.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'createdOnExpression'?: string;
    /**
     * Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format `yyyy-MM-dd\'T\'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.342+0200`.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'createdAfter'?: string | null;
    /**
     * Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a `java.util.Date` or `org.joda.time.DateTime` object.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'createdAfterExpression'?: string;
    /**
     * Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format `yyyy-MM-dd\'T\'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.332+0200`.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'createdBefore'?: string | null;
    /**
     * Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a `java.util.Date` or `org.joda.time.DateTime` object.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'createdBeforeExpression'?: string;
    /**
     * Restrict to tasks that are in the given delegation state. Valid values are `PENDING` and `RESOLVED`.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'delegationState'?: TaskQueryDtoDelegationStateEnum;
    /**
     * Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example `developers,support,sales`.
     * @type {Array<string>}
     * @memberof TaskQueryDto
     */
    'candidateGroups'?: Array<string>;
    /**
     * Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to `java.util.List` of Strings.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'candidateGroupsExpression'?: string;
    /**
     * Only include tasks which have a candidate group. Value may only be `true`, as `false` is the default behavior.
     * @type {boolean}
     * @memberof TaskQueryDto
     */
    'withCandidateGroups'?: boolean | null;
    /**
     * Only include tasks which have no candidate group. Value may only be `true`, as `false` is the default behavior.
     * @type {boolean}
     * @memberof TaskQueryDto
     */
    'withoutCandidateGroups'?: boolean | null;
    /**
     * Only include tasks which have a candidate user. Value may only be `true`, as `false` is the default behavior.
     * @type {boolean}
     * @memberof TaskQueryDto
     */
    'withCandidateUsers'?: boolean | null;
    /**
     * Only include tasks which have no candidate users. Value may only be `true`, as `false` is the default behavior.
     * @type {boolean}
     * @memberof TaskQueryDto
     */
    'withoutCandidateUsers'?: boolean | null;
    /**
     * Only include active tasks. Value may only be `true`, as `false` is the default behavior.
     * @type {boolean}
     * @memberof TaskQueryDto
     */
    'active'?: boolean | null;
    /**
     * Only include suspended tasks. Value may only be `true`, as `false` is the default behavior.
     * @type {boolean}
     * @memberof TaskQueryDto
     */
    'suspended'?: boolean | null;
    /**
     * A JSON array to only include tasks that have variables with certain values. The array consists of JSON objects with three properties `name`, `operator` and `value`. `name` is the variable name, `operator` is the comparison operator to be used and `value` the variable value. `value` may be of type `String`, `Number` or `Boolean`.  Valid `operator` values are: `eq` - equal to; `neq` - not equal to; `gt` - greater than; `gteq` - greater than or equal to; `lt` - lower than; `lteq` - lower than or equal to; `like`. `key` and `value` may not contain underscore or comma characters.
     * @type {Array<VariableQueryParameterDto>}
     * @memberof TaskQueryDto
     */
    'taskVariables'?: Array<VariableQueryParameterDto>;
    /**
     * A JSON array to only include tasks that belong to a process instance with variables with certain values. The array consists of JSON objects with three properties `name`, `operator` and `value`. `name` is the variable name, `operator` is the comparison operator to be used and `value` the variable value. `value` may be of type `String`, `Number` or `Boolean`.  Valid `operator` values are: `eq` - equal to; `neq` - not equal to; `gt` - greater than; `gteq` - greater than or equal to; `lt` - lower than; `lteq` - lower than or equal to; `like`. `key` and `value` may not contain underscore or comma characters.
     * @type {Array<VariableQueryParameterDto>}
     * @memberof TaskQueryDto
     */
    'processVariables'?: Array<VariableQueryParameterDto>;
    /**
     * A JSON array to only include tasks that belong to a case instance with variables with certain values. The array consists of JSON objects with three properties `name`, `operator` and `value`. `name` is the variable name, `operator` is the comparison operator to be used and `value` the variable value. `value` may be of type `String`, `Number` or `Boolean`.  Valid `operator` values are: `eq` - equal to; `neq` - not equal to; `gt` - greater than; `gteq` - greater than or equal to; `lt` - lower than; `lteq` - lower than or equal to; `like`. `key` and `value` may not contain underscore or comma characters.
     * @type {Array<VariableQueryParameterDto>}
     * @memberof TaskQueryDto
     */
    'caseInstanceVariables'?: Array<VariableQueryParameterDto>;
    /**
     * Match all variable names in this query case-insensitively. If set `variableName` and `variablename` are treated as equal.
     * @type {boolean}
     * @memberof TaskQueryDto
     */
    'variableNamesIgnoreCase'?: boolean | null;
    /**
     * Match all variable values in this query case-insensitively. If set `variableValue` and `variablevalue` are treated as equal.
     * @type {boolean}
     * @memberof TaskQueryDto
     */
    'variableValuesIgnoreCase'?: boolean | null;
    /**
     * Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
     * @type {string}
     * @memberof TaskQueryDto
     */
    'parentTaskId'?: string;
    /**
     * A JSON array of nested task queries with OR semantics. A task matches a nested query if it fulfills *at least one* of the query\'s predicates. With multiple nested queries, a task must fulfill at least one predicate of *each* query ([Conjunctive Normal Form](https://en.wikipedia.org/wiki/Conjunctive_normal_form)).  All task query properties can be used except for: `sorting`, `withCandidateGroups`, `withoutCandidateGroups`, `withCandidateUsers`, `withoutCandidateUsers`  See the [User guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-engine-api/#or-queries) for more information about OR queries.
     * @type {Array<TaskQueryDto>}
     * @memberof TaskQueryDto
     */
    'orQueries'?: Array<TaskQueryDto>;
    /**
     * Apply sorting of the result
     * @type {Array<TaskQueryDtoSorting>}
     * @memberof TaskQueryDto
     */
    'sorting'?: Array<TaskQueryDtoSorting>;
}

export const TaskQueryDtoDelegationStateEnum = {
    Pending: 'PENDING',
    Resolved: 'RESOLVED'
} as const;

export type TaskQueryDtoDelegationStateEnum = typeof TaskQueryDtoDelegationStateEnum[keyof typeof TaskQueryDtoDelegationStateEnum];

/**
 * 
 * @export
 * @interface TaskQueryDtoSorting
 */
export interface TaskQueryDtoSorting {
    /**
     * Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @type {string}
     * @memberof TaskQueryDtoSorting
     */
    'sortBy'?: TaskQueryDtoSortingSortByEnum;
    /**
     * Sort the results in a given order. Values may be `asc` for ascending order or `desc` for descending order. Must be used in conjunction with the sortBy parameter.
     * @type {string}
     * @memberof TaskQueryDtoSorting
     */
    'sortOrder'?: TaskQueryDtoSortingSortOrderEnum;
    /**
     * 
     * @type {SortTaskQueryParametersDto}
     * @memberof TaskQueryDtoSorting
     */
    'parameters'?: SortTaskQueryParametersDto;
}

export const TaskQueryDtoSortingSortByEnum = {
    InstanceId: 'instanceId',
    CaseInstanceId: 'caseInstanceId',
    DueDate: 'dueDate',
    ExecutionId: 'executionId',
    CaseExecutionId: 'caseExecutionId',
    Assignee: 'assignee',
    Created: 'created',
    Description: 'description',
    Id: 'id',
    Name: 'name',
    NameCaseInsensitive: 'nameCaseInsensitive',
    Priority: 'priority',
    ProcessVariable: 'processVariable',
    ExecutionVariable: 'executionVariable',
    TaskVariable: 'taskVariable',
    CaseExecutionVariable: 'caseExecutionVariable',
    CaseInstanceVariable: 'caseInstanceVariable'
} as const;

export type TaskQueryDtoSortingSortByEnum = typeof TaskQueryDtoSortingSortByEnum[keyof typeof TaskQueryDtoSortingSortByEnum];
export const TaskQueryDtoSortingSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type TaskQueryDtoSortingSortOrderEnum = typeof TaskQueryDtoSortingSortOrderEnum[keyof typeof TaskQueryDtoSortingSortOrderEnum];

/**
 * A JSON object corresponding to the Activity Instance tree of the given process instance.
 * @export
 * @interface TransitionInstanceDto
 */
export interface TransitionInstanceDto {
    /**
     * The id of the transition instance.
     * @type {string}
     * @memberof TransitionInstanceDto
     */
    'id'?: string;
    /**
     * The id of the parent activity instance, for example a sub process instance.
     * @type {string}
     * @memberof TransitionInstanceDto
     */
    'parentActivityInstanceId'?: string;
    /**
     * The id of the activity that this instance enters (asyncBefore job) or leaves (asyncAfter job)
     * @type {string}
     * @memberof TransitionInstanceDto
     */
    'activityId'?: string;
    /**
     * The name of the activity that this instance enters (asyncBefore job) or leaves (asyncAfter job)
     * @type {string}
     * @memberof TransitionInstanceDto
     */
    'activityName'?: string;
    /**
     * The type of the activity that this instance enters (asyncBefore job) or leaves (asyncAfter job)
     * @type {string}
     * @memberof TransitionInstanceDto
     */
    'activityType'?: string;
    /**
     * The id of the process instance this instance is part of.
     * @type {string}
     * @memberof TransitionInstanceDto
     */
    'processInstanceId'?: string;
    /**
     * The id of the process definition.
     * @type {string}
     * @memberof TransitionInstanceDto
     */
    'processDefinitionId'?: string;
    /**
     * The execution id.
     * @type {string}
     * @memberof TransitionInstanceDto
     */
    'executionId'?: string;
    /**
     * A list of incident ids.
     * @type {Array<string>}
     * @memberof TransitionInstanceDto
     */
    'incidentIds'?: Array<string>;
    /**
     * A list of JSON objects containing incident specific properties: * `id`: the id of the incident * `activityId`: the activity id in which the incident occurred
     * @type {Array<ActivityInstanceIncidentDto>}
     * @memberof TransitionInstanceDto
     */
    'incidents'?: Array<ActivityInstanceIncidentDto>;
}
/**
 * 
 * @export
 * @interface TriggerVariableValueDto
 */
export interface TriggerVariableValueDto {
    /**
     * Indicates whether the variable should be a local variable or not. If set to true, the variable becomes a local variable of the execution entering the target activity.
     * @type {boolean}
     * @memberof TriggerVariableValueDto
     */
    'local'?: boolean | null;
    /**
     * The variable\'s value. Value differs depending on the variable\'s type and on the deserializeValues parameter.
     * @type {object}
     * @memberof TriggerVariableValueDto
     */
    'value'?: object;
    /**
     * The value type of the variable.
     * @type {string}
     * @memberof TriggerVariableValueDto
     */
    'type'?: string;
    /**
     * A JSON object containing additional, value-type-dependent properties. For serialized variables of type Object, the following properties can be provided:  * `objectTypeName`: A string representation of the object\'s type name. * `serializationDataFormat`: The serialization format used to store the variable.  For serialized variables of type File, the following properties can be provided:  * `filename`: The name of the file. This is not the variable name but the name that will be used when downloading the file again. * `mimetype`: The MIME type of the file that is being uploaded. * `encoding`: The encoding of the file that is being uploaded.
     * @type {{ [key: string]: object; }}
     * @memberof TriggerVariableValueDto
     */
    'valueInfo'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface TriggerVariableValueDtoAllOf
 */
export interface TriggerVariableValueDtoAllOf {
    /**
     * Indicates whether the variable should be a local variable or not. If set to true, the variable becomes a local variable of the execution entering the target activity.
     * @type {boolean}
     * @memberof TriggerVariableValueDtoAllOf
     */
    'local'?: boolean | null;
}
/**
 * 
 * @export
 * @interface UserIdDto
 */
export interface UserIdDto {
    /**
     * The id of the user that the current action refers to.
     * @type {string}
     * @memberof UserIdDto
     */
    'userId'?: string;
}
/**
 * 
 * @export
 * @interface VariableQueryParameterDto
 */
export interface VariableQueryParameterDto {
    /**
     * The variable value, could be of type boolean, string or number
     * @type {object}
     * @memberof VariableQueryParameterDto
     */
    'value'?: object;
    /**
     * Comparison operator to be used
     * @type {string}
     * @memberof VariableQueryParameterDto
     */
    'operator'?: VariableQueryParameterDtoOperatorEnum;
}

export const VariableQueryParameterDtoOperatorEnum = {
    Eq: 'eq',
    Neq: 'neq',
    Gt: 'gt',
    Gteq: 'gteq',
    Lt: 'lt',
    Lteq: 'lteq',
    Like: 'like'
} as const;

export type VariableQueryParameterDtoOperatorEnum = typeof VariableQueryParameterDtoOperatorEnum[keyof typeof VariableQueryParameterDtoOperatorEnum];

/**
 * 
 * @export
 * @interface VariableValueDto
 */
export interface VariableValueDto {
    /**
     * The variable\'s value. Value differs depending on the variable\'s type and on the deserializeValues parameter.
     * @type {object}
     * @memberof VariableValueDto
     */
    'value'?: object;
    /**
     * The value type of the variable.
     * @type {string}
     * @memberof VariableValueDto
     */
    'type'?: string;
    /**
     * A JSON object containing additional, value-type-dependent properties. For serialized variables of type Object, the following properties can be provided:  * `objectTypeName`: A string representation of the object\'s type name. * `serializationDataFormat`: The serialization format used to store the variable.  For serialized variables of type File, the following properties can be provided:  * `filename`: The name of the file. This is not the variable name but the name that will be used when downloading the file again. * `mimetype`: The MIME type of the file that is being uploaded. * `encoding`: The encoding of the file that is being uploaded.
     * @type {{ [key: string]: object; }}
     * @memberof VariableValueDto
     */
    'valueInfo'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface VersionDto
 */
export interface VersionDto {
    /**
     * The version of the Rest API.
     * @type {string}
     * @memberof VersionDto
     */
    'version'?: string;
}

/**
 * ConditionApi - axios parameter creator
 * @export
 */
export const ConditionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Triggers evaluation of conditions for conditional start event(s).  Internally this maps to the engines condition evaluation builder method ConditionEvaluationBuilder#evaluateStartConditions().  For more information see the [Conditional Start Events](https://docs.camunda.org/manual/7.13/reference/bpmn20/events/conditional-events/#conditional-start-event) section of the [BPMN 2.0 Implementation Reference](https://docs.camunda.org/manual/7.13/reference/bpmn20/).
         * @param {EvaluationConditionDto} [evaluationConditionDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluateCondition: async (evaluationConditionDto?: EvaluationConditionDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/condition`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(evaluationConditionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConditionApi - functional programming interface
 * @export
 */
export const ConditionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConditionApiAxiosParamCreator(configuration)
    return {
        /**
         * Triggers evaluation of conditions for conditional start event(s).  Internally this maps to the engines condition evaluation builder method ConditionEvaluationBuilder#evaluateStartConditions().  For more information see the [Conditional Start Events](https://docs.camunda.org/manual/7.13/reference/bpmn20/events/conditional-events/#conditional-start-event) section of the [BPMN 2.0 Implementation Reference](https://docs.camunda.org/manual/7.13/reference/bpmn20/).
         * @param {EvaluationConditionDto} [evaluationConditionDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluateCondition(evaluationConditionDto?: EvaluationConditionDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProcessInstanceDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluateCondition(evaluationConditionDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConditionApi - factory interface
 * @export
 */
export const ConditionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConditionApiFp(configuration)
    return {
        /**
         * Triggers evaluation of conditions for conditional start event(s).  Internally this maps to the engines condition evaluation builder method ConditionEvaluationBuilder#evaluateStartConditions().  For more information see the [Conditional Start Events](https://docs.camunda.org/manual/7.13/reference/bpmn20/events/conditional-events/#conditional-start-event) section of the [BPMN 2.0 Implementation Reference](https://docs.camunda.org/manual/7.13/reference/bpmn20/).
         * @param {EvaluationConditionDto} [evaluationConditionDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluateCondition(evaluationConditionDto?: EvaluationConditionDto, options?: any): AxiosPromise<Array<ProcessInstanceDto>> {
            return localVarFp.evaluateCondition(evaluationConditionDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConditionApi - object-oriented interface
 * @export
 * @class ConditionApi
 * @extends {BaseAPI}
 */
export class ConditionApi extends BaseAPI {
    /**
     * Triggers evaluation of conditions for conditional start event(s).  Internally this maps to the engines condition evaluation builder method ConditionEvaluationBuilder#evaluateStartConditions().  For more information see the [Conditional Start Events](https://docs.camunda.org/manual/7.13/reference/bpmn20/events/conditional-events/#conditional-start-event) section of the [BPMN 2.0 Implementation Reference](https://docs.camunda.org/manual/7.13/reference/bpmn20/).
     * @param {EvaluationConditionDto} [evaluationConditionDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConditionApi
     */
    public evaluateCondition(evaluationConditionDto?: EvaluationConditionDto, options?: AxiosRequestConfig) {
        return ConditionApiFp(this.configuration).evaluateCondition(evaluationConditionDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeploymentApi - axios parameter creator
 * @export
 */
export const DeploymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a deployment.  **Security Consideration**  Deployments can contain custom code in form of scripts or EL expressions to customize process behavior. This may be abused for remote execution of arbitrary code.
         * @param {string} [tenantId] The tenant id for the deployment to be created.
         * @param {string} [deploymentSource] The source for the deployment to be created.
         * @param {boolean} [deployChangedOnly] A flag indicating whether the process engine should perform duplicate checking on a per-resource basis. If set to true, only those resources that have actually changed are deployed. Checks are made against resources included previous deployments of the same name and only against the latest versions of those resources. If set to true, the option enable-duplicate-filtering is overridden and set to true.
         * @param {boolean} [enableDuplicateFiltering] A flag indicating whether the process engine should perform duplicate checking for the deployment or not. This allows you to check if a deployment with the same name and the same resouces already exists and if true, not create a new deployment but instead return the existing deployment. The default value is false.
         * @param {string} [deploymentName] The name for the deployment to be created.
         * @param {any} [data] The binary data to create the deployment resource. It is possible to have more than one form part with different form part names for the binary data to create a deployment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeployment: async (tenantId?: string, deploymentSource?: string, deployChangedOnly?: boolean, enableDuplicateFiltering?: boolean, deploymentName?: string, data?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/deployment/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (tenantId !== undefined) { 
                localVarFormParams.append('tenant-id', tenantId as any);
            }
    
            if (deploymentSource !== undefined) { 
                localVarFormParams.append('deployment-source', deploymentSource as any);
            }
    
            if (deployChangedOnly !== undefined) { 
                localVarFormParams.append('deploy-changed-only', deployChangedOnly as any);
            }
    
            if (enableDuplicateFiltering !== undefined) { 
                localVarFormParams.append('enable-duplicate-filtering', enableDuplicateFiltering as any);
            }
    
            if (deploymentName !== undefined) { 
                localVarFormParams.append('deployment-name', deploymentName as any);
            }
    
            if (data !== undefined) { 
                localVarFormParams.append('data', data as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a deployment by id.
         * @param {string} id The id of the deployment to be deleted.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this deployment should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] &#x60;true&#x60;, if all input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeployment: async (id: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDeployment', 'id', id)
            const localVarPath = `/deployment/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cascade !== undefined) {
                localVarQueryParameter['cascade'] = cascade;
            }

            if (skipCustomListeners !== undefined) {
                localVarQueryParameter['skipCustomListeners'] = skipCustomListeners;
            }

            if (skipIoMappings !== undefined) {
                localVarQueryParameter['skipIoMappings'] = skipIoMappings;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a deployment by id, according to the `Deployment` interface of the engine.
         * @param {string} id The id of the deployment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployment: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDeployment', 'id', id)
            const localVarPath = `/deployment/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a deployment resource by resource id for the given deployment.
         * @param {string} id The id of the deployment
         * @param {string} resourceId The id of the deployment resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentResource: async (id: string, resourceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDeploymentResource', 'id', id)
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('getDeploymentResource', 'resourceId', resourceId)
            const localVarPath = `/deployment/{id}/resources/{resourceId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"resourceId"}}`, encodeURIComponent(String(resourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the binary content of a deployment resource for the given deployment by id.
         * @param {string} id The id of the deployment.
         * @param {string} resourceId The id of the deployment resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentResourceData: async (id: string, resourceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDeploymentResourceData', 'id', id)
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('getDeploymentResourceData', 'resourceId', resourceId)
            const localVarPath = `/deployment/{id}/resources/{resourceId}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"resourceId"}}`, encodeURIComponent(String(resourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all deployment resources of a given deployment.
         * @param {string} id The id of the deployment to retrieve the deployment resources for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentResources: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDeploymentResources', 'id', id)
            const localVarPath = `/deployment/{id}/resources`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for deployments that fulfill given parameters. Parameters may be the properties of deployments, such as the id or name or a range of the deployment time. The size of the result set can be retrieved by using the [Get Deployment count](https://docs.camunda.org/manual/7.13/reference/rest/deployment/get-query-count/) method.
         * @param {string} [id] Filter by deployment id
         * @param {string} [name] Filter by the deployment name. Exact match.
         * @param {string} [nameLike] Filter by the deployment name that the parameter is a substring of. The parameter can include the wildcard &#x60;%&#x60; to express like-strategy such as: starts with (&#x60;%&#x60;name), ends with (name&#x60;%&#x60;) or contains (&#x60;%&#x60;name&#x60;%&#x60;).
         * @param {string} [source] Filter by the deployment source.
         * @param {boolean} [withoutSource] Filter by the deployment source whereby source is equal to &#x60;null&#x60;.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A deployment must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include deployments which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeDeploymentsWithoutTenantId] Include deployments which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [after] Restricts to all deployments after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [before] Restricts to all deployments before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployments: async (id?: string, name?: string, nameLike?: string, source?: string, withoutSource?: boolean, tenantIdIn?: string, withoutTenantId?: boolean, includeDeploymentsWithoutTenantId?: boolean, after?: string, before?: string, sortBy?: string, sortOrder?: 'asc' | 'desc', firstResult?: number, maxResults?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/deployment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameLike !== undefined) {
                localVarQueryParameter['nameLike'] = nameLike;
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (withoutSource !== undefined) {
                localVarQueryParameter['withoutSource'] = withoutSource;
            }

            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }

            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }

            if (includeDeploymentsWithoutTenantId !== undefined) {
                localVarQueryParameter['includeDeploymentsWithoutTenantId'] = includeDeploymentsWithoutTenantId;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = (after as any instanceof Date) ?
                    (after as any).toISOString() :
                    after;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for the number of deployments that fulfill given parameters. Takes the same parameters as the [Get Deployments](https://docs.camunda.org/manual/7.13/reference/rest/deployment/get-query/) method.
         * @param {string} [id] Filter by deployment id
         * @param {string} [name] Filter by the deployment name. Exact match.
         * @param {string} [nameLike] Filter by the deployment name that the parameter is a substring of. The parameter can include the wildcard &#x60;%&#x60; to express like-strategy such as: starts with (&#x60;%&#x60;name), ends with (name&#x60;%&#x60;) or contains (&#x60;%&#x60;name&#x60;%&#x60;).
         * @param {string} [source] Filter by the deployment source.
         * @param {boolean} [withoutSource] Filter by the deployment source whereby source is equal to &#x60;null&#x60;.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A deployment must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include deployments which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeDeploymentsWithoutTenantId] Include deployments which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [after] Restricts to all deployments after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [before] Restricts to all deployments before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentsCount: async (id?: string, name?: string, nameLike?: string, source?: string, withoutSource?: boolean, tenantIdIn?: string, withoutTenantId?: boolean, includeDeploymentsWithoutTenantId?: boolean, after?: string, before?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/deployment/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameLike !== undefined) {
                localVarQueryParameter['nameLike'] = nameLike;
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (withoutSource !== undefined) {
                localVarQueryParameter['withoutSource'] = withoutSource;
            }

            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }

            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }

            if (includeDeploymentsWithoutTenantId !== undefined) {
                localVarQueryParameter['includeDeploymentsWithoutTenantId'] = includeDeploymentsWithoutTenantId;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = (after as any instanceof Date) ?
                    (after as any).toISOString() :
                    after;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Re-deploys an existing deployment.  The deployment resources to re-deploy can be restricted by using the properties `resourceIds` or `resourceNames`. If no deployment resources to re-deploy are passed then all existing resources of the given deployment are re-deployed.  **Warning**: Deployments can contain custom code in form of scripts or EL expressions to customize process behavior. This may be abused for remote execution of arbitrary code. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) in the user guide for details.
         * @param {string} id The id of the deployment to re-deploy.
         * @param {RedeploymentDto} [redeploymentDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeploy: async (id: string, redeploymentDto?: RedeploymentDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('redeploy', 'id', id)
            const localVarPath = `/deployment/{id}/redeploy`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(redeploymentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeploymentApi - functional programming interface
 * @export
 */
export const DeploymentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeploymentApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a deployment.  **Security Consideration**  Deployments can contain custom code in form of scripts or EL expressions to customize process behavior. This may be abused for remote execution of arbitrary code.
         * @param {string} [tenantId] The tenant id for the deployment to be created.
         * @param {string} [deploymentSource] The source for the deployment to be created.
         * @param {boolean} [deployChangedOnly] A flag indicating whether the process engine should perform duplicate checking on a per-resource basis. If set to true, only those resources that have actually changed are deployed. Checks are made against resources included previous deployments of the same name and only against the latest versions of those resources. If set to true, the option enable-duplicate-filtering is overridden and set to true.
         * @param {boolean} [enableDuplicateFiltering] A flag indicating whether the process engine should perform duplicate checking for the deployment or not. This allows you to check if a deployment with the same name and the same resouces already exists and if true, not create a new deployment but instead return the existing deployment. The default value is false.
         * @param {string} [deploymentName] The name for the deployment to be created.
         * @param {any} [data] The binary data to create the deployment resource. It is possible to have more than one form part with different form part names for the binary data to create a deployment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDeployment(tenantId?: string, deploymentSource?: string, deployChangedOnly?: boolean, enableDuplicateFiltering?: boolean, deploymentName?: string, data?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentWithDefinitionsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDeployment(tenantId, deploymentSource, deployChangedOnly, enableDuplicateFiltering, deploymentName, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a deployment by id.
         * @param {string} id The id of the deployment to be deleted.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this deployment should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] &#x60;true&#x60;, if all input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDeployment(id: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeployment(id, cascade, skipCustomListeners, skipIoMappings, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a deployment by id, according to the `Deployment` interface of the engine.
         * @param {string} id The id of the deployment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeployment(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeploymentDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeployment(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a deployment resource by resource id for the given deployment.
         * @param {string} id The id of the deployment
         * @param {string} resourceId The id of the deployment resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeploymentResource(id: string, resourceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentResourceDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeploymentResource(id, resourceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the binary content of a deployment resource for the given deployment by id.
         * @param {string} id The id of the deployment.
         * @param {string} resourceId The id of the deployment resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeploymentResourceData(id: string, resourceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeploymentResourceData(id, resourceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves all deployment resources of a given deployment.
         * @param {string} id The id of the deployment to retrieve the deployment resources for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeploymentResources(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeploymentResourceDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeploymentResources(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Queries for deployments that fulfill given parameters. Parameters may be the properties of deployments, such as the id or name or a range of the deployment time. The size of the result set can be retrieved by using the [Get Deployment count](https://docs.camunda.org/manual/7.13/reference/rest/deployment/get-query-count/) method.
         * @param {string} [id] Filter by deployment id
         * @param {string} [name] Filter by the deployment name. Exact match.
         * @param {string} [nameLike] Filter by the deployment name that the parameter is a substring of. The parameter can include the wildcard &#x60;%&#x60; to express like-strategy such as: starts with (&#x60;%&#x60;name), ends with (name&#x60;%&#x60;) or contains (&#x60;%&#x60;name&#x60;%&#x60;).
         * @param {string} [source] Filter by the deployment source.
         * @param {boolean} [withoutSource] Filter by the deployment source whereby source is equal to &#x60;null&#x60;.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A deployment must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include deployments which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeDeploymentsWithoutTenantId] Include deployments which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [after] Restricts to all deployments after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [before] Restricts to all deployments before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeployments(id?: string, name?: string, nameLike?: string, source?: string, withoutSource?: boolean, tenantIdIn?: string, withoutTenantId?: boolean, includeDeploymentsWithoutTenantId?: boolean, after?: string, before?: string, sortBy?: string, sortOrder?: 'asc' | 'desc', firstResult?: number, maxResults?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeploymentDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeployments(id, name, nameLike, source, withoutSource, tenantIdIn, withoutTenantId, includeDeploymentsWithoutTenantId, after, before, sortBy, sortOrder, firstResult, maxResults, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Queries for the number of deployments that fulfill given parameters. Takes the same parameters as the [Get Deployments](https://docs.camunda.org/manual/7.13/reference/rest/deployment/get-query/) method.
         * @param {string} [id] Filter by deployment id
         * @param {string} [name] Filter by the deployment name. Exact match.
         * @param {string} [nameLike] Filter by the deployment name that the parameter is a substring of. The parameter can include the wildcard &#x60;%&#x60; to express like-strategy such as: starts with (&#x60;%&#x60;name), ends with (name&#x60;%&#x60;) or contains (&#x60;%&#x60;name&#x60;%&#x60;).
         * @param {string} [source] Filter by the deployment source.
         * @param {boolean} [withoutSource] Filter by the deployment source whereby source is equal to &#x60;null&#x60;.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A deployment must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include deployments which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeDeploymentsWithoutTenantId] Include deployments which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [after] Restricts to all deployments after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [before] Restricts to all deployments before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeploymentsCount(id?: string, name?: string, nameLike?: string, source?: string, withoutSource?: boolean, tenantIdIn?: string, withoutTenantId?: boolean, includeDeploymentsWithoutTenantId?: boolean, after?: string, before?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeploymentsCount(id, name, nameLike, source, withoutSource, tenantIdIn, withoutTenantId, includeDeploymentsWithoutTenantId, after, before, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Re-deploys an existing deployment.  The deployment resources to re-deploy can be restricted by using the properties `resourceIds` or `resourceNames`. If no deployment resources to re-deploy are passed then all existing resources of the given deployment are re-deployed.  **Warning**: Deployments can contain custom code in form of scripts or EL expressions to customize process behavior. This may be abused for remote execution of arbitrary code. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) in the user guide for details.
         * @param {string} id The id of the deployment to re-deploy.
         * @param {RedeploymentDto} [redeploymentDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redeploy(id: string, redeploymentDto?: RedeploymentDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentWithDefinitionsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redeploy(id, redeploymentDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeploymentApi - factory interface
 * @export
 */
export const DeploymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeploymentApiFp(configuration)
    return {
        /**
         * Creates a deployment.  **Security Consideration**  Deployments can contain custom code in form of scripts or EL expressions to customize process behavior. This may be abused for remote execution of arbitrary code.
         * @param {string} [tenantId] The tenant id for the deployment to be created.
         * @param {string} [deploymentSource] The source for the deployment to be created.
         * @param {boolean} [deployChangedOnly] A flag indicating whether the process engine should perform duplicate checking on a per-resource basis. If set to true, only those resources that have actually changed are deployed. Checks are made against resources included previous deployments of the same name and only against the latest versions of those resources. If set to true, the option enable-duplicate-filtering is overridden and set to true.
         * @param {boolean} [enableDuplicateFiltering] A flag indicating whether the process engine should perform duplicate checking for the deployment or not. This allows you to check if a deployment with the same name and the same resouces already exists and if true, not create a new deployment but instead return the existing deployment. The default value is false.
         * @param {string} [deploymentName] The name for the deployment to be created.
         * @param {any} [data] The binary data to create the deployment resource. It is possible to have more than one form part with different form part names for the binary data to create a deployment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeployment(tenantId?: string, deploymentSource?: string, deployChangedOnly?: boolean, enableDuplicateFiltering?: boolean, deploymentName?: string, data?: any, options?: any): AxiosPromise<DeploymentWithDefinitionsDto> {
            return localVarFp.createDeployment(tenantId, deploymentSource, deployChangedOnly, enableDuplicateFiltering, deploymentName, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a deployment by id.
         * @param {string} id The id of the deployment to be deleted.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this deployment should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] &#x60;true&#x60;, if all input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeployment(id: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDeployment(id, cascade, skipCustomListeners, skipIoMappings, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a deployment by id, according to the `Deployment` interface of the engine.
         * @param {string} id The id of the deployment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployment(id: string, options?: any): AxiosPromise<Array<DeploymentDto>> {
            return localVarFp.getDeployment(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a deployment resource by resource id for the given deployment.
         * @param {string} id The id of the deployment
         * @param {string} resourceId The id of the deployment resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentResource(id: string, resourceId: string, options?: any): AxiosPromise<DeploymentResourceDto> {
            return localVarFp.getDeploymentResource(id, resourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the binary content of a deployment resource for the given deployment by id.
         * @param {string} id The id of the deployment.
         * @param {string} resourceId The id of the deployment resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentResourceData(id: string, resourceId: string, options?: any): AxiosPromise<any> {
            return localVarFp.getDeploymentResourceData(id, resourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all deployment resources of a given deployment.
         * @param {string} id The id of the deployment to retrieve the deployment resources for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentResources(id: string, options?: any): AxiosPromise<Array<DeploymentResourceDto>> {
            return localVarFp.getDeploymentResources(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for deployments that fulfill given parameters. Parameters may be the properties of deployments, such as the id or name or a range of the deployment time. The size of the result set can be retrieved by using the [Get Deployment count](https://docs.camunda.org/manual/7.13/reference/rest/deployment/get-query-count/) method.
         * @param {string} [id] Filter by deployment id
         * @param {string} [name] Filter by the deployment name. Exact match.
         * @param {string} [nameLike] Filter by the deployment name that the parameter is a substring of. The parameter can include the wildcard &#x60;%&#x60; to express like-strategy such as: starts with (&#x60;%&#x60;name), ends with (name&#x60;%&#x60;) or contains (&#x60;%&#x60;name&#x60;%&#x60;).
         * @param {string} [source] Filter by the deployment source.
         * @param {boolean} [withoutSource] Filter by the deployment source whereby source is equal to &#x60;null&#x60;.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A deployment must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include deployments which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeDeploymentsWithoutTenantId] Include deployments which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [after] Restricts to all deployments after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [before] Restricts to all deployments before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployments(id?: string, name?: string, nameLike?: string, source?: string, withoutSource?: boolean, tenantIdIn?: string, withoutTenantId?: boolean, includeDeploymentsWithoutTenantId?: boolean, after?: string, before?: string, sortBy?: string, sortOrder?: 'asc' | 'desc', firstResult?: number, maxResults?: number, options?: any): AxiosPromise<Array<DeploymentDto>> {
            return localVarFp.getDeployments(id, name, nameLike, source, withoutSource, tenantIdIn, withoutTenantId, includeDeploymentsWithoutTenantId, after, before, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for the number of deployments that fulfill given parameters. Takes the same parameters as the [Get Deployments](https://docs.camunda.org/manual/7.13/reference/rest/deployment/get-query/) method.
         * @param {string} [id] Filter by deployment id
         * @param {string} [name] Filter by the deployment name. Exact match.
         * @param {string} [nameLike] Filter by the deployment name that the parameter is a substring of. The parameter can include the wildcard &#x60;%&#x60; to express like-strategy such as: starts with (&#x60;%&#x60;name), ends with (name&#x60;%&#x60;) or contains (&#x60;%&#x60;name&#x60;%&#x60;).
         * @param {string} [source] Filter by the deployment source.
         * @param {boolean} [withoutSource] Filter by the deployment source whereby source is equal to &#x60;null&#x60;.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A deployment must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include deployments which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeDeploymentsWithoutTenantId] Include deployments which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [after] Restricts to all deployments after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [before] Restricts to all deployments before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentsCount(id?: string, name?: string, nameLike?: string, source?: string, withoutSource?: boolean, tenantIdIn?: string, withoutTenantId?: boolean, includeDeploymentsWithoutTenantId?: boolean, after?: string, before?: string, options?: any): AxiosPromise<CountResultDto> {
            return localVarFp.getDeploymentsCount(id, name, nameLike, source, withoutSource, tenantIdIn, withoutTenantId, includeDeploymentsWithoutTenantId, after, before, options).then((request) => request(axios, basePath));
        },
        /**
         * Re-deploys an existing deployment.  The deployment resources to re-deploy can be restricted by using the properties `resourceIds` or `resourceNames`. If no deployment resources to re-deploy are passed then all existing resources of the given deployment are re-deployed.  **Warning**: Deployments can contain custom code in form of scripts or EL expressions to customize process behavior. This may be abused for remote execution of arbitrary code. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) in the user guide for details.
         * @param {string} id The id of the deployment to re-deploy.
         * @param {RedeploymentDto} [redeploymentDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeploy(id: string, redeploymentDto?: RedeploymentDto, options?: any): AxiosPromise<DeploymentWithDefinitionsDto> {
            return localVarFp.redeploy(id, redeploymentDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeploymentApi - object-oriented interface
 * @export
 * @class DeploymentApi
 * @extends {BaseAPI}
 */
export class DeploymentApi extends BaseAPI {
    /**
     * Creates a deployment.  **Security Consideration**  Deployments can contain custom code in form of scripts or EL expressions to customize process behavior. This may be abused for remote execution of arbitrary code.
     * @param {string} [tenantId] The tenant id for the deployment to be created.
     * @param {string} [deploymentSource] The source for the deployment to be created.
     * @param {boolean} [deployChangedOnly] A flag indicating whether the process engine should perform duplicate checking on a per-resource basis. If set to true, only those resources that have actually changed are deployed. Checks are made against resources included previous deployments of the same name and only against the latest versions of those resources. If set to true, the option enable-duplicate-filtering is overridden and set to true.
     * @param {boolean} [enableDuplicateFiltering] A flag indicating whether the process engine should perform duplicate checking for the deployment or not. This allows you to check if a deployment with the same name and the same resouces already exists and if true, not create a new deployment but instead return the existing deployment. The default value is false.
     * @param {string} [deploymentName] The name for the deployment to be created.
     * @param {any} [data] The binary data to create the deployment resource. It is possible to have more than one form part with different form part names for the binary data to create a deployment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public createDeployment(tenantId?: string, deploymentSource?: string, deployChangedOnly?: boolean, enableDuplicateFiltering?: boolean, deploymentName?: string, data?: any, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).createDeployment(tenantId, deploymentSource, deployChangedOnly, enableDuplicateFiltering, deploymentName, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a deployment by id.
     * @param {string} id The id of the deployment to be deleted.
     * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this deployment should be deleted.
     * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
     * @param {boolean} [skipIoMappings] &#x60;true&#x60;, if all input/output mappings should not be invoked.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public deleteDeployment(id: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).deleteDeployment(id, cascade, skipCustomListeners, skipIoMappings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a deployment by id, according to the `Deployment` interface of the engine.
     * @param {string} id The id of the deployment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public getDeployment(id: string, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).getDeployment(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a deployment resource by resource id for the given deployment.
     * @param {string} id The id of the deployment
     * @param {string} resourceId The id of the deployment resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public getDeploymentResource(id: string, resourceId: string, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).getDeploymentResource(id, resourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the binary content of a deployment resource for the given deployment by id.
     * @param {string} id The id of the deployment.
     * @param {string} resourceId The id of the deployment resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public getDeploymentResourceData(id: string, resourceId: string, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).getDeploymentResourceData(id, resourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all deployment resources of a given deployment.
     * @param {string} id The id of the deployment to retrieve the deployment resources for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public getDeploymentResources(id: string, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).getDeploymentResources(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Queries for deployments that fulfill given parameters. Parameters may be the properties of deployments, such as the id or name or a range of the deployment time. The size of the result set can be retrieved by using the [Get Deployment count](https://docs.camunda.org/manual/7.13/reference/rest/deployment/get-query-count/) method.
     * @param {string} [id] Filter by deployment id
     * @param {string} [name] Filter by the deployment name. Exact match.
     * @param {string} [nameLike] Filter by the deployment name that the parameter is a substring of. The parameter can include the wildcard &#x60;%&#x60; to express like-strategy such as: starts with (&#x60;%&#x60;name), ends with (name&#x60;%&#x60;) or contains (&#x60;%&#x60;name&#x60;%&#x60;).
     * @param {string} [source] Filter by the deployment source.
     * @param {boolean} [withoutSource] Filter by the deployment source whereby source is equal to &#x60;null&#x60;.
     * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A deployment must have one of the given tenant ids.
     * @param {boolean} [withoutTenantId] Only include deployments which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [includeDeploymentsWithoutTenantId] Include deployments which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [after] Restricts to all deployments after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {string} [before] Restricts to all deployments before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public getDeployments(id?: string, name?: string, nameLike?: string, source?: string, withoutSource?: boolean, tenantIdIn?: string, withoutTenantId?: boolean, includeDeploymentsWithoutTenantId?: boolean, after?: string, before?: string, sortBy?: string, sortOrder?: 'asc' | 'desc', firstResult?: number, maxResults?: number, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).getDeployments(id, name, nameLike, source, withoutSource, tenantIdIn, withoutTenantId, includeDeploymentsWithoutTenantId, after, before, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Queries for the number of deployments that fulfill given parameters. Takes the same parameters as the [Get Deployments](https://docs.camunda.org/manual/7.13/reference/rest/deployment/get-query/) method.
     * @param {string} [id] Filter by deployment id
     * @param {string} [name] Filter by the deployment name. Exact match.
     * @param {string} [nameLike] Filter by the deployment name that the parameter is a substring of. The parameter can include the wildcard &#x60;%&#x60; to express like-strategy such as: starts with (&#x60;%&#x60;name), ends with (name&#x60;%&#x60;) or contains (&#x60;%&#x60;name&#x60;%&#x60;).
     * @param {string} [source] Filter by the deployment source.
     * @param {boolean} [withoutSource] Filter by the deployment source whereby source is equal to &#x60;null&#x60;.
     * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A deployment must have one of the given tenant ids.
     * @param {boolean} [withoutTenantId] Only include deployments which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [includeDeploymentsWithoutTenantId] Include deployments which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [after] Restricts to all deployments after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {string} [before] Restricts to all deployments before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public getDeploymentsCount(id?: string, name?: string, nameLike?: string, source?: string, withoutSource?: boolean, tenantIdIn?: string, withoutTenantId?: boolean, includeDeploymentsWithoutTenantId?: boolean, after?: string, before?: string, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).getDeploymentsCount(id, name, nameLike, source, withoutSource, tenantIdIn, withoutTenantId, includeDeploymentsWithoutTenantId, after, before, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Re-deploys an existing deployment.  The deployment resources to re-deploy can be restricted by using the properties `resourceIds` or `resourceNames`. If no deployment resources to re-deploy are passed then all existing resources of the given deployment are re-deployed.  **Warning**: Deployments can contain custom code in form of scripts or EL expressions to customize process behavior. This may be abused for remote execution of arbitrary code. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) in the user guide for details.
     * @param {string} id The id of the deployment to re-deploy.
     * @param {RedeploymentDto} [redeploymentDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public redeploy(id: string, redeploymentDto?: RedeploymentDto, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).redeploy(id, redeploymentDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EngineApi - axios parameter creator
 * @export
 */
export const EngineApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the names of all process engines available on your platform. **Note**: You cannot prepend `/engine/{name}` to this method.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessEngineNames: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/engine`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EngineApi - functional programming interface
 * @export
 */
export const EngineApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EngineApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the names of all process engines available on your platform. **Note**: You cannot prepend `/engine/{name}` to this method.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessEngineNames(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProcessEngineDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessEngineNames(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EngineApi - factory interface
 * @export
 */
export const EngineApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EngineApiFp(configuration)
    return {
        /**
         * Retrieves the names of all process engines available on your platform. **Note**: You cannot prepend `/engine/{name}` to this method.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessEngineNames(options?: any): AxiosPromise<Array<ProcessEngineDto>> {
            return localVarFp.getProcessEngineNames(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EngineApi - object-oriented interface
 * @export
 * @class EngineApi
 * @extends {BaseAPI}
 */
export class EngineApi extends BaseAPI {
    /**
     * Retrieves the names of all process engines available on your platform. **Note**: You cannot prepend `/engine/{name}` to this method.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EngineApi
     */
    public getProcessEngineNames(options?: AxiosRequestConfig) {
        return EngineApiFp(this.configuration).getProcessEngineNames(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventSubscriptionApi - axios parameter creator
 * @export
 */
export const EventSubscriptionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Queries for event subscriptions that fulfill given parameters. The size of the result set can be retrieved by using the [Get Event Subscriptions count](https://docs.camunda.org/manual/7.13/reference/rest/event-subscription/get-query-count/) method.
         * @param {string} [eventSubscriptionId] Only select subscription with the given id.
         * @param {string} [eventName] Only select subscriptions for events with the given name.
         * @param {'message' | 'signal' | 'compensate' | 'conditional'} [eventType] Only select subscriptions for events with the given type. Valid values: &#x60;message&#x60;, &#x60;signal&#x60;, &#x60;compensate&#x60; and &#x60;conditional&#x60;.
         * @param {string} [executionId] Only select subscriptions that belong to an execution with the given id.
         * @param {string} [processInstanceId] Only select subscriptions that belong to a process instance with the given id.
         * @param {string} [activityId] Only select subscriptions that belong to an activity with the given id.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. Only select subscriptions that belong to one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only select subscriptions which have no tenant id. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeEventSubscriptionsWithoutTenantId] Select event subscriptions which have no tenant id. Can be used in combination with tenantIdIn parameter. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {'created' | 'tenantId'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSubscriptions: async (eventSubscriptionId?: string, eventName?: string, eventType?: 'message' | 'signal' | 'compensate' | 'conditional', executionId?: string, processInstanceId?: string, activityId?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeEventSubscriptionsWithoutTenantId?: boolean, sortBy?: 'created' | 'tenantId', sortOrder?: 'asc' | 'desc', firstResult?: number, maxResults?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/event-subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (eventSubscriptionId !== undefined) {
                localVarQueryParameter['eventSubscriptionId'] = eventSubscriptionId;
            }

            if (eventName !== undefined) {
                localVarQueryParameter['eventName'] = eventName;
            }

            if (eventType !== undefined) {
                localVarQueryParameter['eventType'] = eventType;
            }

            if (executionId !== undefined) {
                localVarQueryParameter['executionId'] = executionId;
            }

            if (processInstanceId !== undefined) {
                localVarQueryParameter['processInstanceId'] = processInstanceId;
            }

            if (activityId !== undefined) {
                localVarQueryParameter['activityId'] = activityId;
            }

            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }

            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }

            if (includeEventSubscriptionsWithoutTenantId !== undefined) {
                localVarQueryParameter['includeEventSubscriptionsWithoutTenantId'] = includeEventSubscriptionsWithoutTenantId;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for the number of event subscriptions that fulfill given parameters. Takes the same parameters as the [Get Event Subscriptions](https://docs.camunda.org/manual/7.13/reference/rest/event-subscription/get-query/) method.
         * @param {string} [eventSubscriptionId] Only select subscription with the given id.
         * @param {string} [eventName] Only select subscriptions for events with the given name.
         * @param {'message' | 'signal' | 'compensate' | 'conditional'} [eventType] Only select subscriptions for events with the given type. Valid values: &#x60;message&#x60;, &#x60;signal&#x60;, &#x60;compensate&#x60; and &#x60;conditional&#x60;.
         * @param {string} [executionId] Only select subscriptions that belong to an execution with the given id.
         * @param {string} [processInstanceId] Only select subscriptions that belong to a process instance with the given id.
         * @param {string} [activityId] Only select subscriptions that belong to an activity with the given id.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. Only select subscriptions that belong to one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only select subscriptions which have no tenant id. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeEventSubscriptionsWithoutTenantId] Select event subscriptions which have no tenant id. Can be used in combination with tenantIdIn parameter. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSubscriptionsCount: async (eventSubscriptionId?: string, eventName?: string, eventType?: 'message' | 'signal' | 'compensate' | 'conditional', executionId?: string, processInstanceId?: string, activityId?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeEventSubscriptionsWithoutTenantId?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/event-subscription/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (eventSubscriptionId !== undefined) {
                localVarQueryParameter['eventSubscriptionId'] = eventSubscriptionId;
            }

            if (eventName !== undefined) {
                localVarQueryParameter['eventName'] = eventName;
            }

            if (eventType !== undefined) {
                localVarQueryParameter['eventType'] = eventType;
            }

            if (executionId !== undefined) {
                localVarQueryParameter['executionId'] = executionId;
            }

            if (processInstanceId !== undefined) {
                localVarQueryParameter['processInstanceId'] = processInstanceId;
            }

            if (activityId !== undefined) {
                localVarQueryParameter['activityId'] = activityId;
            }

            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }

            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }

            if (includeEventSubscriptionsWithoutTenantId !== undefined) {
                localVarQueryParameter['includeEventSubscriptionsWithoutTenantId'] = includeEventSubscriptionsWithoutTenantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventSubscriptionApi - functional programming interface
 * @export
 */
export const EventSubscriptionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventSubscriptionApiAxiosParamCreator(configuration)
    return {
        /**
         * Queries for event subscriptions that fulfill given parameters. The size of the result set can be retrieved by using the [Get Event Subscriptions count](https://docs.camunda.org/manual/7.13/reference/rest/event-subscription/get-query-count/) method.
         * @param {string} [eventSubscriptionId] Only select subscription with the given id.
         * @param {string} [eventName] Only select subscriptions for events with the given name.
         * @param {'message' | 'signal' | 'compensate' | 'conditional'} [eventType] Only select subscriptions for events with the given type. Valid values: &#x60;message&#x60;, &#x60;signal&#x60;, &#x60;compensate&#x60; and &#x60;conditional&#x60;.
         * @param {string} [executionId] Only select subscriptions that belong to an execution with the given id.
         * @param {string} [processInstanceId] Only select subscriptions that belong to a process instance with the given id.
         * @param {string} [activityId] Only select subscriptions that belong to an activity with the given id.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. Only select subscriptions that belong to one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only select subscriptions which have no tenant id. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeEventSubscriptionsWithoutTenantId] Select event subscriptions which have no tenant id. Can be used in combination with tenantIdIn parameter. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {'created' | 'tenantId'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventSubscriptions(eventSubscriptionId?: string, eventName?: string, eventType?: 'message' | 'signal' | 'compensate' | 'conditional', executionId?: string, processInstanceId?: string, activityId?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeEventSubscriptionsWithoutTenantId?: boolean, sortBy?: 'created' | 'tenantId', sortOrder?: 'asc' | 'desc', firstResult?: number, maxResults?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventSubscriptionDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventSubscriptions(eventSubscriptionId, eventName, eventType, executionId, processInstanceId, activityId, tenantIdIn, withoutTenantId, includeEventSubscriptionsWithoutTenantId, sortBy, sortOrder, firstResult, maxResults, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Queries for the number of event subscriptions that fulfill given parameters. Takes the same parameters as the [Get Event Subscriptions](https://docs.camunda.org/manual/7.13/reference/rest/event-subscription/get-query/) method.
         * @param {string} [eventSubscriptionId] Only select subscription with the given id.
         * @param {string} [eventName] Only select subscriptions for events with the given name.
         * @param {'message' | 'signal' | 'compensate' | 'conditional'} [eventType] Only select subscriptions for events with the given type. Valid values: &#x60;message&#x60;, &#x60;signal&#x60;, &#x60;compensate&#x60; and &#x60;conditional&#x60;.
         * @param {string} [executionId] Only select subscriptions that belong to an execution with the given id.
         * @param {string} [processInstanceId] Only select subscriptions that belong to a process instance with the given id.
         * @param {string} [activityId] Only select subscriptions that belong to an activity with the given id.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. Only select subscriptions that belong to one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only select subscriptions which have no tenant id. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeEventSubscriptionsWithoutTenantId] Select event subscriptions which have no tenant id. Can be used in combination with tenantIdIn parameter. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventSubscriptionsCount(eventSubscriptionId?: string, eventName?: string, eventType?: 'message' | 'signal' | 'compensate' | 'conditional', executionId?: string, processInstanceId?: string, activityId?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeEventSubscriptionsWithoutTenantId?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventSubscriptionsCount(eventSubscriptionId, eventName, eventType, executionId, processInstanceId, activityId, tenantIdIn, withoutTenantId, includeEventSubscriptionsWithoutTenantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventSubscriptionApi - factory interface
 * @export
 */
export const EventSubscriptionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventSubscriptionApiFp(configuration)
    return {
        /**
         * Queries for event subscriptions that fulfill given parameters. The size of the result set can be retrieved by using the [Get Event Subscriptions count](https://docs.camunda.org/manual/7.13/reference/rest/event-subscription/get-query-count/) method.
         * @param {string} [eventSubscriptionId] Only select subscription with the given id.
         * @param {string} [eventName] Only select subscriptions for events with the given name.
         * @param {'message' | 'signal' | 'compensate' | 'conditional'} [eventType] Only select subscriptions for events with the given type. Valid values: &#x60;message&#x60;, &#x60;signal&#x60;, &#x60;compensate&#x60; and &#x60;conditional&#x60;.
         * @param {string} [executionId] Only select subscriptions that belong to an execution with the given id.
         * @param {string} [processInstanceId] Only select subscriptions that belong to a process instance with the given id.
         * @param {string} [activityId] Only select subscriptions that belong to an activity with the given id.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. Only select subscriptions that belong to one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only select subscriptions which have no tenant id. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeEventSubscriptionsWithoutTenantId] Select event subscriptions which have no tenant id. Can be used in combination with tenantIdIn parameter. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {'created' | 'tenantId'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSubscriptions(eventSubscriptionId?: string, eventName?: string, eventType?: 'message' | 'signal' | 'compensate' | 'conditional', executionId?: string, processInstanceId?: string, activityId?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeEventSubscriptionsWithoutTenantId?: boolean, sortBy?: 'created' | 'tenantId', sortOrder?: 'asc' | 'desc', firstResult?: number, maxResults?: number, options?: any): AxiosPromise<Array<EventSubscriptionDto>> {
            return localVarFp.getEventSubscriptions(eventSubscriptionId, eventName, eventType, executionId, processInstanceId, activityId, tenantIdIn, withoutTenantId, includeEventSubscriptionsWithoutTenantId, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for the number of event subscriptions that fulfill given parameters. Takes the same parameters as the [Get Event Subscriptions](https://docs.camunda.org/manual/7.13/reference/rest/event-subscription/get-query/) method.
         * @param {string} [eventSubscriptionId] Only select subscription with the given id.
         * @param {string} [eventName] Only select subscriptions for events with the given name.
         * @param {'message' | 'signal' | 'compensate' | 'conditional'} [eventType] Only select subscriptions for events with the given type. Valid values: &#x60;message&#x60;, &#x60;signal&#x60;, &#x60;compensate&#x60; and &#x60;conditional&#x60;.
         * @param {string} [executionId] Only select subscriptions that belong to an execution with the given id.
         * @param {string} [processInstanceId] Only select subscriptions that belong to a process instance with the given id.
         * @param {string} [activityId] Only select subscriptions that belong to an activity with the given id.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. Only select subscriptions that belong to one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only select subscriptions which have no tenant id. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeEventSubscriptionsWithoutTenantId] Select event subscriptions which have no tenant id. Can be used in combination with tenantIdIn parameter. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSubscriptionsCount(eventSubscriptionId?: string, eventName?: string, eventType?: 'message' | 'signal' | 'compensate' | 'conditional', executionId?: string, processInstanceId?: string, activityId?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeEventSubscriptionsWithoutTenantId?: boolean, options?: any): AxiosPromise<CountResultDto> {
            return localVarFp.getEventSubscriptionsCount(eventSubscriptionId, eventName, eventType, executionId, processInstanceId, activityId, tenantIdIn, withoutTenantId, includeEventSubscriptionsWithoutTenantId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventSubscriptionApi - object-oriented interface
 * @export
 * @class EventSubscriptionApi
 * @extends {BaseAPI}
 */
export class EventSubscriptionApi extends BaseAPI {
    /**
     * Queries for event subscriptions that fulfill given parameters. The size of the result set can be retrieved by using the [Get Event Subscriptions count](https://docs.camunda.org/manual/7.13/reference/rest/event-subscription/get-query-count/) method.
     * @param {string} [eventSubscriptionId] Only select subscription with the given id.
     * @param {string} [eventName] Only select subscriptions for events with the given name.
     * @param {'message' | 'signal' | 'compensate' | 'conditional'} [eventType] Only select subscriptions for events with the given type. Valid values: &#x60;message&#x60;, &#x60;signal&#x60;, &#x60;compensate&#x60; and &#x60;conditional&#x60;.
     * @param {string} [executionId] Only select subscriptions that belong to an execution with the given id.
     * @param {string} [processInstanceId] Only select subscriptions that belong to a process instance with the given id.
     * @param {string} [activityId] Only select subscriptions that belong to an activity with the given id.
     * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. Only select subscriptions that belong to one of the given tenant ids.
     * @param {boolean} [withoutTenantId] Only select subscriptions which have no tenant id. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [includeEventSubscriptionsWithoutTenantId] Select event subscriptions which have no tenant id. Can be used in combination with tenantIdIn parameter. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {'created' | 'tenantId'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSubscriptionApi
     */
    public getEventSubscriptions(eventSubscriptionId?: string, eventName?: string, eventType?: 'message' | 'signal' | 'compensate' | 'conditional', executionId?: string, processInstanceId?: string, activityId?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeEventSubscriptionsWithoutTenantId?: boolean, sortBy?: 'created' | 'tenantId', sortOrder?: 'asc' | 'desc', firstResult?: number, maxResults?: number, options?: AxiosRequestConfig) {
        return EventSubscriptionApiFp(this.configuration).getEventSubscriptions(eventSubscriptionId, eventName, eventType, executionId, processInstanceId, activityId, tenantIdIn, withoutTenantId, includeEventSubscriptionsWithoutTenantId, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Queries for the number of event subscriptions that fulfill given parameters. Takes the same parameters as the [Get Event Subscriptions](https://docs.camunda.org/manual/7.13/reference/rest/event-subscription/get-query/) method.
     * @param {string} [eventSubscriptionId] Only select subscription with the given id.
     * @param {string} [eventName] Only select subscriptions for events with the given name.
     * @param {'message' | 'signal' | 'compensate' | 'conditional'} [eventType] Only select subscriptions for events with the given type. Valid values: &#x60;message&#x60;, &#x60;signal&#x60;, &#x60;compensate&#x60; and &#x60;conditional&#x60;.
     * @param {string} [executionId] Only select subscriptions that belong to an execution with the given id.
     * @param {string} [processInstanceId] Only select subscriptions that belong to a process instance with the given id.
     * @param {string} [activityId] Only select subscriptions that belong to an activity with the given id.
     * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. Only select subscriptions that belong to one of the given tenant ids.
     * @param {boolean} [withoutTenantId] Only select subscriptions which have no tenant id. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [includeEventSubscriptionsWithoutTenantId] Select event subscriptions which have no tenant id. Can be used in combination with tenantIdIn parameter. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSubscriptionApi
     */
    public getEventSubscriptionsCount(eventSubscriptionId?: string, eventName?: string, eventType?: 'message' | 'signal' | 'compensate' | 'conditional', executionId?: string, processInstanceId?: string, activityId?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeEventSubscriptionsWithoutTenantId?: boolean, options?: AxiosRequestConfig) {
        return EventSubscriptionApiFp(this.configuration).getEventSubscriptionsCount(eventSubscriptionId, eventName, eventType, executionId, processInstanceId, activityId, tenantIdIn, withoutTenantId, includeEventSubscriptionsWithoutTenantId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ExternalTaskApi - axios parameter creator
 * @export
 */
export const ExternalTaskApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Completes an external task by id and updates process variables.
         * @param {string} id The id of the task to complete.
         * @param {CompleteExternalTaskDto} [completeExternalTaskDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeExternalTaskResource: async (id: string, completeExternalTaskDto?: CompleteExternalTaskDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('completeExternalTaskResource', 'id', id)
            const localVarPath = `/external-task/{id}/complete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(completeExternalTaskDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Extends the timeout of the lock by a given amount of time.
         * @param {string} id The id of the external task.
         * @param {ExtendLockOnExternalTaskDto} [extendLockOnExternalTaskDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extendLock: async (id: string, extendLockOnExternalTaskDto?: ExtendLockOnExternalTaskDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('extendLock', 'id', id)
            const localVarPath = `/external-task/{id}/extendLock`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(extendLockOnExternalTaskDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches and locks a specific number of external tasks for execution by a worker. Query can be restricted to specific task topics and for each task topic an individual lock time can be provided.
         * @param {FetchExternalTasksDto} [fetchExternalTasksDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAndLock: async (fetchExternalTasksDto?: FetchExternalTasksDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/external-task/fetchAndLock`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fetchExternalTasksDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves an external task by id, corresponding to the `ExternalTask` interface in the engine.
         * @param {string} id The id of the external task to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalTask: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getExternalTask', 'id', id)
            const localVarPath = `/external-task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the error details in the context of a running external task by id.
         * @param {string} id The id of the external task for which the error details should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalTaskErrorDetails: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getExternalTaskErrorDetails', 'id', id)
            const localVarPath = `/external-task/{id}/errorDetails`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for the external tasks that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of executions. The size of the result set can be retrieved by using the [Get External Task Count](https://docs.camunda.org/manual/7.13/reference/rest/external-task/get-query-count/) method.
         * @param {string} [externalTaskId] Filter by an external task\&#39;s id.
         * @param {string} [externalTaskIdIn] Filter by the comma-separated list of external task ids.
         * @param {string} [topicName] Filter by an external task topic.
         * @param {string} [workerId] Filter by the id of the worker that the task was most recently locked by.
         * @param {boolean} [locked] Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [notLocked] Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [withRetriesLeft] Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [noRetriesLeft] Only include external tasks that have 0 retries. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {string} [lockExpirationAfter] Restrict to external tasks that have a lock that expires after a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [lockExpirationBefore] Restrict to external tasks that have a lock that expires before a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [activityId] Filter by the id of the activity that an external task is created for.
         * @param {string} [activityIdIn] Filter by the comma-separated list of ids of the activities that an external task is created for.
         * @param {string} [executionId] Filter by the id of the execution that an external task belongs to.
         * @param {string} [processInstanceId] Filter by the id of the process instance that an external task belongs to.
         * @param {string} [processInstanceIdIn] Filter by a comma-separated list of process instance ids that an external task may belong to.
         * @param {string} [processDefinitionId] Filter by the id of the process definition that an external task belongs to.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. An external task must have one of the given tenant ids.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {number} [priorityHigherThanOrEquals] Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {number} [priorityLowerThanOrEquals] Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {'id' | 'lockExpirationTime' | 'processInstanceId' | 'processDefinitionId' | 'processDefinitionKey' | 'taskPriority' | 'tenantId'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalTasks: async (externalTaskId?: string, externalTaskIdIn?: string, topicName?: string, workerId?: string, locked?: boolean, notLocked?: boolean, withRetriesLeft?: boolean, noRetriesLeft?: boolean, lockExpirationAfter?: string, lockExpirationBefore?: string, activityId?: string, activityIdIn?: string, executionId?: string, processInstanceId?: string, processInstanceIdIn?: string, processDefinitionId?: string, tenantIdIn?: string, active?: boolean, suspended?: boolean, priorityHigherThanOrEquals?: number, priorityLowerThanOrEquals?: number, sortBy?: 'id' | 'lockExpirationTime' | 'processInstanceId' | 'processDefinitionId' | 'processDefinitionKey' | 'taskPriority' | 'tenantId', sortOrder?: 'asc' | 'desc', firstResult?: number, maxResults?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/external-task`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (externalTaskId !== undefined) {
                localVarQueryParameter['externalTaskId'] = externalTaskId;
            }

            if (externalTaskIdIn !== undefined) {
                localVarQueryParameter['externalTaskIdIn'] = externalTaskIdIn;
            }

            if (topicName !== undefined) {
                localVarQueryParameter['topicName'] = topicName;
            }

            if (workerId !== undefined) {
                localVarQueryParameter['workerId'] = workerId;
            }

            if (locked !== undefined) {
                localVarQueryParameter['locked'] = locked;
            }

            if (notLocked !== undefined) {
                localVarQueryParameter['notLocked'] = notLocked;
            }

            if (withRetriesLeft !== undefined) {
                localVarQueryParameter['withRetriesLeft'] = withRetriesLeft;
            }

            if (noRetriesLeft !== undefined) {
                localVarQueryParameter['noRetriesLeft'] = noRetriesLeft;
            }

            if (lockExpirationAfter !== undefined) {
                localVarQueryParameter['lockExpirationAfter'] = (lockExpirationAfter as any instanceof Date) ?
                    (lockExpirationAfter as any).toISOString() :
                    lockExpirationAfter;
            }

            if (lockExpirationBefore !== undefined) {
                localVarQueryParameter['lockExpirationBefore'] = (lockExpirationBefore as any instanceof Date) ?
                    (lockExpirationBefore as any).toISOString() :
                    lockExpirationBefore;
            }

            if (activityId !== undefined) {
                localVarQueryParameter['activityId'] = activityId;
            }

            if (activityIdIn !== undefined) {
                localVarQueryParameter['activityIdIn'] = activityIdIn;
            }

            if (executionId !== undefined) {
                localVarQueryParameter['executionId'] = executionId;
            }

            if (processInstanceId !== undefined) {
                localVarQueryParameter['processInstanceId'] = processInstanceId;
            }

            if (processInstanceIdIn !== undefined) {
                localVarQueryParameter['processInstanceIdIn'] = processInstanceIdIn;
            }

            if (processDefinitionId !== undefined) {
                localVarQueryParameter['processDefinitionId'] = processDefinitionId;
            }

            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (suspended !== undefined) {
                localVarQueryParameter['suspended'] = suspended;
            }

            if (priorityHigherThanOrEquals !== undefined) {
                localVarQueryParameter['priorityHigherThanOrEquals'] = priorityHigherThanOrEquals;
            }

            if (priorityLowerThanOrEquals !== undefined) {
                localVarQueryParameter['priorityLowerThanOrEquals'] = priorityLowerThanOrEquals;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for the number of external tasks that fulfill given parameters. Takes the same parameters as the [Get External Tasks](https://docs.camunda.org/manual/7.13/reference/rest/external-task/get-query/) method.
         * @param {string} [externalTaskId] Filter by an external task\&#39;s id.
         * @param {string} [externalTaskIdIn] Filter by the comma-separated list of external task ids.
         * @param {string} [topicName] Filter by an external task topic.
         * @param {string} [workerId] Filter by the id of the worker that the task was most recently locked by.
         * @param {boolean} [locked] Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [notLocked] Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [withRetriesLeft] Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [noRetriesLeft] Only include external tasks that have 0 retries. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {string} [lockExpirationAfter] Restrict to external tasks that have a lock that expires after a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [lockExpirationBefore] Restrict to external tasks that have a lock that expires before a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [activityId] Filter by the id of the activity that an external task is created for.
         * @param {string} [activityIdIn] Filter by the comma-separated list of ids of the activities that an external task is created for.
         * @param {string} [executionId] Filter by the id of the execution that an external task belongs to.
         * @param {string} [processInstanceId] Filter by the id of the process instance that an external task belongs to.
         * @param {string} [processInstanceIdIn] Filter by a comma-separated list of process instance ids that an external task may belong to.
         * @param {string} [processDefinitionId] Filter by the id of the process definition that an external task belongs to.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. An external task must have one of the given tenant ids.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {number} [priorityHigherThanOrEquals] Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {number} [priorityLowerThanOrEquals] Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalTasksCount: async (externalTaskId?: string, externalTaskIdIn?: string, topicName?: string, workerId?: string, locked?: boolean, notLocked?: boolean, withRetriesLeft?: boolean, noRetriesLeft?: boolean, lockExpirationAfter?: string, lockExpirationBefore?: string, activityId?: string, activityIdIn?: string, executionId?: string, processInstanceId?: string, processInstanceIdIn?: string, processDefinitionId?: string, tenantIdIn?: string, active?: boolean, suspended?: boolean, priorityHigherThanOrEquals?: number, priorityLowerThanOrEquals?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/external-task/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (externalTaskId !== undefined) {
                localVarQueryParameter['externalTaskId'] = externalTaskId;
            }

            if (externalTaskIdIn !== undefined) {
                localVarQueryParameter['externalTaskIdIn'] = externalTaskIdIn;
            }

            if (topicName !== undefined) {
                localVarQueryParameter['topicName'] = topicName;
            }

            if (workerId !== undefined) {
                localVarQueryParameter['workerId'] = workerId;
            }

            if (locked !== undefined) {
                localVarQueryParameter['locked'] = locked;
            }

            if (notLocked !== undefined) {
                localVarQueryParameter['notLocked'] = notLocked;
            }

            if (withRetriesLeft !== undefined) {
                localVarQueryParameter['withRetriesLeft'] = withRetriesLeft;
            }

            if (noRetriesLeft !== undefined) {
                localVarQueryParameter['noRetriesLeft'] = noRetriesLeft;
            }

            if (lockExpirationAfter !== undefined) {
                localVarQueryParameter['lockExpirationAfter'] = (lockExpirationAfter as any instanceof Date) ?
                    (lockExpirationAfter as any).toISOString() :
                    lockExpirationAfter;
            }

            if (lockExpirationBefore !== undefined) {
                localVarQueryParameter['lockExpirationBefore'] = (lockExpirationBefore as any instanceof Date) ?
                    (lockExpirationBefore as any).toISOString() :
                    lockExpirationBefore;
            }

            if (activityId !== undefined) {
                localVarQueryParameter['activityId'] = activityId;
            }

            if (activityIdIn !== undefined) {
                localVarQueryParameter['activityIdIn'] = activityIdIn;
            }

            if (executionId !== undefined) {
                localVarQueryParameter['executionId'] = executionId;
            }

            if (processInstanceId !== undefined) {
                localVarQueryParameter['processInstanceId'] = processInstanceId;
            }

            if (processInstanceIdIn !== undefined) {
                localVarQueryParameter['processInstanceIdIn'] = processInstanceIdIn;
            }

            if (processDefinitionId !== undefined) {
                localVarQueryParameter['processDefinitionId'] = processDefinitionId;
            }

            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (suspended !== undefined) {
                localVarQueryParameter['suspended'] = suspended;
            }

            if (priorityHigherThanOrEquals !== undefined) {
                localVarQueryParameter['priorityHigherThanOrEquals'] = priorityHigherThanOrEquals;
            }

            if (priorityLowerThanOrEquals !== undefined) {
                localVarQueryParameter['priorityLowerThanOrEquals'] = priorityLowerThanOrEquals;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for distinct topic names of external tasks that fulfill given parameters. Query can be restricted to only tasks with retries left, tasks that are locked, or tasks that are unlocked. The parameters withLockedTasks and withUnlockedTasks are exclusive. Setting them both to true will return an empty list. Providing no parameters will return a list of all distinct topic names with external tasks.
         * @param {boolean} [withLockedTasks] Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [withUnlockedTasks] Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [withRetriesLeft] Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicNames: async (withLockedTasks?: boolean, withUnlockedTasks?: boolean, withRetriesLeft?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/external-task/topic-names`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (withLockedTasks !== undefined) {
                localVarQueryParameter['withLockedTasks'] = withLockedTasks;
            }

            if (withUnlockedTasks !== undefined) {
                localVarQueryParameter['withUnlockedTasks'] = withUnlockedTasks;
            }

            if (withRetriesLeft !== undefined) {
                localVarQueryParameter['withRetriesLeft'] = withRetriesLeft;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reports a business error in the context of a running external task by id. The error code must be specified to identify the BPMN error handler.
         * @param {string} id The id of the external task in which context a BPMN error is reported.
         * @param {ExternalTaskBpmnError} [externalTaskBpmnError] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleExternalTaskBpmnError: async (id: string, externalTaskBpmnError?: ExternalTaskBpmnError, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('handleExternalTaskBpmnError', 'id', id)
            const localVarPath = `/external-task/{id}/bpmnError`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(externalTaskBpmnError, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reports a failure to execute an external task by id. A number of retries and a timeout until the task can be retried can be specified. If retries are set to 0, an incident for this task is created.
         * @param {string} id The id of the external task to report a failure for.
         * @param {ExternalTaskFailureDto} [externalTaskFailureDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleFailure: async (id: string, externalTaskFailureDto?: ExternalTaskFailureDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('handleFailure', 'id', id)
            const localVarPath = `/external-task/{id}/failure`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(externalTaskFailureDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for external tasks that fulfill given parameters in the form of a JSON object.  This method is slightly more powerful than the [Get External Tasks](https://docs.camunda.org/manual/7.13/reference/rest/external-task/get-query/) method because it allows to specify a hierarchical result sorting.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {ExternalTaskQueryDto} [externalTaskQueryDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryExternalTasks: async (firstResult?: number, maxResults?: number, externalTaskQueryDto?: ExternalTaskQueryDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/external-task`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(externalTaskQueryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for the number of external tasks that fulfill given parameters. This method takes the same message body as the [Get External Tasks (POST)](https://docs.camunda.org/manual/7.13/reference/rest/external-task/post-query/) method.
         * @param {ExternalTaskQueryDto} [externalTaskQueryDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryExternalTasksCount: async (externalTaskQueryDto?: ExternalTaskQueryDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/external-task/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(externalTaskQueryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the priority of an existing external task by id. The default value of a priority is 0.
         * @param {string} id The id of the external task to set the priority for.
         * @param {PriorityDto} [priorityDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalTaskResourcePriority: async (id: string, priorityDto?: PriorityDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setExternalTaskResourcePriority', 'id', id)
            const localVarPath = `/external-task/{id}/priority`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(priorityDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the number of retries left to execute an external task by id. If retries are set to 0, an  incident is created.
         * @param {string} id The id of the external task to set the number of retries for.
         * @param {RetriesDto} [retriesDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalTaskResourceRetries: async (id: string, retriesDto?: RetriesDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setExternalTaskResourceRetries', 'id', id)
            const localVarPath = `/external-task/{id}/retries`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(retriesDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the number of retries left to execute external tasks by id synchronously. If retries are set to 0,  an incident is created.
         * @param {SetRetriesForExternalTasksDto} [setRetriesForExternalTasksDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalTaskRetries: async (setRetriesForExternalTasksDto?: SetRetriesForExternalTasksDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/external-task/retries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setRetriesForExternalTasksDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the number of retries left to execute external tasks by id asynchronously. If retries are set to 0, an incident is created.
         * @param {SetRetriesForExternalTasksDto} [setRetriesForExternalTasksDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalTaskRetriesAsyncOperation: async (setRetriesForExternalTasksDto?: SetRetriesForExternalTasksDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/external-task/retries-async`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setRetriesForExternalTasksDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unlocks an external task by id. Clears the task\'s lock expiration time and worker id.
         * @param {string} id The id of the external task to unlock.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlock: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unlock', 'id', id)
            const localVarPath = `/external-task/{id}/unlock`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExternalTaskApi - functional programming interface
 * @export
 */
export const ExternalTaskApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExternalTaskApiAxiosParamCreator(configuration)
    return {
        /**
         * Completes an external task by id and updates process variables.
         * @param {string} id The id of the task to complete.
         * @param {CompleteExternalTaskDto} [completeExternalTaskDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeExternalTaskResource(id: string, completeExternalTaskDto?: CompleteExternalTaskDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeExternalTaskResource(id, completeExternalTaskDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Extends the timeout of the lock by a given amount of time.
         * @param {string} id The id of the external task.
         * @param {ExtendLockOnExternalTaskDto} [extendLockOnExternalTaskDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extendLock(id: string, extendLockOnExternalTaskDto?: ExtendLockOnExternalTaskDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extendLock(id, extendLockOnExternalTaskDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches and locks a specific number of external tasks for execution by a worker. Query can be restricted to specific task topics and for each task topic an individual lock time can be provided.
         * @param {FetchExternalTasksDto} [fetchExternalTasksDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchAndLock(fetchExternalTasksDto?: FetchExternalTasksDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LockedExternalTaskDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchAndLock(fetchExternalTasksDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves an external task by id, corresponding to the `ExternalTask` interface in the engine.
         * @param {string} id The id of the external task to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExternalTask(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalTaskDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExternalTask(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the error details in the context of a running external task by id.
         * @param {string} id The id of the external task for which the error details should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExternalTaskErrorDetails(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExternalTaskErrorDetails(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Queries for the external tasks that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of executions. The size of the result set can be retrieved by using the [Get External Task Count](https://docs.camunda.org/manual/7.13/reference/rest/external-task/get-query-count/) method.
         * @param {string} [externalTaskId] Filter by an external task\&#39;s id.
         * @param {string} [externalTaskIdIn] Filter by the comma-separated list of external task ids.
         * @param {string} [topicName] Filter by an external task topic.
         * @param {string} [workerId] Filter by the id of the worker that the task was most recently locked by.
         * @param {boolean} [locked] Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [notLocked] Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [withRetriesLeft] Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [noRetriesLeft] Only include external tasks that have 0 retries. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {string} [lockExpirationAfter] Restrict to external tasks that have a lock that expires after a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [lockExpirationBefore] Restrict to external tasks that have a lock that expires before a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [activityId] Filter by the id of the activity that an external task is created for.
         * @param {string} [activityIdIn] Filter by the comma-separated list of ids of the activities that an external task is created for.
         * @param {string} [executionId] Filter by the id of the execution that an external task belongs to.
         * @param {string} [processInstanceId] Filter by the id of the process instance that an external task belongs to.
         * @param {string} [processInstanceIdIn] Filter by a comma-separated list of process instance ids that an external task may belong to.
         * @param {string} [processDefinitionId] Filter by the id of the process definition that an external task belongs to.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. An external task must have one of the given tenant ids.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {number} [priorityHigherThanOrEquals] Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {number} [priorityLowerThanOrEquals] Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {'id' | 'lockExpirationTime' | 'processInstanceId' | 'processDefinitionId' | 'processDefinitionKey' | 'taskPriority' | 'tenantId'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExternalTasks(externalTaskId?: string, externalTaskIdIn?: string, topicName?: string, workerId?: string, locked?: boolean, notLocked?: boolean, withRetriesLeft?: boolean, noRetriesLeft?: boolean, lockExpirationAfter?: string, lockExpirationBefore?: string, activityId?: string, activityIdIn?: string, executionId?: string, processInstanceId?: string, processInstanceIdIn?: string, processDefinitionId?: string, tenantIdIn?: string, active?: boolean, suspended?: boolean, priorityHigherThanOrEquals?: number, priorityLowerThanOrEquals?: number, sortBy?: 'id' | 'lockExpirationTime' | 'processInstanceId' | 'processDefinitionId' | 'processDefinitionKey' | 'taskPriority' | 'tenantId', sortOrder?: 'asc' | 'desc', firstResult?: number, maxResults?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExternalTaskDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExternalTasks(externalTaskId, externalTaskIdIn, topicName, workerId, locked, notLocked, withRetriesLeft, noRetriesLeft, lockExpirationAfter, lockExpirationBefore, activityId, activityIdIn, executionId, processInstanceId, processInstanceIdIn, processDefinitionId, tenantIdIn, active, suspended, priorityHigherThanOrEquals, priorityLowerThanOrEquals, sortBy, sortOrder, firstResult, maxResults, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Queries for the number of external tasks that fulfill given parameters. Takes the same parameters as the [Get External Tasks](https://docs.camunda.org/manual/7.13/reference/rest/external-task/get-query/) method.
         * @param {string} [externalTaskId] Filter by an external task\&#39;s id.
         * @param {string} [externalTaskIdIn] Filter by the comma-separated list of external task ids.
         * @param {string} [topicName] Filter by an external task topic.
         * @param {string} [workerId] Filter by the id of the worker that the task was most recently locked by.
         * @param {boolean} [locked] Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [notLocked] Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [withRetriesLeft] Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [noRetriesLeft] Only include external tasks that have 0 retries. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {string} [lockExpirationAfter] Restrict to external tasks that have a lock that expires after a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [lockExpirationBefore] Restrict to external tasks that have a lock that expires before a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [activityId] Filter by the id of the activity that an external task is created for.
         * @param {string} [activityIdIn] Filter by the comma-separated list of ids of the activities that an external task is created for.
         * @param {string} [executionId] Filter by the id of the execution that an external task belongs to.
         * @param {string} [processInstanceId] Filter by the id of the process instance that an external task belongs to.
         * @param {string} [processInstanceIdIn] Filter by a comma-separated list of process instance ids that an external task may belong to.
         * @param {string} [processDefinitionId] Filter by the id of the process definition that an external task belongs to.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. An external task must have one of the given tenant ids.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {number} [priorityHigherThanOrEquals] Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {number} [priorityLowerThanOrEquals] Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExternalTasksCount(externalTaskId?: string, externalTaskIdIn?: string, topicName?: string, workerId?: string, locked?: boolean, notLocked?: boolean, withRetriesLeft?: boolean, noRetriesLeft?: boolean, lockExpirationAfter?: string, lockExpirationBefore?: string, activityId?: string, activityIdIn?: string, executionId?: string, processInstanceId?: string, processInstanceIdIn?: string, processDefinitionId?: string, tenantIdIn?: string, active?: boolean, suspended?: boolean, priorityHigherThanOrEquals?: number, priorityLowerThanOrEquals?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExternalTasksCount(externalTaskId, externalTaskIdIn, topicName, workerId, locked, notLocked, withRetriesLeft, noRetriesLeft, lockExpirationAfter, lockExpirationBefore, activityId, activityIdIn, executionId, processInstanceId, processInstanceIdIn, processDefinitionId, tenantIdIn, active, suspended, priorityHigherThanOrEquals, priorityLowerThanOrEquals, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Queries for distinct topic names of external tasks that fulfill given parameters. Query can be restricted to only tasks with retries left, tasks that are locked, or tasks that are unlocked. The parameters withLockedTasks and withUnlockedTasks are exclusive. Setting them both to true will return an empty list. Providing no parameters will return a list of all distinct topic names with external tasks.
         * @param {boolean} [withLockedTasks] Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [withUnlockedTasks] Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [withRetriesLeft] Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopicNames(withLockedTasks?: boolean, withUnlockedTasks?: boolean, withRetriesLeft?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopicNames(withLockedTasks, withUnlockedTasks, withRetriesLeft, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reports a business error in the context of a running external task by id. The error code must be specified to identify the BPMN error handler.
         * @param {string} id The id of the external task in which context a BPMN error is reported.
         * @param {ExternalTaskBpmnError} [externalTaskBpmnError] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleExternalTaskBpmnError(id: string, externalTaskBpmnError?: ExternalTaskBpmnError, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleExternalTaskBpmnError(id, externalTaskBpmnError, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reports a failure to execute an external task by id. A number of retries and a timeout until the task can be retried can be specified. If retries are set to 0, an incident for this task is created.
         * @param {string} id The id of the external task to report a failure for.
         * @param {ExternalTaskFailureDto} [externalTaskFailureDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleFailure(id: string, externalTaskFailureDto?: ExternalTaskFailureDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleFailure(id, externalTaskFailureDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Queries for external tasks that fulfill given parameters in the form of a JSON object.  This method is slightly more powerful than the [Get External Tasks](https://docs.camunda.org/manual/7.13/reference/rest/external-task/get-query/) method because it allows to specify a hierarchical result sorting.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {ExternalTaskQueryDto} [externalTaskQueryDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryExternalTasks(firstResult?: number, maxResults?: number, externalTaskQueryDto?: ExternalTaskQueryDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExternalTaskDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryExternalTasks(firstResult, maxResults, externalTaskQueryDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Queries for the number of external tasks that fulfill given parameters. This method takes the same message body as the [Get External Tasks (POST)](https://docs.camunda.org/manual/7.13/reference/rest/external-task/post-query/) method.
         * @param {ExternalTaskQueryDto} [externalTaskQueryDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryExternalTasksCount(externalTaskQueryDto?: ExternalTaskQueryDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryExternalTasksCount(externalTaskQueryDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets the priority of an existing external task by id. The default value of a priority is 0.
         * @param {string} id The id of the external task to set the priority for.
         * @param {PriorityDto} [priorityDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setExternalTaskResourcePriority(id: string, priorityDto?: PriorityDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setExternalTaskResourcePriority(id, priorityDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets the number of retries left to execute an external task by id. If retries are set to 0, an  incident is created.
         * @param {string} id The id of the external task to set the number of retries for.
         * @param {RetriesDto} [retriesDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setExternalTaskResourceRetries(id: string, retriesDto?: RetriesDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setExternalTaskResourceRetries(id, retriesDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets the number of retries left to execute external tasks by id synchronously. If retries are set to 0,  an incident is created.
         * @param {SetRetriesForExternalTasksDto} [setRetriesForExternalTasksDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setExternalTaskRetries(setRetriesForExternalTasksDto?: SetRetriesForExternalTasksDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setExternalTaskRetries(setRetriesForExternalTasksDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets the number of retries left to execute external tasks by id asynchronously. If retries are set to 0, an incident is created.
         * @param {SetRetriesForExternalTasksDto} [setRetriesForExternalTasksDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setExternalTaskRetriesAsyncOperation(setRetriesForExternalTasksDto?: SetRetriesForExternalTasksDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setExternalTaskRetriesAsyncOperation(setRetriesForExternalTasksDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Unlocks an external task by id. Clears the task\'s lock expiration time and worker id.
         * @param {string} id The id of the external task to unlock.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlock(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlock(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExternalTaskApi - factory interface
 * @export
 */
export const ExternalTaskApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExternalTaskApiFp(configuration)
    return {
        /**
         * Completes an external task by id and updates process variables.
         * @param {string} id The id of the task to complete.
         * @param {CompleteExternalTaskDto} [completeExternalTaskDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeExternalTaskResource(id: string, completeExternalTaskDto?: CompleteExternalTaskDto, options?: any): AxiosPromise<void> {
            return localVarFp.completeExternalTaskResource(id, completeExternalTaskDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Extends the timeout of the lock by a given amount of time.
         * @param {string} id The id of the external task.
         * @param {ExtendLockOnExternalTaskDto} [extendLockOnExternalTaskDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extendLock(id: string, extendLockOnExternalTaskDto?: ExtendLockOnExternalTaskDto, options?: any): AxiosPromise<void> {
            return localVarFp.extendLock(id, extendLockOnExternalTaskDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches and locks a specific number of external tasks for execution by a worker. Query can be restricted to specific task topics and for each task topic an individual lock time can be provided.
         * @param {FetchExternalTasksDto} [fetchExternalTasksDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAndLock(fetchExternalTasksDto?: FetchExternalTasksDto, options?: any): AxiosPromise<Array<LockedExternalTaskDto>> {
            return localVarFp.fetchAndLock(fetchExternalTasksDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves an external task by id, corresponding to the `ExternalTask` interface in the engine.
         * @param {string} id The id of the external task to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalTask(id: string, options?: any): AxiosPromise<ExternalTaskDto> {
            return localVarFp.getExternalTask(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the error details in the context of a running external task by id.
         * @param {string} id The id of the external task for which the error details should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalTaskErrorDetails(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.getExternalTaskErrorDetails(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for the external tasks that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of executions. The size of the result set can be retrieved by using the [Get External Task Count](https://docs.camunda.org/manual/7.13/reference/rest/external-task/get-query-count/) method.
         * @param {string} [externalTaskId] Filter by an external task\&#39;s id.
         * @param {string} [externalTaskIdIn] Filter by the comma-separated list of external task ids.
         * @param {string} [topicName] Filter by an external task topic.
         * @param {string} [workerId] Filter by the id of the worker that the task was most recently locked by.
         * @param {boolean} [locked] Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [notLocked] Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [withRetriesLeft] Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [noRetriesLeft] Only include external tasks that have 0 retries. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {string} [lockExpirationAfter] Restrict to external tasks that have a lock that expires after a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [lockExpirationBefore] Restrict to external tasks that have a lock that expires before a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [activityId] Filter by the id of the activity that an external task is created for.
         * @param {string} [activityIdIn] Filter by the comma-separated list of ids of the activities that an external task is created for.
         * @param {string} [executionId] Filter by the id of the execution that an external task belongs to.
         * @param {string} [processInstanceId] Filter by the id of the process instance that an external task belongs to.
         * @param {string} [processInstanceIdIn] Filter by a comma-separated list of process instance ids that an external task may belong to.
         * @param {string} [processDefinitionId] Filter by the id of the process definition that an external task belongs to.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. An external task must have one of the given tenant ids.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {number} [priorityHigherThanOrEquals] Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {number} [priorityLowerThanOrEquals] Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {'id' | 'lockExpirationTime' | 'processInstanceId' | 'processDefinitionId' | 'processDefinitionKey' | 'taskPriority' | 'tenantId'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalTasks(externalTaskId?: string, externalTaskIdIn?: string, topicName?: string, workerId?: string, locked?: boolean, notLocked?: boolean, withRetriesLeft?: boolean, noRetriesLeft?: boolean, lockExpirationAfter?: string, lockExpirationBefore?: string, activityId?: string, activityIdIn?: string, executionId?: string, processInstanceId?: string, processInstanceIdIn?: string, processDefinitionId?: string, tenantIdIn?: string, active?: boolean, suspended?: boolean, priorityHigherThanOrEquals?: number, priorityLowerThanOrEquals?: number, sortBy?: 'id' | 'lockExpirationTime' | 'processInstanceId' | 'processDefinitionId' | 'processDefinitionKey' | 'taskPriority' | 'tenantId', sortOrder?: 'asc' | 'desc', firstResult?: number, maxResults?: number, options?: any): AxiosPromise<Array<ExternalTaskDto>> {
            return localVarFp.getExternalTasks(externalTaskId, externalTaskIdIn, topicName, workerId, locked, notLocked, withRetriesLeft, noRetriesLeft, lockExpirationAfter, lockExpirationBefore, activityId, activityIdIn, executionId, processInstanceId, processInstanceIdIn, processDefinitionId, tenantIdIn, active, suspended, priorityHigherThanOrEquals, priorityLowerThanOrEquals, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for the number of external tasks that fulfill given parameters. Takes the same parameters as the [Get External Tasks](https://docs.camunda.org/manual/7.13/reference/rest/external-task/get-query/) method.
         * @param {string} [externalTaskId] Filter by an external task\&#39;s id.
         * @param {string} [externalTaskIdIn] Filter by the comma-separated list of external task ids.
         * @param {string} [topicName] Filter by an external task topic.
         * @param {string} [workerId] Filter by the id of the worker that the task was most recently locked by.
         * @param {boolean} [locked] Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [notLocked] Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [withRetriesLeft] Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [noRetriesLeft] Only include external tasks that have 0 retries. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {string} [lockExpirationAfter] Restrict to external tasks that have a lock that expires after a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [lockExpirationBefore] Restrict to external tasks that have a lock that expires before a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [activityId] Filter by the id of the activity that an external task is created for.
         * @param {string} [activityIdIn] Filter by the comma-separated list of ids of the activities that an external task is created for.
         * @param {string} [executionId] Filter by the id of the execution that an external task belongs to.
         * @param {string} [processInstanceId] Filter by the id of the process instance that an external task belongs to.
         * @param {string} [processInstanceIdIn] Filter by a comma-separated list of process instance ids that an external task may belong to.
         * @param {string} [processDefinitionId] Filter by the id of the process definition that an external task belongs to.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. An external task must have one of the given tenant ids.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {number} [priorityHigherThanOrEquals] Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {number} [priorityLowerThanOrEquals] Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalTasksCount(externalTaskId?: string, externalTaskIdIn?: string, topicName?: string, workerId?: string, locked?: boolean, notLocked?: boolean, withRetriesLeft?: boolean, noRetriesLeft?: boolean, lockExpirationAfter?: string, lockExpirationBefore?: string, activityId?: string, activityIdIn?: string, executionId?: string, processInstanceId?: string, processInstanceIdIn?: string, processDefinitionId?: string, tenantIdIn?: string, active?: boolean, suspended?: boolean, priorityHigherThanOrEquals?: number, priorityLowerThanOrEquals?: number, options?: any): AxiosPromise<CountResultDto> {
            return localVarFp.getExternalTasksCount(externalTaskId, externalTaskIdIn, topicName, workerId, locked, notLocked, withRetriesLeft, noRetriesLeft, lockExpirationAfter, lockExpirationBefore, activityId, activityIdIn, executionId, processInstanceId, processInstanceIdIn, processDefinitionId, tenantIdIn, active, suspended, priorityHigherThanOrEquals, priorityLowerThanOrEquals, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for distinct topic names of external tasks that fulfill given parameters. Query can be restricted to only tasks with retries left, tasks that are locked, or tasks that are unlocked. The parameters withLockedTasks and withUnlockedTasks are exclusive. Setting them both to true will return an empty list. Providing no parameters will return a list of all distinct topic names with external tasks.
         * @param {boolean} [withLockedTasks] Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [withUnlockedTasks] Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [withRetriesLeft] Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicNames(withLockedTasks?: boolean, withUnlockedTasks?: boolean, withRetriesLeft?: boolean, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getTopicNames(withLockedTasks, withUnlockedTasks, withRetriesLeft, options).then((request) => request(axios, basePath));
        },
        /**
         * Reports a business error in the context of a running external task by id. The error code must be specified to identify the BPMN error handler.
         * @param {string} id The id of the external task in which context a BPMN error is reported.
         * @param {ExternalTaskBpmnError} [externalTaskBpmnError] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleExternalTaskBpmnError(id: string, externalTaskBpmnError?: ExternalTaskBpmnError, options?: any): AxiosPromise<void> {
            return localVarFp.handleExternalTaskBpmnError(id, externalTaskBpmnError, options).then((request) => request(axios, basePath));
        },
        /**
         * Reports a failure to execute an external task by id. A number of retries and a timeout until the task can be retried can be specified. If retries are set to 0, an incident for this task is created.
         * @param {string} id The id of the external task to report a failure for.
         * @param {ExternalTaskFailureDto} [externalTaskFailureDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleFailure(id: string, externalTaskFailureDto?: ExternalTaskFailureDto, options?: any): AxiosPromise<void> {
            return localVarFp.handleFailure(id, externalTaskFailureDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for external tasks that fulfill given parameters in the form of a JSON object.  This method is slightly more powerful than the [Get External Tasks](https://docs.camunda.org/manual/7.13/reference/rest/external-task/get-query/) method because it allows to specify a hierarchical result sorting.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {ExternalTaskQueryDto} [externalTaskQueryDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryExternalTasks(firstResult?: number, maxResults?: number, externalTaskQueryDto?: ExternalTaskQueryDto, options?: any): AxiosPromise<Array<ExternalTaskDto>> {
            return localVarFp.queryExternalTasks(firstResult, maxResults, externalTaskQueryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for the number of external tasks that fulfill given parameters. This method takes the same message body as the [Get External Tasks (POST)](https://docs.camunda.org/manual/7.13/reference/rest/external-task/post-query/) method.
         * @param {ExternalTaskQueryDto} [externalTaskQueryDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryExternalTasksCount(externalTaskQueryDto?: ExternalTaskQueryDto, options?: any): AxiosPromise<CountResultDto> {
            return localVarFp.queryExternalTasksCount(externalTaskQueryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the priority of an existing external task by id. The default value of a priority is 0.
         * @param {string} id The id of the external task to set the priority for.
         * @param {PriorityDto} [priorityDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalTaskResourcePriority(id: string, priorityDto?: PriorityDto, options?: any): AxiosPromise<void> {
            return localVarFp.setExternalTaskResourcePriority(id, priorityDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the number of retries left to execute an external task by id. If retries are set to 0, an  incident is created.
         * @param {string} id The id of the external task to set the number of retries for.
         * @param {RetriesDto} [retriesDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalTaskResourceRetries(id: string, retriesDto?: RetriesDto, options?: any): AxiosPromise<void> {
            return localVarFp.setExternalTaskResourceRetries(id, retriesDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the number of retries left to execute external tasks by id synchronously. If retries are set to 0,  an incident is created.
         * @param {SetRetriesForExternalTasksDto} [setRetriesForExternalTasksDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalTaskRetries(setRetriesForExternalTasksDto?: SetRetriesForExternalTasksDto, options?: any): AxiosPromise<void> {
            return localVarFp.setExternalTaskRetries(setRetriesForExternalTasksDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the number of retries left to execute external tasks by id asynchronously. If retries are set to 0, an incident is created.
         * @param {SetRetriesForExternalTasksDto} [setRetriesForExternalTasksDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalTaskRetriesAsyncOperation(setRetriesForExternalTasksDto?: SetRetriesForExternalTasksDto, options?: any): AxiosPromise<BatchDto> {
            return localVarFp.setExternalTaskRetriesAsyncOperation(setRetriesForExternalTasksDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Unlocks an external task by id. Clears the task\'s lock expiration time and worker id.
         * @param {string} id The id of the external task to unlock.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlock(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.unlock(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExternalTaskApi - object-oriented interface
 * @export
 * @class ExternalTaskApi
 * @extends {BaseAPI}
 */
export class ExternalTaskApi extends BaseAPI {
    /**
     * Completes an external task by id and updates process variables.
     * @param {string} id The id of the task to complete.
     * @param {CompleteExternalTaskDto} [completeExternalTaskDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    public completeExternalTaskResource(id: string, completeExternalTaskDto?: CompleteExternalTaskDto, options?: AxiosRequestConfig) {
        return ExternalTaskApiFp(this.configuration).completeExternalTaskResource(id, completeExternalTaskDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Extends the timeout of the lock by a given amount of time.
     * @param {string} id The id of the external task.
     * @param {ExtendLockOnExternalTaskDto} [extendLockOnExternalTaskDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    public extendLock(id: string, extendLockOnExternalTaskDto?: ExtendLockOnExternalTaskDto, options?: AxiosRequestConfig) {
        return ExternalTaskApiFp(this.configuration).extendLock(id, extendLockOnExternalTaskDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches and locks a specific number of external tasks for execution by a worker. Query can be restricted to specific task topics and for each task topic an individual lock time can be provided.
     * @param {FetchExternalTasksDto} [fetchExternalTasksDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    public fetchAndLock(fetchExternalTasksDto?: FetchExternalTasksDto, options?: AxiosRequestConfig) {
        return ExternalTaskApiFp(this.configuration).fetchAndLock(fetchExternalTasksDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves an external task by id, corresponding to the `ExternalTask` interface in the engine.
     * @param {string} id The id of the external task to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    public getExternalTask(id: string, options?: AxiosRequestConfig) {
        return ExternalTaskApiFp(this.configuration).getExternalTask(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the error details in the context of a running external task by id.
     * @param {string} id The id of the external task for which the error details should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    public getExternalTaskErrorDetails(id: string, options?: AxiosRequestConfig) {
        return ExternalTaskApiFp(this.configuration).getExternalTaskErrorDetails(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Queries for the external tasks that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of executions. The size of the result set can be retrieved by using the [Get External Task Count](https://docs.camunda.org/manual/7.13/reference/rest/external-task/get-query-count/) method.
     * @param {string} [externalTaskId] Filter by an external task\&#39;s id.
     * @param {string} [externalTaskIdIn] Filter by the comma-separated list of external task ids.
     * @param {string} [topicName] Filter by an external task topic.
     * @param {string} [workerId] Filter by the id of the worker that the task was most recently locked by.
     * @param {boolean} [locked] Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {boolean} [notLocked] Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {boolean} [withRetriesLeft] Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {boolean} [noRetriesLeft] Only include external tasks that have 0 retries. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {string} [lockExpirationAfter] Restrict to external tasks that have a lock that expires after a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {string} [lockExpirationBefore] Restrict to external tasks that have a lock that expires before a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {string} [activityId] Filter by the id of the activity that an external task is created for.
     * @param {string} [activityIdIn] Filter by the comma-separated list of ids of the activities that an external task is created for.
     * @param {string} [executionId] Filter by the id of the execution that an external task belongs to.
     * @param {string} [processInstanceId] Filter by the id of the process instance that an external task belongs to.
     * @param {string} [processInstanceIdIn] Filter by a comma-separated list of process instance ids that an external task may belong to.
     * @param {string} [processDefinitionId] Filter by the id of the process definition that an external task belongs to.
     * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. An external task must have one of the given tenant ids.
     * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {number} [priorityHigherThanOrEquals] Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
     * @param {number} [priorityLowerThanOrEquals] Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
     * @param {'id' | 'lockExpirationTime' | 'processInstanceId' | 'processDefinitionId' | 'processDefinitionKey' | 'taskPriority' | 'tenantId'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    public getExternalTasks(externalTaskId?: string, externalTaskIdIn?: string, topicName?: string, workerId?: string, locked?: boolean, notLocked?: boolean, withRetriesLeft?: boolean, noRetriesLeft?: boolean, lockExpirationAfter?: string, lockExpirationBefore?: string, activityId?: string, activityIdIn?: string, executionId?: string, processInstanceId?: string, processInstanceIdIn?: string, processDefinitionId?: string, tenantIdIn?: string, active?: boolean, suspended?: boolean, priorityHigherThanOrEquals?: number, priorityLowerThanOrEquals?: number, sortBy?: 'id' | 'lockExpirationTime' | 'processInstanceId' | 'processDefinitionId' | 'processDefinitionKey' | 'taskPriority' | 'tenantId', sortOrder?: 'asc' | 'desc', firstResult?: number, maxResults?: number, options?: AxiosRequestConfig) {
        return ExternalTaskApiFp(this.configuration).getExternalTasks(externalTaskId, externalTaskIdIn, topicName, workerId, locked, notLocked, withRetriesLeft, noRetriesLeft, lockExpirationAfter, lockExpirationBefore, activityId, activityIdIn, executionId, processInstanceId, processInstanceIdIn, processDefinitionId, tenantIdIn, active, suspended, priorityHigherThanOrEquals, priorityLowerThanOrEquals, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Queries for the number of external tasks that fulfill given parameters. Takes the same parameters as the [Get External Tasks](https://docs.camunda.org/manual/7.13/reference/rest/external-task/get-query/) method.
     * @param {string} [externalTaskId] Filter by an external task\&#39;s id.
     * @param {string} [externalTaskIdIn] Filter by the comma-separated list of external task ids.
     * @param {string} [topicName] Filter by an external task topic.
     * @param {string} [workerId] Filter by the id of the worker that the task was most recently locked by.
     * @param {boolean} [locked] Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {boolean} [notLocked] Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {boolean} [withRetriesLeft] Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {boolean} [noRetriesLeft] Only include external tasks that have 0 retries. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {string} [lockExpirationAfter] Restrict to external tasks that have a lock that expires after a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {string} [lockExpirationBefore] Restrict to external tasks that have a lock that expires before a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {string} [activityId] Filter by the id of the activity that an external task is created for.
     * @param {string} [activityIdIn] Filter by the comma-separated list of ids of the activities that an external task is created for.
     * @param {string} [executionId] Filter by the id of the execution that an external task belongs to.
     * @param {string} [processInstanceId] Filter by the id of the process instance that an external task belongs to.
     * @param {string} [processInstanceIdIn] Filter by a comma-separated list of process instance ids that an external task may belong to.
     * @param {string} [processDefinitionId] Filter by the id of the process definition that an external task belongs to.
     * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. An external task must have one of the given tenant ids.
     * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {number} [priorityHigherThanOrEquals] Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
     * @param {number} [priorityLowerThanOrEquals] Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    public getExternalTasksCount(externalTaskId?: string, externalTaskIdIn?: string, topicName?: string, workerId?: string, locked?: boolean, notLocked?: boolean, withRetriesLeft?: boolean, noRetriesLeft?: boolean, lockExpirationAfter?: string, lockExpirationBefore?: string, activityId?: string, activityIdIn?: string, executionId?: string, processInstanceId?: string, processInstanceIdIn?: string, processDefinitionId?: string, tenantIdIn?: string, active?: boolean, suspended?: boolean, priorityHigherThanOrEquals?: number, priorityLowerThanOrEquals?: number, options?: AxiosRequestConfig) {
        return ExternalTaskApiFp(this.configuration).getExternalTasksCount(externalTaskId, externalTaskIdIn, topicName, workerId, locked, notLocked, withRetriesLeft, noRetriesLeft, lockExpirationAfter, lockExpirationBefore, activityId, activityIdIn, executionId, processInstanceId, processInstanceIdIn, processDefinitionId, tenantIdIn, active, suspended, priorityHigherThanOrEquals, priorityLowerThanOrEquals, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Queries for distinct topic names of external tasks that fulfill given parameters. Query can be restricted to only tasks with retries left, tasks that are locked, or tasks that are unlocked. The parameters withLockedTasks and withUnlockedTasks are exclusive. Setting them both to true will return an empty list. Providing no parameters will return a list of all distinct topic names with external tasks.
     * @param {boolean} [withLockedTasks] Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {boolean} [withUnlockedTasks] Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {boolean} [withRetriesLeft] Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    public getTopicNames(withLockedTasks?: boolean, withUnlockedTasks?: boolean, withRetriesLeft?: boolean, options?: AxiosRequestConfig) {
        return ExternalTaskApiFp(this.configuration).getTopicNames(withLockedTasks, withUnlockedTasks, withRetriesLeft, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reports a business error in the context of a running external task by id. The error code must be specified to identify the BPMN error handler.
     * @param {string} id The id of the external task in which context a BPMN error is reported.
     * @param {ExternalTaskBpmnError} [externalTaskBpmnError] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    public handleExternalTaskBpmnError(id: string, externalTaskBpmnError?: ExternalTaskBpmnError, options?: AxiosRequestConfig) {
        return ExternalTaskApiFp(this.configuration).handleExternalTaskBpmnError(id, externalTaskBpmnError, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reports a failure to execute an external task by id. A number of retries and a timeout until the task can be retried can be specified. If retries are set to 0, an incident for this task is created.
     * @param {string} id The id of the external task to report a failure for.
     * @param {ExternalTaskFailureDto} [externalTaskFailureDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    public handleFailure(id: string, externalTaskFailureDto?: ExternalTaskFailureDto, options?: AxiosRequestConfig) {
        return ExternalTaskApiFp(this.configuration).handleFailure(id, externalTaskFailureDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Queries for external tasks that fulfill given parameters in the form of a JSON object.  This method is slightly more powerful than the [Get External Tasks](https://docs.camunda.org/manual/7.13/reference/rest/external-task/get-query/) method because it allows to specify a hierarchical result sorting.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {ExternalTaskQueryDto} [externalTaskQueryDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    public queryExternalTasks(firstResult?: number, maxResults?: number, externalTaskQueryDto?: ExternalTaskQueryDto, options?: AxiosRequestConfig) {
        return ExternalTaskApiFp(this.configuration).queryExternalTasks(firstResult, maxResults, externalTaskQueryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Queries for the number of external tasks that fulfill given parameters. This method takes the same message body as the [Get External Tasks (POST)](https://docs.camunda.org/manual/7.13/reference/rest/external-task/post-query/) method.
     * @param {ExternalTaskQueryDto} [externalTaskQueryDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    public queryExternalTasksCount(externalTaskQueryDto?: ExternalTaskQueryDto, options?: AxiosRequestConfig) {
        return ExternalTaskApiFp(this.configuration).queryExternalTasksCount(externalTaskQueryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets the priority of an existing external task by id. The default value of a priority is 0.
     * @param {string} id The id of the external task to set the priority for.
     * @param {PriorityDto} [priorityDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    public setExternalTaskResourcePriority(id: string, priorityDto?: PriorityDto, options?: AxiosRequestConfig) {
        return ExternalTaskApiFp(this.configuration).setExternalTaskResourcePriority(id, priorityDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets the number of retries left to execute an external task by id. If retries are set to 0, an  incident is created.
     * @param {string} id The id of the external task to set the number of retries for.
     * @param {RetriesDto} [retriesDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    public setExternalTaskResourceRetries(id: string, retriesDto?: RetriesDto, options?: AxiosRequestConfig) {
        return ExternalTaskApiFp(this.configuration).setExternalTaskResourceRetries(id, retriesDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets the number of retries left to execute external tasks by id synchronously. If retries are set to 0,  an incident is created.
     * @param {SetRetriesForExternalTasksDto} [setRetriesForExternalTasksDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    public setExternalTaskRetries(setRetriesForExternalTasksDto?: SetRetriesForExternalTasksDto, options?: AxiosRequestConfig) {
        return ExternalTaskApiFp(this.configuration).setExternalTaskRetries(setRetriesForExternalTasksDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets the number of retries left to execute external tasks by id asynchronously. If retries are set to 0, an incident is created.
     * @param {SetRetriesForExternalTasksDto} [setRetriesForExternalTasksDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    public setExternalTaskRetriesAsyncOperation(setRetriesForExternalTasksDto?: SetRetriesForExternalTasksDto, options?: AxiosRequestConfig) {
        return ExternalTaskApiFp(this.configuration).setExternalTaskRetriesAsyncOperation(setRetriesForExternalTasksDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unlocks an external task by id. Clears the task\'s lock expiration time and worker id.
     * @param {string} id The id of the external task to unlock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    public unlock(id: string, options?: AxiosRequestConfig) {
        return ExternalTaskApiFp(this.configuration).unlock(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MessageApi - axios parameter creator
 * @export
 */
export const MessageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Correlates a message to the process engine to either trigger a message start event or an intermediate message  catching event. Internally this maps to the engine\'s message correlation builder methods `MessageCorrelationBuilder#correlateWithResult()` and `MessageCorrelationBuilder#correlateAllWithResult()`. For more information about the correlation behavior, see the [Message Events](https://docs.camunda.org/manual/7.13/bpmn20/events/message-events/) section of the [BPMN 2.0 Implementation Reference](https://docs.camunda.org/manual/7.13/reference/bpmn20/).
         * @param {CorrelationMessageDto} [correlationMessageDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliverMessage: async (correlationMessageDto?: CorrelationMessageDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/message`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(correlationMessageDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessageApi - functional programming interface
 * @export
 */
export const MessageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessageApiAxiosParamCreator(configuration)
    return {
        /**
         * Correlates a message to the process engine to either trigger a message start event or an intermediate message  catching event. Internally this maps to the engine\'s message correlation builder methods `MessageCorrelationBuilder#correlateWithResult()` and `MessageCorrelationBuilder#correlateAllWithResult()`. For more information about the correlation behavior, see the [Message Events](https://docs.camunda.org/manual/7.13/bpmn20/events/message-events/) section of the [BPMN 2.0 Implementation Reference](https://docs.camunda.org/manual/7.13/reference/bpmn20/).
         * @param {CorrelationMessageDto} [correlationMessageDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deliverMessage(correlationMessageDto?: CorrelationMessageDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MessageCorrelationResultWithVariableDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deliverMessage(correlationMessageDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MessageApi - factory interface
 * @export
 */
export const MessageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessageApiFp(configuration)
    return {
        /**
         * Correlates a message to the process engine to either trigger a message start event or an intermediate message  catching event. Internally this maps to the engine\'s message correlation builder methods `MessageCorrelationBuilder#correlateWithResult()` and `MessageCorrelationBuilder#correlateAllWithResult()`. For more information about the correlation behavior, see the [Message Events](https://docs.camunda.org/manual/7.13/bpmn20/events/message-events/) section of the [BPMN 2.0 Implementation Reference](https://docs.camunda.org/manual/7.13/reference/bpmn20/).
         * @param {CorrelationMessageDto} [correlationMessageDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliverMessage(correlationMessageDto?: CorrelationMessageDto, options?: any): AxiosPromise<Array<MessageCorrelationResultWithVariableDto>> {
            return localVarFp.deliverMessage(correlationMessageDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MessageApi - object-oriented interface
 * @export
 * @class MessageApi
 * @extends {BaseAPI}
 */
export class MessageApi extends BaseAPI {
    /**
     * Correlates a message to the process engine to either trigger a message start event or an intermediate message  catching event. Internally this maps to the engine\'s message correlation builder methods `MessageCorrelationBuilder#correlateWithResult()` and `MessageCorrelationBuilder#correlateAllWithResult()`. For more information about the correlation behavior, see the [Message Events](https://docs.camunda.org/manual/7.13/bpmn20/events/message-events/) section of the [BPMN 2.0 Implementation Reference](https://docs.camunda.org/manual/7.13/reference/bpmn20/).
     * @param {CorrelationMessageDto} [correlationMessageDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    public deliverMessage(correlationMessageDto?: CorrelationMessageDto, options?: AxiosRequestConfig) {
        return MessageApiFp(this.configuration).deliverMessage(correlationMessageDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MetricsApi - axios parameter creator
 * @export
 */
export const MetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the `sum` (count) for a given metric.
         * @param {'activity-instance-start' | 'activity-instance-end' | 'job-acquisition-attempt' | 'job-acquired-success' | 'job-acquired-failure' | 'job-execution-rejected' | 'job-successful' | 'job-failed' | 'job-locked-exclusive' | 'executed-decision-elements' | 'history-cleanup-removed-process-instances' | 'history-cleanup-removed-case-instances' | 'history-cleanup-removed-decision-instances' | 'history-cleanup-removed-batch-operations'} metricsName The name of the metric.
         * @param {string} [startDate] The start date (inclusive).
         * @param {string} [endDate] The end date (exclusive).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics: async (metricsName: 'activity-instance-start' | 'activity-instance-end' | 'job-acquisition-attempt' | 'job-acquired-success' | 'job-acquired-failure' | 'job-execution-rejected' | 'job-successful' | 'job-failed' | 'job-locked-exclusive' | 'executed-decision-elements' | 'history-cleanup-removed-process-instances' | 'history-cleanup-removed-case-instances' | 'history-cleanup-removed-decision-instances' | 'history-cleanup-removed-batch-operations', startDate?: string, endDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'metricsName' is not null or undefined
            assertParamExists('getMetrics', 'metricsName', metricsName)
            const localVarPath = `/metrics/{metrics-name}/sum`
                .replace(`{${"metrics-name"}}`, encodeURIComponent(String(metricsName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of metrics, aggregated for a given interval.
         * @param {'activity-instance-start' | 'activity-instance-end' | 'job-acquisition-attempt' | 'job-acquired-success' | 'job-acquired-failure' | 'job-execution-rejected' | 'job-successful' | 'job-failed' | 'job-locked-exclusive' | 'executed-decision-elements' | 'history-cleanup-removed-process-instances' | 'history-cleanup-removed-case-instances' | 'history-cleanup-removed-decision-instances' | 'history-cleanup-removed-batch-operations'} [name] The name of the metric.
         * @param {string} [reporter] The name of the reporter (host), on which the metrics was logged. This will have value provided by the [hostname configuration property](https://docs.camunda.org/manual/7.13/reference/deployment-descriptors/tags/process-engine/#hostname).
         * @param {string} [startDate] The start date (inclusive).
         * @param {string} [endDate] The end date (exclusive).
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {string} [interval] The interval for which the metrics should be aggregated. Time unit is seconds. Default: The interval is set to 15 minutes (900 seconds).
         * @param {string} [aggregateByReporter] Aggregate metrics by reporter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interval: async (name?: 'activity-instance-start' | 'activity-instance-end' | 'job-acquisition-attempt' | 'job-acquired-success' | 'job-acquired-failure' | 'job-execution-rejected' | 'job-successful' | 'job-failed' | 'job-locked-exclusive' | 'executed-decision-elements' | 'history-cleanup-removed-process-instances' | 'history-cleanup-removed-case-instances' | 'history-cleanup-removed-decision-instances' | 'history-cleanup-removed-batch-operations', reporter?: string, startDate?: string, endDate?: string, firstResult?: number, maxResults?: number, interval?: string, aggregateByReporter?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (reporter !== undefined) {
                localVarQueryParameter['reporter'] = reporter;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (aggregateByReporter !== undefined) {
                localVarQueryParameter['aggregateByReporter'] = aggregateByReporter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the `sum` (count) for a given metric.
         * @param {'activity-instance-start' | 'activity-instance-end' | 'job-acquisition-attempt' | 'job-acquired-success' | 'job-acquired-failure' | 'job-execution-rejected' | 'job-successful' | 'job-failed' | 'job-locked-exclusive' | 'executed-decision-elements' | 'history-cleanup-removed-process-instances' | 'history-cleanup-removed-case-instances' | 'history-cleanup-removed-decision-instances' | 'history-cleanup-removed-batch-operations'} metricsName The name of the metric.
         * @param {string} [startDate] The start date (inclusive).
         * @param {string} [endDate] The end date (exclusive).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetrics(metricsName: 'activity-instance-start' | 'activity-instance-end' | 'job-acquisition-attempt' | 'job-acquired-success' | 'job-acquired-failure' | 'job-execution-rejected' | 'job-successful' | 'job-failed' | 'job-locked-exclusive' | 'executed-decision-elements' | 'history-cleanup-removed-process-instances' | 'history-cleanup-removed-case-instances' | 'history-cleanup-removed-decision-instances' | 'history-cleanup-removed-batch-operations', startDate?: string, endDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetrics(metricsName, startDate, endDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of metrics, aggregated for a given interval.
         * @param {'activity-instance-start' | 'activity-instance-end' | 'job-acquisition-attempt' | 'job-acquired-success' | 'job-acquired-failure' | 'job-execution-rejected' | 'job-successful' | 'job-failed' | 'job-locked-exclusive' | 'executed-decision-elements' | 'history-cleanup-removed-process-instances' | 'history-cleanup-removed-case-instances' | 'history-cleanup-removed-decision-instances' | 'history-cleanup-removed-batch-operations'} [name] The name of the metric.
         * @param {string} [reporter] The name of the reporter (host), on which the metrics was logged. This will have value provided by the [hostname configuration property](https://docs.camunda.org/manual/7.13/reference/deployment-descriptors/tags/process-engine/#hostname).
         * @param {string} [startDate] The start date (inclusive).
         * @param {string} [endDate] The end date (exclusive).
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {string} [interval] The interval for which the metrics should be aggregated. Time unit is seconds. Default: The interval is set to 15 minutes (900 seconds).
         * @param {string} [aggregateByReporter] Aggregate metrics by reporter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async interval(name?: 'activity-instance-start' | 'activity-instance-end' | 'job-acquisition-attempt' | 'job-acquired-success' | 'job-acquired-failure' | 'job-execution-rejected' | 'job-successful' | 'job-failed' | 'job-locked-exclusive' | 'executed-decision-elements' | 'history-cleanup-removed-process-instances' | 'history-cleanup-removed-case-instances' | 'history-cleanup-removed-decision-instances' | 'history-cleanup-removed-batch-operations', reporter?: string, startDate?: string, endDate?: string, firstResult?: number, maxResults?: number, interval?: string, aggregateByReporter?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MetricsIntervalResultDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.interval(name, reporter, startDate, endDate, firstResult, maxResults, interval, aggregateByReporter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetricsApiFp(configuration)
    return {
        /**
         * Retrieves the `sum` (count) for a given metric.
         * @param {'activity-instance-start' | 'activity-instance-end' | 'job-acquisition-attempt' | 'job-acquired-success' | 'job-acquired-failure' | 'job-execution-rejected' | 'job-successful' | 'job-failed' | 'job-locked-exclusive' | 'executed-decision-elements' | 'history-cleanup-removed-process-instances' | 'history-cleanup-removed-case-instances' | 'history-cleanup-removed-decision-instances' | 'history-cleanup-removed-batch-operations'} metricsName The name of the metric.
         * @param {string} [startDate] The start date (inclusive).
         * @param {string} [endDate] The end date (exclusive).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics(metricsName: 'activity-instance-start' | 'activity-instance-end' | 'job-acquisition-attempt' | 'job-acquired-success' | 'job-acquired-failure' | 'job-execution-rejected' | 'job-successful' | 'job-failed' | 'job-locked-exclusive' | 'executed-decision-elements' | 'history-cleanup-removed-process-instances' | 'history-cleanup-removed-case-instances' | 'history-cleanup-removed-decision-instances' | 'history-cleanup-removed-batch-operations', startDate?: string, endDate?: string, options?: any): AxiosPromise<MetricsResultDto> {
            return localVarFp.getMetrics(metricsName, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of metrics, aggregated for a given interval.
         * @param {'activity-instance-start' | 'activity-instance-end' | 'job-acquisition-attempt' | 'job-acquired-success' | 'job-acquired-failure' | 'job-execution-rejected' | 'job-successful' | 'job-failed' | 'job-locked-exclusive' | 'executed-decision-elements' | 'history-cleanup-removed-process-instances' | 'history-cleanup-removed-case-instances' | 'history-cleanup-removed-decision-instances' | 'history-cleanup-removed-batch-operations'} [name] The name of the metric.
         * @param {string} [reporter] The name of the reporter (host), on which the metrics was logged. This will have value provided by the [hostname configuration property](https://docs.camunda.org/manual/7.13/reference/deployment-descriptors/tags/process-engine/#hostname).
         * @param {string} [startDate] The start date (inclusive).
         * @param {string} [endDate] The end date (exclusive).
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {string} [interval] The interval for which the metrics should be aggregated. Time unit is seconds. Default: The interval is set to 15 minutes (900 seconds).
         * @param {string} [aggregateByReporter] Aggregate metrics by reporter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interval(name?: 'activity-instance-start' | 'activity-instance-end' | 'job-acquisition-attempt' | 'job-acquired-success' | 'job-acquired-failure' | 'job-execution-rejected' | 'job-successful' | 'job-failed' | 'job-locked-exclusive' | 'executed-decision-elements' | 'history-cleanup-removed-process-instances' | 'history-cleanup-removed-case-instances' | 'history-cleanup-removed-decision-instances' | 'history-cleanup-removed-batch-operations', reporter?: string, startDate?: string, endDate?: string, firstResult?: number, maxResults?: number, interval?: string, aggregateByReporter?: string, options?: any): AxiosPromise<Array<MetricsIntervalResultDto>> {
            return localVarFp.interval(name, reporter, startDate, endDate, firstResult, maxResults, interval, aggregateByReporter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
    /**
     * Retrieves the `sum` (count) for a given metric.
     * @param {'activity-instance-start' | 'activity-instance-end' | 'job-acquisition-attempt' | 'job-acquired-success' | 'job-acquired-failure' | 'job-execution-rejected' | 'job-successful' | 'job-failed' | 'job-locked-exclusive' | 'executed-decision-elements' | 'history-cleanup-removed-process-instances' | 'history-cleanup-removed-case-instances' | 'history-cleanup-removed-decision-instances' | 'history-cleanup-removed-batch-operations'} metricsName The name of the metric.
     * @param {string} [startDate] The start date (inclusive).
     * @param {string} [endDate] The end date (exclusive).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getMetrics(metricsName: 'activity-instance-start' | 'activity-instance-end' | 'job-acquisition-attempt' | 'job-acquired-success' | 'job-acquired-failure' | 'job-execution-rejected' | 'job-successful' | 'job-failed' | 'job-locked-exclusive' | 'executed-decision-elements' | 'history-cleanup-removed-process-instances' | 'history-cleanup-removed-case-instances' | 'history-cleanup-removed-decision-instances' | 'history-cleanup-removed-batch-operations', startDate?: string, endDate?: string, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).getMetrics(metricsName, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of metrics, aggregated for a given interval.
     * @param {'activity-instance-start' | 'activity-instance-end' | 'job-acquisition-attempt' | 'job-acquired-success' | 'job-acquired-failure' | 'job-execution-rejected' | 'job-successful' | 'job-failed' | 'job-locked-exclusive' | 'executed-decision-elements' | 'history-cleanup-removed-process-instances' | 'history-cleanup-removed-case-instances' | 'history-cleanup-removed-decision-instances' | 'history-cleanup-removed-batch-operations'} [name] The name of the metric.
     * @param {string} [reporter] The name of the reporter (host), on which the metrics was logged. This will have value provided by the [hostname configuration property](https://docs.camunda.org/manual/7.13/reference/deployment-descriptors/tags/process-engine/#hostname).
     * @param {string} [startDate] The start date (inclusive).
     * @param {string} [endDate] The end date (exclusive).
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {string} [interval] The interval for which the metrics should be aggregated. Time unit is seconds. Default: The interval is set to 15 minutes (900 seconds).
     * @param {string} [aggregateByReporter] Aggregate metrics by reporter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public interval(name?: 'activity-instance-start' | 'activity-instance-end' | 'job-acquisition-attempt' | 'job-acquired-success' | 'job-acquired-failure' | 'job-execution-rejected' | 'job-successful' | 'job-failed' | 'job-locked-exclusive' | 'executed-decision-elements' | 'history-cleanup-removed-process-instances' | 'history-cleanup-removed-case-instances' | 'history-cleanup-removed-decision-instances' | 'history-cleanup-removed-batch-operations', reporter?: string, startDate?: string, endDate?: string, firstResult?: number, maxResults?: number, interval?: string, aggregateByReporter?: string, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).interval(name, reporter, startDate, endDate, firstResult, maxResults, interval, aggregateByReporter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProcessDefinitionApi - axios parameter creator
 * @export
 */
export const ProcessDefinitionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a running process instance by id.
         * @summary Delete
         * @param {string} id The id of the process definition to be deleted.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessDefinition: async (id: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProcessDefinition', 'id', id)
            const localVarPath = `/process-definition/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cascade !== undefined) {
                localVarQueryParameter['cascade'] = cascade;
            }

            if (skipCustomListeners !== undefined) {
                localVarQueryParameter['skipCustomListeners'] = skipCustomListeners;
            }

            if (skipIoMappings !== undefined) {
                localVarQueryParameter['skipIoMappings'] = skipIoMappings;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes process definitions by a given key which belong to no tenant id.
         * @summary Delete By Key
         * @param {string} key The key of the process definitions to be deleted.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessDefinitionsByKey: async (key: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('deleteProcessDefinitionsByKey', 'key', key)
            const localVarPath = `/process-definition/key/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cascade !== undefined) {
                localVarQueryParameter['cascade'] = cascade;
            }

            if (skipCustomListeners !== undefined) {
                localVarQueryParameter['skipCustomListeners'] = skipCustomListeners;
            }

            if (skipIoMappings !== undefined) {
                localVarQueryParameter['skipIoMappings'] = skipIoMappings;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes process definitions by a given key and which belong to a tenant id.
         * @summary Delete By Key
         * @param {string} key The key of the process definitions to be deleted.
         * @param {string} tenantId The id of the tenant the process definitions belong to.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessDefinitionsByKeyAndTenantId: async (key: string, tenantId: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('deleteProcessDefinitionsByKeyAndTenantId', 'key', key)
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('deleteProcessDefinitionsByKeyAndTenantId', 'tenantId', tenantId)
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cascade !== undefined) {
                localVarQueryParameter['cascade'] = cascade;
            }

            if (skipCustomListeners !== undefined) {
                localVarQueryParameter['skipCustomListeners'] = skipCustomListeners;
            }

            if (skipIoMappings !== undefined) {
                localVarQueryParameter['skipIoMappings'] = skipIoMappings;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves runtime statistics of a given process definition, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Activity Instance Statistics
         * @param {string} id The id of the process definition.
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityStatistics: async (id: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getActivityStatistics', 'id', id)
            const localVarPath = `/process-definition/{id}/statistics`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (failedJobs !== undefined) {
                localVarQueryParameter['failedJobs'] = failedJobs;
            }

            if (incidents !== undefined) {
                localVarQueryParameter['incidents'] = incidents;
            }

            if (incidentsForType !== undefined) {
                localVarQueryParameter['incidentsForType'] = incidentsForType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves runtime statistics of the latest version of the given process definition which belongs to no tenant, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Activity Instance Statistics
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityStatisticsByProcessDefinitionKey: async (key: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getActivityStatisticsByProcessDefinitionKey', 'key', key)
            const localVarPath = `/process-definition/key/{key}/statistics`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (failedJobs !== undefined) {
                localVarQueryParameter['failedJobs'] = failedJobs;
            }

            if (incidents !== undefined) {
                localVarQueryParameter['incidents'] = incidents;
            }

            if (incidentsForType !== undefined) {
                localVarQueryParameter['incidentsForType'] = incidentsForType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves runtime statistics of the latest version of the given process definition for a tenant, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Activity Instance Statistics
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityStatisticsByProcessDefinitionKeyAndTenantId: async (key: string, tenantId: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getActivityStatisticsByProcessDefinitionKeyAndTenantId', 'key', key)
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('getActivityStatisticsByProcessDefinitionKeyAndTenantId', 'tenantId', tenantId)
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}/statistics`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (failedJobs !== undefined) {
                localVarQueryParameter['failedJobs'] = failedJobs;
            }

            if (incidents !== undefined) {
                localVarQueryParameter['incidents'] = incidents;
            }

            if (incidentsForType !== undefined) {
                localVarQueryParameter['incidentsForType'] = incidentsForType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Start Form
         * @param {string} id The id of the process definition to get the deployed start form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedStartForm: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDeployedStartForm', 'id', id)
            const localVarPath = `/process-definition/{id}/deployed-start-form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedStartFormByKey: async (key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getDeployedStartFormByKey', 'key', key)
            const localVarPath = `/process-definition/key/{key}/deployed-start-form`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definitions belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedStartFormByKeyAndTenantId: async (key: string, tenantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getDeployedStartFormByKeyAndTenantId', 'key', key)
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('getDeployedStartFormByKeyAndTenantId', 'tenantId', tenantId)
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}/deployed-start-form`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the latest version of the process definition for tenant according to the `ProcessDefinition` interface in the engine.
         * @summary Get
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestProcessDefinitionByTenantId: async (key: string, tenantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getLatestProcessDefinitionByTenantId', 'key', key)
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('getLatestProcessDefinitionByTenantId', 'tenantId', tenantId)
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a process definition according to the `ProcessDefinition` interface in the engine.
         * @summary Get
         * @param {string} id The id of the process definition to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinition: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProcessDefinition', 'id', id)
            const localVarPath = `/process-definition/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the BPMN 2.0 XML of a process definition.
         * @summary Get XML
         * @param {string} id The id of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionBpmn20Xml: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProcessDefinitionBpmn20Xml', 'id', id)
            const localVarPath = `/process-definition/{id}/xml`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves latest version the BPMN 2.0 XML of a process definition.
         * @summary Get XML
         * @param {string} key The key of the process definition (the latest version thereof) whose XML should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionBpmn20XmlByKey: async (key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getProcessDefinitionBpmn20XmlByKey', 'key', key)
            const localVarPath = `/process-definition/key/{key}/xml`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves latest version the BPMN 2.0 XML of a process definition. Returns the XML for the latest version of the process definition for tenant.
         * @summary Get XML
         * @param {string} key The key of the process definition (the latest version thereof) whose XML should be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionBpmn20XmlByKeyAndTenantId: async (key: string, tenantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getProcessDefinitionBpmn20XmlByKeyAndTenantId', 'key', key)
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('getProcessDefinitionBpmn20XmlByKeyAndTenantId', 'tenantId', tenantId)
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}/xml`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the latest version of the process definition which belongs to no tenant according to the `ProcessDefinition` interface in the engine.
         * @summary Get
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionByKey: async (key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getProcessDefinitionByKey', 'key', key)
            const localVarPath = `/process-definition/key/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the diagram of a process definition.  If the process definition\'s deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
         * @summary Get Diagram
         * @param {string} id The id of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionDiagram: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProcessDefinitionDiagram', 'id', id)
            const localVarPath = `/process-definition/{id}/diagram`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the diagram for the latest version of the process definition which belongs to no tenant.  If the process definition\'s deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
         * @summary Get Diagram
         * @param {string} key The key of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionDiagramByKey: async (key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getProcessDefinitionDiagramByKey', 'key', key)
            const localVarPath = `/process-definition/key/{key}/diagram`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the diagram for the latest version of the process definition for tenant.  If the process definition\'s deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
         * @summary Get Diagram
         * @param {string} key The key of the process definition.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionDiagramByKeyAndTenantId: async (key: string, tenantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getProcessDefinitionDiagramByKeyAndTenantId', 'key', key)
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('getProcessDefinitionDiagramByKeyAndTenantId', 'tenantId', tenantId)
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}/diagram`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves runtime statistics of the process engine, grouped by process definitions. These statistics include the number of running process instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Process Instance Statistics
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {boolean} [rootIncidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of root incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60; or &#x60;incidents&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionStatistics: async (failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, rootIncidents?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/process-definition/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (failedJobs !== undefined) {
                localVarQueryParameter['failedJobs'] = failedJobs;
            }

            if (incidents !== undefined) {
                localVarQueryParameter['incidents'] = incidents;
            }

            if (incidentsForType !== undefined) {
                localVarQueryParameter['incidentsForType'] = incidentsForType;
            }

            if (rootIncidents !== undefined) {
                localVarQueryParameter['rootIncidents'] = rootIncidents;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for process definitions that fulfill given parameters. Parameters may be the properties of  process definitions, such as the name, key or version. The size of the result set can be retrieved by using the [Get Definition Count](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/get-query-count/) method.
         * @summary Get List
         * @param {string} [processDefinitionId] Filter by process definition id.
         * @param {string} [processDefinitionIdIn] Filter by a comma-separated list of process definition ids.
         * @param {string} [name] Filter by process definition name.
         * @param {string} [nameLike] Filter by process definition names that the parameter is a substring of.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {string} [deployedAfter] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [deployedAt] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [key] Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match.
         * @param {string} [keysIn] Filter by a comma-separated list of process definition keys.
         * @param {string} [keyLike] Filter by process definition keys that the parameter is a substring of.
         * @param {string} [category] Filter by process definition category. Exact match.
         * @param {string} [categoryLike] Filter by process definition categories that the parameter is a substring of.
         * @param {number} [version] Filter by process definition version.
         * @param {boolean} [latestVersion] Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [resourceName] Filter by the name of the process definition resource. Exact match.
         * @param {string} [resourceNameLike] Filter by names of those process definition resources that the parameter is a substring of.
         * @param {string} [startableBy] Filter by a user name who is allowed to start the process.
         * @param {boolean} [active] Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior.
         * @param {boolean} [includeProcessDefinitionsWithoutTenantId] Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [versionTag] Filter by the version tag.
         * @param {string} [versionTagLike] Filter by the version tag that the parameter is a substring of.
         * @param {boolean} [withoutVersionTag] Only include process definitions without a &#x60;versionTag&#x60;.
         * @param {boolean} [startableInTasklist] Filter by process definitions which are startable in Tasklist..
         * @param {boolean} [notStartableInTasklist] Filter by process definitions which are not startable in Tasklist.
         * @param {boolean} [startablePermissionCheck] Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn\&#39;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level
         * @param {'category' | 'key' | 'id' | 'name' | 'version' | 'deploymentId' | 'deployTime' | 'tenantId ' | 'versionTag'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitions: async (processDefinitionId?: string, processDefinitionIdIn?: string, name?: string, nameLike?: string, deploymentId?: string, deployedAfter?: string, deployedAt?: string, key?: string, keysIn?: string, keyLike?: string, category?: string, categoryLike?: string, version?: number, latestVersion?: boolean, resourceName?: string, resourceNameLike?: string, startableBy?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeProcessDefinitionsWithoutTenantId?: boolean, versionTag?: string, versionTagLike?: string, withoutVersionTag?: boolean, startableInTasklist?: boolean, notStartableInTasklist?: boolean, startablePermissionCheck?: boolean, sortBy?: 'category' | 'key' | 'id' | 'name' | 'version' | 'deploymentId' | 'deployTime' | 'tenantId ' | 'versionTag', sortOrder?: 'asc' | 'desc', firstResult?: number, maxResults?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/process-definition`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (processDefinitionId !== undefined) {
                localVarQueryParameter['processDefinitionId'] = processDefinitionId;
            }

            if (processDefinitionIdIn !== undefined) {
                localVarQueryParameter['processDefinitionIdIn'] = processDefinitionIdIn;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameLike !== undefined) {
                localVarQueryParameter['nameLike'] = nameLike;
            }

            if (deploymentId !== undefined) {
                localVarQueryParameter['deploymentId'] = deploymentId;
            }

            if (deployedAfter !== undefined) {
                localVarQueryParameter['deployedAfter'] = (deployedAfter as any instanceof Date) ?
                    (deployedAfter as any).toISOString() :
                    deployedAfter;
            }

            if (deployedAt !== undefined) {
                localVarQueryParameter['deployedAt'] = (deployedAt as any instanceof Date) ?
                    (deployedAt as any).toISOString() :
                    deployedAt;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }

            if (keysIn !== undefined) {
                localVarQueryParameter['keysIn'] = keysIn;
            }

            if (keyLike !== undefined) {
                localVarQueryParameter['keyLike'] = keyLike;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (categoryLike !== undefined) {
                localVarQueryParameter['categoryLike'] = categoryLike;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (latestVersion !== undefined) {
                localVarQueryParameter['latestVersion'] = latestVersion;
            }

            if (resourceName !== undefined) {
                localVarQueryParameter['resourceName'] = resourceName;
            }

            if (resourceNameLike !== undefined) {
                localVarQueryParameter['resourceNameLike'] = resourceNameLike;
            }

            if (startableBy !== undefined) {
                localVarQueryParameter['startableBy'] = startableBy;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (suspended !== undefined) {
                localVarQueryParameter['suspended'] = suspended;
            }

            if (incidentId !== undefined) {
                localVarQueryParameter['incidentId'] = incidentId;
            }

            if (incidentType !== undefined) {
                localVarQueryParameter['incidentType'] = incidentType;
            }

            if (incidentMessage !== undefined) {
                localVarQueryParameter['incidentMessage'] = incidentMessage;
            }

            if (incidentMessageLike !== undefined) {
                localVarQueryParameter['incidentMessageLike'] = incidentMessageLike;
            }

            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }

            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }

            if (includeProcessDefinitionsWithoutTenantId !== undefined) {
                localVarQueryParameter['includeProcessDefinitionsWithoutTenantId'] = includeProcessDefinitionsWithoutTenantId;
            }

            if (versionTag !== undefined) {
                localVarQueryParameter['versionTag'] = versionTag;
            }

            if (versionTagLike !== undefined) {
                localVarQueryParameter['versionTagLike'] = versionTagLike;
            }

            if (withoutVersionTag !== undefined) {
                localVarQueryParameter['withoutVersionTag'] = withoutVersionTag;
            }

            if (startableInTasklist !== undefined) {
                localVarQueryParameter['startableInTasklist'] = startableInTasklist;
            }

            if (notStartableInTasklist !== undefined) {
                localVarQueryParameter['notStartableInTasklist'] = notStartableInTasklist;
            }

            if (startablePermissionCheck !== undefined) {
                localVarQueryParameter['startablePermissionCheck'] = startablePermissionCheck;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requests the number of process definitions that fulfill the query criteria. Takes the same filtering parameters as the [Get Definitions](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/get-query/) method.
         * @summary Get List Count
         * @param {string} [processDefinitionId] Filter by process definition id.
         * @param {string} [processDefinitionIdIn] Filter by a comma-separated list of process definition ids.
         * @param {string} [name] Filter by process definition name.
         * @param {string} [nameLike] Filter by process definition names that the parameter is a substring of.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {string} [deployedAfter] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [deployedAt] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [key] Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match.
         * @param {string} [keysIn] Filter by a comma-separated list of process definition keys.
         * @param {string} [keyLike] Filter by process definition keys that the parameter is a substring of.
         * @param {string} [category] Filter by process definition category. Exact match.
         * @param {string} [categoryLike] Filter by process definition categories that the parameter is a substring of.
         * @param {number} [version] Filter by process definition version.
         * @param {boolean} [latestVersion] Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [resourceName] Filter by the name of the process definition resource. Exact match.
         * @param {string} [resourceNameLike] Filter by names of those process definition resources that the parameter is a substring of.
         * @param {string} [startableBy] Filter by a user name who is allowed to start the process.
         * @param {boolean} [active] Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior.
         * @param {boolean} [includeProcessDefinitionsWithoutTenantId] Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [versionTag] Filter by the version tag.
         * @param {string} [versionTagLike] Filter by the version tag that the parameter is a substring of.
         * @param {boolean} [withoutVersionTag] Only include process definitions without a &#x60;versionTag&#x60;.
         * @param {boolean} [startableInTasklist] Filter by process definitions which are startable in Tasklist..
         * @param {boolean} [notStartableInTasklist] Filter by process definitions which are not startable in Tasklist.
         * @param {boolean} [startablePermissionCheck] Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn\&#39;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionsCount: async (processDefinitionId?: string, processDefinitionIdIn?: string, name?: string, nameLike?: string, deploymentId?: string, deployedAfter?: string, deployedAt?: string, key?: string, keysIn?: string, keyLike?: string, category?: string, categoryLike?: string, version?: number, latestVersion?: boolean, resourceName?: string, resourceNameLike?: string, startableBy?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeProcessDefinitionsWithoutTenantId?: boolean, versionTag?: string, versionTagLike?: string, withoutVersionTag?: boolean, startableInTasklist?: boolean, notStartableInTasklist?: boolean, startablePermissionCheck?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/process-definition/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (processDefinitionId !== undefined) {
                localVarQueryParameter['processDefinitionId'] = processDefinitionId;
            }

            if (processDefinitionIdIn !== undefined) {
                localVarQueryParameter['processDefinitionIdIn'] = processDefinitionIdIn;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameLike !== undefined) {
                localVarQueryParameter['nameLike'] = nameLike;
            }

            if (deploymentId !== undefined) {
                localVarQueryParameter['deploymentId'] = deploymentId;
            }

            if (deployedAfter !== undefined) {
                localVarQueryParameter['deployedAfter'] = (deployedAfter as any instanceof Date) ?
                    (deployedAfter as any).toISOString() :
                    deployedAfter;
            }

            if (deployedAt !== undefined) {
                localVarQueryParameter['deployedAt'] = (deployedAt as any instanceof Date) ?
                    (deployedAt as any).toISOString() :
                    deployedAt;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }

            if (keysIn !== undefined) {
                localVarQueryParameter['keysIn'] = keysIn;
            }

            if (keyLike !== undefined) {
                localVarQueryParameter['keyLike'] = keyLike;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (categoryLike !== undefined) {
                localVarQueryParameter['categoryLike'] = categoryLike;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (latestVersion !== undefined) {
                localVarQueryParameter['latestVersion'] = latestVersion;
            }

            if (resourceName !== undefined) {
                localVarQueryParameter['resourceName'] = resourceName;
            }

            if (resourceNameLike !== undefined) {
                localVarQueryParameter['resourceNameLike'] = resourceNameLike;
            }

            if (startableBy !== undefined) {
                localVarQueryParameter['startableBy'] = startableBy;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (suspended !== undefined) {
                localVarQueryParameter['suspended'] = suspended;
            }

            if (incidentId !== undefined) {
                localVarQueryParameter['incidentId'] = incidentId;
            }

            if (incidentType !== undefined) {
                localVarQueryParameter['incidentType'] = incidentType;
            }

            if (incidentMessage !== undefined) {
                localVarQueryParameter['incidentMessage'] = incidentMessage;
            }

            if (incidentMessageLike !== undefined) {
                localVarQueryParameter['incidentMessageLike'] = incidentMessageLike;
            }

            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }

            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }

            if (includeProcessDefinitionsWithoutTenantId !== undefined) {
                localVarQueryParameter['includeProcessDefinitionsWithoutTenantId'] = includeProcessDefinitionsWithoutTenantId;
            }

            if (versionTag !== undefined) {
                localVarQueryParameter['versionTag'] = versionTag;
            }

            if (versionTagLike !== undefined) {
                localVarQueryParameter['versionTagLike'] = versionTagLike;
            }

            if (withoutVersionTag !== undefined) {
                localVarQueryParameter['withoutVersionTag'] = withoutVersionTag;
            }

            if (startableInTasklist !== undefined) {
                localVarQueryParameter['startableInTasklist'] = startableInTasklist;
            }

            if (notStartableInTasklist !== undefined) {
                localVarQueryParameter['notStartableInTasklist'] = notStartableInTasklist;
            }

            if (startablePermissionCheck !== undefined) {
                localVarQueryParameter['startablePermissionCheck'] = startablePermissionCheck;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the rendered form for a process definition. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Start Form
         * @param {string} id The id of the process definition to get the rendered start form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRenderedStartForm: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRenderedStartForm', 'id', id)
            const localVarPath = `/process-definition/{id}/rendered-form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves  the rendered form for the latest version of the process definition which belongs to no tenant. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRenderedStartFormByKey: async (key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getRenderedStartFormByKey', 'key', key)
            const localVarPath = `/process-definition/key/{key}/rendered-form`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves  the rendered form for the latest version of the process definition for a tenant. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRenderedStartFormByKeyAndTenantId: async (key: string, tenantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getRenderedStartFormByKeyAndTenantId', 'key', key)
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('getRenderedStartFormByKeyAndTenantId', 'tenantId', tenantId)
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}/rendered-form`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the key of the start form for a process definition. The form key corresponds to the `FormData#formKey` property in the engine.
         * @summary Get Start Form Key
         * @param {string} id The id of the process definition to get the start form key for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartForm: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getStartForm', 'id', id)
            const localVarPath = `/process-definition/{id}/startForm`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the key of the start form for the latest version of the process definition which belongs to no tenant. The form key corresponds to the `FormData#formKey` property in the engine.
         * @summary Get Start Form Key
         * @param {string} key The key of the process definition (the latest version thereof) for which the form key is to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormByKey: async (key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getStartFormByKey', 'key', key)
            const localVarPath = `/process-definition/key/{key}/startForm`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the key of the start form for the latest version of the process definition for a tenant. The form key corresponds to the `FormData#formKey` property in the engine.
         * @summary Get Start Form Key
         * @param {string} key The key of the process definition (the latest version thereof) for which the form key is to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormByKeyAndTenantId: async (key: string, tenantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getStartFormByKeyAndTenantId', 'key', key)
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('getStartFormByKeyAndTenantId', 'tenantId', tenantId)
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}/startForm`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the start form variables for a process definition (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Start Form Variables
         * @param {string} id The id of the process definition to retrieve the variables for.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormVariables: async (id: string, variableNames?: string, deserializeValues?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getStartFormVariables', 'id', id)
            const localVarPath = `/process-definition/{id}/form-variables`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (variableNames !== undefined) {
                localVarQueryParameter['variableNames'] = variableNames;
            }

            if (deserializeValues !== undefined) {
                localVarQueryParameter['deserializeValues'] = deserializeValues;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the start form variables for the latest process definition which belongs to no tenant (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Start Form Variables
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormVariablesByKey: async (key: string, variableNames?: string, deserializeValues?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getStartFormVariablesByKey', 'key', key)
            const localVarPath = `/process-definition/key/{key}/form-variables`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (variableNames !== undefined) {
                localVarQueryParameter['variableNames'] = variableNames;
            }

            if (deserializeValues !== undefined) {
                localVarQueryParameter['deserializeValues'] = deserializeValues;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the start form variables for the latest process definition for a tenant (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Start Form Variables
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormVariablesByKeyAndTenantId: async (key: string, tenantId: string, variableNames?: string, deserializeValues?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getStartFormVariablesByKeyAndTenantId', 'key', key)
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('getStartFormVariablesByKeyAndTenantId', 'tenantId', tenantId)
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}/form-variables`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (variableNames !== undefined) {
                localVarQueryParameter['variableNames'] = variableNames;
            }

            if (deserializeValues !== undefined) {
                localVarQueryParameter['deserializeValues'] = deserializeValues;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restarts process instances that were canceled or terminated synchronously. Can also restart completed process instances. It will create a new instance using the original instance information. To execute the restart asynchronously, use the [Restart Process Instance Async](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/post-restart-process-instance-async/) method.  For more information about the difference between synchronous and asynchronous execution, please refer to the related section of the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-restart/#execution).
         * @summary Restart Process Instance
         * @param {string} id The id of the process definition of the process instances to restart.
         * @param {RestartProcessInstanceDto} [restartProcessInstanceDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartProcessInstance: async (id: string, restartProcessInstanceDto?: RestartProcessInstanceDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('restartProcessInstance', 'id', id)
            const localVarPath = `/process-definition/{id}/restart`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(restartProcessInstanceDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restarts process instances that were canceled or terminated asynchronously. Can also restart completed process instances. It will create a new instance using the original instance information. To execute the restart asynchronously, use the [Restart Process Instance](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/post-restart-process-instance-sync/) method.  For more information about the difference between synchronous and asynchronous execution, please refer to the related section of the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-restart/#execution).
         * @summary Restart Process Instance Async
         * @param {string} id The id of the process definition of the process instances to restart.
         * @param {RestartProcessInstanceDto} [restartProcessInstanceDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartProcessInstanceAsyncOperation: async (id: string, restartProcessInstanceDto?: RestartProcessInstanceDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('restartProcessInstanceAsyncOperation', 'id', id)
            const localVarPath = `/process-definition/{id}/restart-async`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(restartProcessInstanceDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Instantiates a given process definition. Process variables and business key may be supplied in the request body.
         * @summary Start Instance
         * @param {string} id The id of the process definition to be retrieved.
         * @param {StartProcessInstanceDto} [startProcessInstanceDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProcessInstance: async (id: string, startProcessInstanceDto?: StartProcessInstanceDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('startProcessInstance', 'id', id)
            const localVarPath = `/process-definition/{id}/start`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(startProcessInstanceDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Instantiates a given process definition, starts the latest version of the process definition which belongs to no tenant. Process variables and business key may be supplied in the request body.
         * @summary Start Instance
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {StartProcessInstanceDto} [startProcessInstanceDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProcessInstanceByKey: async (key: string, startProcessInstanceDto?: StartProcessInstanceDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('startProcessInstanceByKey', 'key', key)
            const localVarPath = `/process-definition/key/{key}/start`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(startProcessInstanceDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Instantiates a given process definition, starts the latest version of the process definition for tenant. Process variables and business key may be supplied in the request body.
         * @summary Start Instance
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {StartProcessInstanceDto} [startProcessInstanceDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProcessInstanceByKeyAndTenantId: async (key: string, tenantId: string, startProcessInstanceDto?: StartProcessInstanceDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('startProcessInstanceByKeyAndTenantId', 'key', key)
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('startProcessInstanceByKeyAndTenantId', 'tenantId', tenantId)
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}/start`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(startProcessInstanceDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts a process instance using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Submit Start Form
         * @param {string} id The id of the process definition to submit the form for.
         * @param {StartProcessInstanceFormDto} [startProcessInstanceFormDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitForm: async (id: string, startProcessInstanceFormDto?: StartProcessInstanceFormDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submitForm', 'id', id)
            const localVarPath = `/process-definition/{id}/submit-form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(startProcessInstanceFormDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts the latest version of the process definition which belongs to no tenant using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Submit Start Form
         * @param {string} key The key of the process definition to submit the form for.
         * @param {StartProcessInstanceFormDto} [startProcessInstanceFormDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitFormByKey: async (key: string, startProcessInstanceFormDto?: StartProcessInstanceFormDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('submitFormByKey', 'key', key)
            const localVarPath = `/process-definition/key/{key}/submit-form`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(startProcessInstanceFormDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts the latest version of the process definition for a tenant using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Submit Start Form
         * @param {string} key The key of the process definition to submit the form for.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {StartProcessInstanceFormDto} [startProcessInstanceFormDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitFormByKeyAndTenantId: async (key: string, tenantId: string, startProcessInstanceFormDto?: StartProcessInstanceFormDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('submitFormByKeyAndTenantId', 'key', key)
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('submitFormByKeyAndTenantId', 'tenantId', tenantId)
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}/submit-form`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(startProcessInstanceFormDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates history time to live for process definition. The field is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
         * @summary Update History Time to Live
         * @param {string} id The id of the process definition to change history time to live.
         * @param {HistoryTimeToLiveDto} [historyTimeToLiveDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHistoryTimeToLiveByProcessDefinitionId: async (id: string, historyTimeToLiveDto?: HistoryTimeToLiveDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateHistoryTimeToLiveByProcessDefinitionId', 'id', id)
            const localVarPath = `/process-definition/{id}/history-time-to-live`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(historyTimeToLiveDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates history time to live for the latest version of the process definition which belongs to no tenant. The field is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
         * @summary Update History Time to Live
         * @param {string} key The key of the process definition to change history time to live.
         * @param {HistoryTimeToLiveDto} [historyTimeToLiveDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHistoryTimeToLiveByProcessDefinitionKey: async (key: string, historyTimeToLiveDto?: HistoryTimeToLiveDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('updateHistoryTimeToLiveByProcessDefinitionKey', 'key', key)
            const localVarPath = `/process-definition/key/{key}/history-time-to-live`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(historyTimeToLiveDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates history time to live for the latest version of the process definition for a tenant. The field is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
         * @summary Update History Time to Live
         * @param {string} key The key of the process definition to change history time to live.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {HistoryTimeToLiveDto} [historyTimeToLiveDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId: async (key: string, tenantId: string, historyTimeToLiveDto?: HistoryTimeToLiveDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId', 'key', key)
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId', 'tenantId', tenantId)
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}/history-time-to-live`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(historyTimeToLiveDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activates or suspends process definitions with the given process definition key.
         * @summary Activate/Suspend By Key
         * @param {ProcessDefinitionSuspensionStateDto} [processDefinitionSuspensionStateDto] **Note**: Unallowed property is &#x60;processDefinitionId&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessDefinitionSuspensionState: async (processDefinitionSuspensionStateDto?: ProcessDefinitionSuspensionStateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/process-definition/suspended`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(processDefinitionSuspensionStateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activates or suspends a given process definition by id.
         * @summary Activate/Suspend By Id
         * @param {string} id The id of the process definition to activate or suspend.
         * @param {ProcessDefinitionSuspensionStateDto} [processDefinitionSuspensionStateDto] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessDefinitionSuspensionStateById: async (id: string, processDefinitionSuspensionStateDto?: ProcessDefinitionSuspensionStateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProcessDefinitionSuspensionStateById', 'id', id)
            const localVarPath = `/process-definition/{id}/suspended`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(processDefinitionSuspensionStateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activates or suspends a given process definition by latest version of process definition key which belongs to no tenant.
         * @summary Activate/Suspend by Id
         * @param {string} key The key of the process definition (the latest version thereof) to be activated/suspended.
         * @param {ProcessDefinitionSuspensionStateDto} [processDefinitionSuspensionStateDto] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessDefinitionSuspensionStateByKey: async (key: string, processDefinitionSuspensionStateDto?: ProcessDefinitionSuspensionStateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('updateProcessDefinitionSuspensionStateByKey', 'key', key)
            const localVarPath = `/process-definition/key/{key}/suspended`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(processDefinitionSuspensionStateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activates or suspends a given process definition by the latest version of the process definition for tenant.
         * @summary Activate/Suspend by Id
         * @param {string} key The key of the process definition (the latest version thereof) to be activated/suspended.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {ProcessDefinitionSuspensionStateDto} [processDefinitionSuspensionStateDto] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessDefinitionSuspensionStateByKeyAndTenantId: async (key: string, tenantId: string, processDefinitionSuspensionStateDto?: ProcessDefinitionSuspensionStateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('updateProcessDefinitionSuspensionStateByKeyAndTenantId', 'key', key)
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('updateProcessDefinitionSuspensionStateByKeyAndTenantId', 'tenantId', tenantId)
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}/suspended`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(processDefinitionSuspensionStateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProcessDefinitionApi - functional programming interface
 * @export
 */
export const ProcessDefinitionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProcessDefinitionApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a running process instance by id.
         * @summary Delete
         * @param {string} id The id of the process definition to be deleted.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProcessDefinition(id: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProcessDefinition(id, cascade, skipCustomListeners, skipIoMappings, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes process definitions by a given key which belong to no tenant id.
         * @summary Delete By Key
         * @param {string} key The key of the process definitions to be deleted.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProcessDefinitionsByKey(key: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProcessDefinitionsByKey(key, cascade, skipCustomListeners, skipIoMappings, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes process definitions by a given key and which belong to a tenant id.
         * @summary Delete By Key
         * @param {string} key The key of the process definitions to be deleted.
         * @param {string} tenantId The id of the tenant the process definitions belong to.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProcessDefinitionsByKeyAndTenantId(key: string, tenantId: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProcessDefinitionsByKeyAndTenantId(key, tenantId, cascade, skipCustomListeners, skipIoMappings, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves runtime statistics of a given process definition, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Activity Instance Statistics
         * @param {string} id The id of the process definition.
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivityStatistics(id: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActivityStatisticsResultDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivityStatistics(id, failedJobs, incidents, incidentsForType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves runtime statistics of the latest version of the given process definition which belongs to no tenant, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Activity Instance Statistics
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivityStatisticsByProcessDefinitionKey(key: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActivityStatisticsResultDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivityStatisticsByProcessDefinitionKey(key, failedJobs, incidents, incidentsForType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves runtime statistics of the latest version of the given process definition for a tenant, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Activity Instance Statistics
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivityStatisticsByProcessDefinitionKeyAndTenantId(key: string, tenantId: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActivityStatisticsResultDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivityStatisticsByProcessDefinitionKeyAndTenantId(key, tenantId, failedJobs, incidents, incidentsForType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Start Form
         * @param {string} id The id of the process definition to get the deployed start form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeployedStartForm(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeployedStartForm(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeployedStartFormByKey(key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeployedStartFormByKey(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definitions belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeployedStartFormByKeyAndTenantId(key: string, tenantId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeployedStartFormByKeyAndTenantId(key, tenantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the latest version of the process definition for tenant according to the `ProcessDefinition` interface in the engine.
         * @summary Get
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestProcessDefinitionByTenantId(key: string, tenantId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessDefinitionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestProcessDefinitionByTenantId(key, tenantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a process definition according to the `ProcessDefinition` interface in the engine.
         * @summary Get
         * @param {string} id The id of the process definition to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinition(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessDefinitionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessDefinition(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the BPMN 2.0 XML of a process definition.
         * @summary Get XML
         * @param {string} id The id of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitionBpmn20Xml(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessDefinitionDiagramDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessDefinitionBpmn20Xml(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves latest version the BPMN 2.0 XML of a process definition.
         * @summary Get XML
         * @param {string} key The key of the process definition (the latest version thereof) whose XML should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitionBpmn20XmlByKey(key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessDefinitionDiagramDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessDefinitionBpmn20XmlByKey(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves latest version the BPMN 2.0 XML of a process definition. Returns the XML for the latest version of the process definition for tenant.
         * @summary Get XML
         * @param {string} key The key of the process definition (the latest version thereof) whose XML should be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitionBpmn20XmlByKeyAndTenantId(key: string, tenantId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessDefinitionDiagramDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessDefinitionBpmn20XmlByKeyAndTenantId(key, tenantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the latest version of the process definition which belongs to no tenant according to the `ProcessDefinition` interface in the engine.
         * @summary Get
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitionByKey(key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessDefinitionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessDefinitionByKey(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the diagram of a process definition.  If the process definition\'s deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
         * @summary Get Diagram
         * @param {string} id The id of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitionDiagram(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessDefinitionDiagram(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the diagram for the latest version of the process definition which belongs to no tenant.  If the process definition\'s deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
         * @summary Get Diagram
         * @param {string} key The key of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitionDiagramByKey(key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessDefinitionDiagramByKey(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the diagram for the latest version of the process definition for tenant.  If the process definition\'s deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
         * @summary Get Diagram
         * @param {string} key The key of the process definition.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitionDiagramByKeyAndTenantId(key: string, tenantId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessDefinitionDiagramByKeyAndTenantId(key, tenantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves runtime statistics of the process engine, grouped by process definitions. These statistics include the number of running process instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Process Instance Statistics
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {boolean} [rootIncidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of root incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60; or &#x60;incidents&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitionStatistics(failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, rootIncidents?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProcessDefinitionStatisticsResultDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessDefinitionStatistics(failedJobs, incidents, incidentsForType, rootIncidents, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Queries for process definitions that fulfill given parameters. Parameters may be the properties of  process definitions, such as the name, key or version. The size of the result set can be retrieved by using the [Get Definition Count](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/get-query-count/) method.
         * @summary Get List
         * @param {string} [processDefinitionId] Filter by process definition id.
         * @param {string} [processDefinitionIdIn] Filter by a comma-separated list of process definition ids.
         * @param {string} [name] Filter by process definition name.
         * @param {string} [nameLike] Filter by process definition names that the parameter is a substring of.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {string} [deployedAfter] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [deployedAt] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [key] Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match.
         * @param {string} [keysIn] Filter by a comma-separated list of process definition keys.
         * @param {string} [keyLike] Filter by process definition keys that the parameter is a substring of.
         * @param {string} [category] Filter by process definition category. Exact match.
         * @param {string} [categoryLike] Filter by process definition categories that the parameter is a substring of.
         * @param {number} [version] Filter by process definition version.
         * @param {boolean} [latestVersion] Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [resourceName] Filter by the name of the process definition resource. Exact match.
         * @param {string} [resourceNameLike] Filter by names of those process definition resources that the parameter is a substring of.
         * @param {string} [startableBy] Filter by a user name who is allowed to start the process.
         * @param {boolean} [active] Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior.
         * @param {boolean} [includeProcessDefinitionsWithoutTenantId] Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [versionTag] Filter by the version tag.
         * @param {string} [versionTagLike] Filter by the version tag that the parameter is a substring of.
         * @param {boolean} [withoutVersionTag] Only include process definitions without a &#x60;versionTag&#x60;.
         * @param {boolean} [startableInTasklist] Filter by process definitions which are startable in Tasklist..
         * @param {boolean} [notStartableInTasklist] Filter by process definitions which are not startable in Tasklist.
         * @param {boolean} [startablePermissionCheck] Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn\&#39;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level
         * @param {'category' | 'key' | 'id' | 'name' | 'version' | 'deploymentId' | 'deployTime' | 'tenantId ' | 'versionTag'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitions(processDefinitionId?: string, processDefinitionIdIn?: string, name?: string, nameLike?: string, deploymentId?: string, deployedAfter?: string, deployedAt?: string, key?: string, keysIn?: string, keyLike?: string, category?: string, categoryLike?: string, version?: number, latestVersion?: boolean, resourceName?: string, resourceNameLike?: string, startableBy?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeProcessDefinitionsWithoutTenantId?: boolean, versionTag?: string, versionTagLike?: string, withoutVersionTag?: boolean, startableInTasklist?: boolean, notStartableInTasklist?: boolean, startablePermissionCheck?: boolean, sortBy?: 'category' | 'key' | 'id' | 'name' | 'version' | 'deploymentId' | 'deployTime' | 'tenantId ' | 'versionTag', sortOrder?: 'asc' | 'desc', firstResult?: number, maxResults?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProcessDefinitionDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessDefinitions(processDefinitionId, processDefinitionIdIn, name, nameLike, deploymentId, deployedAfter, deployedAt, key, keysIn, keyLike, category, categoryLike, version, latestVersion, resourceName, resourceNameLike, startableBy, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, includeProcessDefinitionsWithoutTenantId, versionTag, versionTagLike, withoutVersionTag, startableInTasklist, notStartableInTasklist, startablePermissionCheck, sortBy, sortOrder, firstResult, maxResults, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Requests the number of process definitions that fulfill the query criteria. Takes the same filtering parameters as the [Get Definitions](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/get-query/) method.
         * @summary Get List Count
         * @param {string} [processDefinitionId] Filter by process definition id.
         * @param {string} [processDefinitionIdIn] Filter by a comma-separated list of process definition ids.
         * @param {string} [name] Filter by process definition name.
         * @param {string} [nameLike] Filter by process definition names that the parameter is a substring of.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {string} [deployedAfter] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [deployedAt] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [key] Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match.
         * @param {string} [keysIn] Filter by a comma-separated list of process definition keys.
         * @param {string} [keyLike] Filter by process definition keys that the parameter is a substring of.
         * @param {string} [category] Filter by process definition category. Exact match.
         * @param {string} [categoryLike] Filter by process definition categories that the parameter is a substring of.
         * @param {number} [version] Filter by process definition version.
         * @param {boolean} [latestVersion] Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [resourceName] Filter by the name of the process definition resource. Exact match.
         * @param {string} [resourceNameLike] Filter by names of those process definition resources that the parameter is a substring of.
         * @param {string} [startableBy] Filter by a user name who is allowed to start the process.
         * @param {boolean} [active] Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior.
         * @param {boolean} [includeProcessDefinitionsWithoutTenantId] Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [versionTag] Filter by the version tag.
         * @param {string} [versionTagLike] Filter by the version tag that the parameter is a substring of.
         * @param {boolean} [withoutVersionTag] Only include process definitions without a &#x60;versionTag&#x60;.
         * @param {boolean} [startableInTasklist] Filter by process definitions which are startable in Tasklist..
         * @param {boolean} [notStartableInTasklist] Filter by process definitions which are not startable in Tasklist.
         * @param {boolean} [startablePermissionCheck] Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn\&#39;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitionsCount(processDefinitionId?: string, processDefinitionIdIn?: string, name?: string, nameLike?: string, deploymentId?: string, deployedAfter?: string, deployedAt?: string, key?: string, keysIn?: string, keyLike?: string, category?: string, categoryLike?: string, version?: number, latestVersion?: boolean, resourceName?: string, resourceNameLike?: string, startableBy?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeProcessDefinitionsWithoutTenantId?: boolean, versionTag?: string, versionTagLike?: string, withoutVersionTag?: boolean, startableInTasklist?: boolean, notStartableInTasklist?: boolean, startablePermissionCheck?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessDefinitionsCount(processDefinitionId, processDefinitionIdIn, name, nameLike, deploymentId, deployedAfter, deployedAt, key, keysIn, keyLike, category, categoryLike, version, latestVersion, resourceName, resourceNameLike, startableBy, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, includeProcessDefinitionsWithoutTenantId, versionTag, versionTagLike, withoutVersionTag, startableInTasklist, notStartableInTasklist, startablePermissionCheck, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the rendered form for a process definition. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Start Form
         * @param {string} id The id of the process definition to get the rendered start form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRenderedStartForm(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRenderedStartForm(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves  the rendered form for the latest version of the process definition which belongs to no tenant. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRenderedStartFormByKey(key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRenderedStartFormByKey(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves  the rendered form for the latest version of the process definition for a tenant. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRenderedStartFormByKeyAndTenantId(key: string, tenantId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRenderedStartFormByKeyAndTenantId(key, tenantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the key of the start form for a process definition. The form key corresponds to the `FormData#formKey` property in the engine.
         * @summary Get Start Form Key
         * @param {string} id The id of the process definition to get the start form key for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStartForm(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStartForm(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the key of the start form for the latest version of the process definition which belongs to no tenant. The form key corresponds to the `FormData#formKey` property in the engine.
         * @summary Get Start Form Key
         * @param {string} key The key of the process definition (the latest version thereof) for which the form key is to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStartFormByKey(key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStartFormByKey(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the key of the start form for the latest version of the process definition for a tenant. The form key corresponds to the `FormData#formKey` property in the engine.
         * @summary Get Start Form Key
         * @param {string} key The key of the process definition (the latest version thereof) for which the form key is to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStartFormByKeyAndTenantId(key: string, tenantId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStartFormByKeyAndTenantId(key, tenantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the start form variables for a process definition (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Start Form Variables
         * @param {string} id The id of the process definition to retrieve the variables for.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStartFormVariables(id: string, variableNames?: string, deserializeValues?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: VariableValueDto; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStartFormVariables(id, variableNames, deserializeValues, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the start form variables for the latest process definition which belongs to no tenant (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Start Form Variables
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStartFormVariablesByKey(key: string, variableNames?: string, deserializeValues?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: VariableValueDto; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStartFormVariablesByKey(key, variableNames, deserializeValues, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the start form variables for the latest process definition for a tenant (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Start Form Variables
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStartFormVariablesByKeyAndTenantId(key: string, tenantId: string, variableNames?: string, deserializeValues?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: VariableValueDto; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStartFormVariablesByKeyAndTenantId(key, tenantId, variableNames, deserializeValues, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Restarts process instances that were canceled or terminated synchronously. Can also restart completed process instances. It will create a new instance using the original instance information. To execute the restart asynchronously, use the [Restart Process Instance Async](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/post-restart-process-instance-async/) method.  For more information about the difference between synchronous and asynchronous execution, please refer to the related section of the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-restart/#execution).
         * @summary Restart Process Instance
         * @param {string} id The id of the process definition of the process instances to restart.
         * @param {RestartProcessInstanceDto} [restartProcessInstanceDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restartProcessInstance(id: string, restartProcessInstanceDto?: RestartProcessInstanceDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restartProcessInstance(id, restartProcessInstanceDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Restarts process instances that were canceled or terminated asynchronously. Can also restart completed process instances. It will create a new instance using the original instance information. To execute the restart asynchronously, use the [Restart Process Instance](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/post-restart-process-instance-sync/) method.  For more information about the difference between synchronous and asynchronous execution, please refer to the related section of the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-restart/#execution).
         * @summary Restart Process Instance Async
         * @param {string} id The id of the process definition of the process instances to restart.
         * @param {RestartProcessInstanceDto} [restartProcessInstanceDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restartProcessInstanceAsyncOperation(id: string, restartProcessInstanceDto?: RestartProcessInstanceDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restartProcessInstanceAsyncOperation(id, restartProcessInstanceDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Instantiates a given process definition. Process variables and business key may be supplied in the request body.
         * @summary Start Instance
         * @param {string} id The id of the process definition to be retrieved.
         * @param {StartProcessInstanceDto} [startProcessInstanceDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startProcessInstance(id: string, startProcessInstanceDto?: StartProcessInstanceDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessInstanceWithVariablesDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startProcessInstance(id, startProcessInstanceDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Instantiates a given process definition, starts the latest version of the process definition which belongs to no tenant. Process variables and business key may be supplied in the request body.
         * @summary Start Instance
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {StartProcessInstanceDto} [startProcessInstanceDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startProcessInstanceByKey(key: string, startProcessInstanceDto?: StartProcessInstanceDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessInstanceWithVariablesDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startProcessInstanceByKey(key, startProcessInstanceDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Instantiates a given process definition, starts the latest version of the process definition for tenant. Process variables and business key may be supplied in the request body.
         * @summary Start Instance
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {StartProcessInstanceDto} [startProcessInstanceDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startProcessInstanceByKeyAndTenantId(key: string, tenantId: string, startProcessInstanceDto?: StartProcessInstanceDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessInstanceWithVariablesDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startProcessInstanceByKeyAndTenantId(key, tenantId, startProcessInstanceDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Starts a process instance using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Submit Start Form
         * @param {string} id The id of the process definition to submit the form for.
         * @param {StartProcessInstanceFormDto} [startProcessInstanceFormDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitForm(id: string, startProcessInstanceFormDto?: StartProcessInstanceFormDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessInstanceDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitForm(id, startProcessInstanceFormDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Starts the latest version of the process definition which belongs to no tenant using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Submit Start Form
         * @param {string} key The key of the process definition to submit the form for.
         * @param {StartProcessInstanceFormDto} [startProcessInstanceFormDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitFormByKey(key: string, startProcessInstanceFormDto?: StartProcessInstanceFormDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessInstanceDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitFormByKey(key, startProcessInstanceFormDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Starts the latest version of the process definition for a tenant using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Submit Start Form
         * @param {string} key The key of the process definition to submit the form for.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {StartProcessInstanceFormDto} [startProcessInstanceFormDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitFormByKeyAndTenantId(key: string, tenantId: string, startProcessInstanceFormDto?: StartProcessInstanceFormDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessInstanceDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitFormByKeyAndTenantId(key, tenantId, startProcessInstanceFormDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates history time to live for process definition. The field is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
         * @summary Update History Time to Live
         * @param {string} id The id of the process definition to change history time to live.
         * @param {HistoryTimeToLiveDto} [historyTimeToLiveDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateHistoryTimeToLiveByProcessDefinitionId(id: string, historyTimeToLiveDto?: HistoryTimeToLiveDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateHistoryTimeToLiveByProcessDefinitionId(id, historyTimeToLiveDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates history time to live for the latest version of the process definition which belongs to no tenant. The field is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
         * @summary Update History Time to Live
         * @param {string} key The key of the process definition to change history time to live.
         * @param {HistoryTimeToLiveDto} [historyTimeToLiveDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateHistoryTimeToLiveByProcessDefinitionKey(key: string, historyTimeToLiveDto?: HistoryTimeToLiveDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateHistoryTimeToLiveByProcessDefinitionKey(key, historyTimeToLiveDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates history time to live for the latest version of the process definition for a tenant. The field is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
         * @summary Update History Time to Live
         * @param {string} key The key of the process definition to change history time to live.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {HistoryTimeToLiveDto} [historyTimeToLiveDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId(key: string, tenantId: string, historyTimeToLiveDto?: HistoryTimeToLiveDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId(key, tenantId, historyTimeToLiveDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Activates or suspends process definitions with the given process definition key.
         * @summary Activate/Suspend By Key
         * @param {ProcessDefinitionSuspensionStateDto} [processDefinitionSuspensionStateDto] **Note**: Unallowed property is &#x60;processDefinitionId&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProcessDefinitionSuspensionState(processDefinitionSuspensionStateDto?: ProcessDefinitionSuspensionStateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProcessDefinitionSuspensionState(processDefinitionSuspensionStateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Activates or suspends a given process definition by id.
         * @summary Activate/Suspend By Id
         * @param {string} id The id of the process definition to activate or suspend.
         * @param {ProcessDefinitionSuspensionStateDto} [processDefinitionSuspensionStateDto] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProcessDefinitionSuspensionStateById(id: string, processDefinitionSuspensionStateDto?: ProcessDefinitionSuspensionStateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProcessDefinitionSuspensionStateById(id, processDefinitionSuspensionStateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Activates or suspends a given process definition by latest version of process definition key which belongs to no tenant.
         * @summary Activate/Suspend by Id
         * @param {string} key The key of the process definition (the latest version thereof) to be activated/suspended.
         * @param {ProcessDefinitionSuspensionStateDto} [processDefinitionSuspensionStateDto] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProcessDefinitionSuspensionStateByKey(key: string, processDefinitionSuspensionStateDto?: ProcessDefinitionSuspensionStateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProcessDefinitionSuspensionStateByKey(key, processDefinitionSuspensionStateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Activates or suspends a given process definition by the latest version of the process definition for tenant.
         * @summary Activate/Suspend by Id
         * @param {string} key The key of the process definition (the latest version thereof) to be activated/suspended.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {ProcessDefinitionSuspensionStateDto} [processDefinitionSuspensionStateDto] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProcessDefinitionSuspensionStateByKeyAndTenantId(key: string, tenantId: string, processDefinitionSuspensionStateDto?: ProcessDefinitionSuspensionStateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProcessDefinitionSuspensionStateByKeyAndTenantId(key, tenantId, processDefinitionSuspensionStateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProcessDefinitionApi - factory interface
 * @export
 */
export const ProcessDefinitionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProcessDefinitionApiFp(configuration)
    return {
        /**
         * Deletes a running process instance by id.
         * @summary Delete
         * @param {string} id The id of the process definition to be deleted.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessDefinition(id: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProcessDefinition(id, cascade, skipCustomListeners, skipIoMappings, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes process definitions by a given key which belong to no tenant id.
         * @summary Delete By Key
         * @param {string} key The key of the process definitions to be deleted.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessDefinitionsByKey(key: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProcessDefinitionsByKey(key, cascade, skipCustomListeners, skipIoMappings, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes process definitions by a given key and which belong to a tenant id.
         * @summary Delete By Key
         * @param {string} key The key of the process definitions to be deleted.
         * @param {string} tenantId The id of the tenant the process definitions belong to.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessDefinitionsByKeyAndTenantId(key: string, tenantId: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProcessDefinitionsByKeyAndTenantId(key, tenantId, cascade, skipCustomListeners, skipIoMappings, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves runtime statistics of a given process definition, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Activity Instance Statistics
         * @param {string} id The id of the process definition.
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityStatistics(id: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, options?: any): AxiosPromise<Array<ActivityStatisticsResultDto>> {
            return localVarFp.getActivityStatistics(id, failedJobs, incidents, incidentsForType, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves runtime statistics of the latest version of the given process definition which belongs to no tenant, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Activity Instance Statistics
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityStatisticsByProcessDefinitionKey(key: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, options?: any): AxiosPromise<Array<ActivityStatisticsResultDto>> {
            return localVarFp.getActivityStatisticsByProcessDefinitionKey(key, failedJobs, incidents, incidentsForType, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves runtime statistics of the latest version of the given process definition for a tenant, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Activity Instance Statistics
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityStatisticsByProcessDefinitionKeyAndTenantId(key: string, tenantId: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, options?: any): AxiosPromise<Array<ActivityStatisticsResultDto>> {
            return localVarFp.getActivityStatisticsByProcessDefinitionKeyAndTenantId(key, tenantId, failedJobs, incidents, incidentsForType, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Start Form
         * @param {string} id The id of the process definition to get the deployed start form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedStartForm(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.getDeployedStartForm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedStartFormByKey(key: string, options?: any): AxiosPromise<any> {
            return localVarFp.getDeployedStartFormByKey(key, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definitions belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedStartFormByKeyAndTenantId(key: string, tenantId: string, options?: any): AxiosPromise<any> {
            return localVarFp.getDeployedStartFormByKeyAndTenantId(key, tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the latest version of the process definition for tenant according to the `ProcessDefinition` interface in the engine.
         * @summary Get
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestProcessDefinitionByTenantId(key: string, tenantId: string, options?: any): AxiosPromise<ProcessDefinitionDto> {
            return localVarFp.getLatestProcessDefinitionByTenantId(key, tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a process definition according to the `ProcessDefinition` interface in the engine.
         * @summary Get
         * @param {string} id The id of the process definition to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinition(id: string, options?: any): AxiosPromise<ProcessDefinitionDto> {
            return localVarFp.getProcessDefinition(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the BPMN 2.0 XML of a process definition.
         * @summary Get XML
         * @param {string} id The id of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionBpmn20Xml(id: string, options?: any): AxiosPromise<ProcessDefinitionDiagramDto> {
            return localVarFp.getProcessDefinitionBpmn20Xml(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves latest version the BPMN 2.0 XML of a process definition.
         * @summary Get XML
         * @param {string} key The key of the process definition (the latest version thereof) whose XML should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionBpmn20XmlByKey(key: string, options?: any): AxiosPromise<ProcessDefinitionDiagramDto> {
            return localVarFp.getProcessDefinitionBpmn20XmlByKey(key, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves latest version the BPMN 2.0 XML of a process definition. Returns the XML for the latest version of the process definition for tenant.
         * @summary Get XML
         * @param {string} key The key of the process definition (the latest version thereof) whose XML should be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionBpmn20XmlByKeyAndTenantId(key: string, tenantId: string, options?: any): AxiosPromise<ProcessDefinitionDiagramDto> {
            return localVarFp.getProcessDefinitionBpmn20XmlByKeyAndTenantId(key, tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the latest version of the process definition which belongs to no tenant according to the `ProcessDefinition` interface in the engine.
         * @summary Get
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionByKey(key: string, options?: any): AxiosPromise<ProcessDefinitionDto> {
            return localVarFp.getProcessDefinitionByKey(key, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the diagram of a process definition.  If the process definition\'s deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
         * @summary Get Diagram
         * @param {string} id The id of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionDiagram(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.getProcessDefinitionDiagram(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the diagram for the latest version of the process definition which belongs to no tenant.  If the process definition\'s deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
         * @summary Get Diagram
         * @param {string} key The key of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionDiagramByKey(key: string, options?: any): AxiosPromise<any> {
            return localVarFp.getProcessDefinitionDiagramByKey(key, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the diagram for the latest version of the process definition for tenant.  If the process definition\'s deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
         * @summary Get Diagram
         * @param {string} key The key of the process definition.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionDiagramByKeyAndTenantId(key: string, tenantId: string, options?: any): AxiosPromise<any> {
            return localVarFp.getProcessDefinitionDiagramByKeyAndTenantId(key, tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves runtime statistics of the process engine, grouped by process definitions. These statistics include the number of running process instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Process Instance Statistics
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {boolean} [rootIncidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of root incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60; or &#x60;incidents&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionStatistics(failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, rootIncidents?: boolean, options?: any): AxiosPromise<Array<ProcessDefinitionStatisticsResultDto>> {
            return localVarFp.getProcessDefinitionStatistics(failedJobs, incidents, incidentsForType, rootIncidents, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for process definitions that fulfill given parameters. Parameters may be the properties of  process definitions, such as the name, key or version. The size of the result set can be retrieved by using the [Get Definition Count](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/get-query-count/) method.
         * @summary Get List
         * @param {string} [processDefinitionId] Filter by process definition id.
         * @param {string} [processDefinitionIdIn] Filter by a comma-separated list of process definition ids.
         * @param {string} [name] Filter by process definition name.
         * @param {string} [nameLike] Filter by process definition names that the parameter is a substring of.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {string} [deployedAfter] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [deployedAt] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [key] Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match.
         * @param {string} [keysIn] Filter by a comma-separated list of process definition keys.
         * @param {string} [keyLike] Filter by process definition keys that the parameter is a substring of.
         * @param {string} [category] Filter by process definition category. Exact match.
         * @param {string} [categoryLike] Filter by process definition categories that the parameter is a substring of.
         * @param {number} [version] Filter by process definition version.
         * @param {boolean} [latestVersion] Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [resourceName] Filter by the name of the process definition resource. Exact match.
         * @param {string} [resourceNameLike] Filter by names of those process definition resources that the parameter is a substring of.
         * @param {string} [startableBy] Filter by a user name who is allowed to start the process.
         * @param {boolean} [active] Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior.
         * @param {boolean} [includeProcessDefinitionsWithoutTenantId] Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [versionTag] Filter by the version tag.
         * @param {string} [versionTagLike] Filter by the version tag that the parameter is a substring of.
         * @param {boolean} [withoutVersionTag] Only include process definitions without a &#x60;versionTag&#x60;.
         * @param {boolean} [startableInTasklist] Filter by process definitions which are startable in Tasklist..
         * @param {boolean} [notStartableInTasklist] Filter by process definitions which are not startable in Tasklist.
         * @param {boolean} [startablePermissionCheck] Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn\&#39;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level
         * @param {'category' | 'key' | 'id' | 'name' | 'version' | 'deploymentId' | 'deployTime' | 'tenantId ' | 'versionTag'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitions(processDefinitionId?: string, processDefinitionIdIn?: string, name?: string, nameLike?: string, deploymentId?: string, deployedAfter?: string, deployedAt?: string, key?: string, keysIn?: string, keyLike?: string, category?: string, categoryLike?: string, version?: number, latestVersion?: boolean, resourceName?: string, resourceNameLike?: string, startableBy?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeProcessDefinitionsWithoutTenantId?: boolean, versionTag?: string, versionTagLike?: string, withoutVersionTag?: boolean, startableInTasklist?: boolean, notStartableInTasklist?: boolean, startablePermissionCheck?: boolean, sortBy?: 'category' | 'key' | 'id' | 'name' | 'version' | 'deploymentId' | 'deployTime' | 'tenantId ' | 'versionTag', sortOrder?: 'asc' | 'desc', firstResult?: number, maxResults?: number, options?: any): AxiosPromise<Array<ProcessDefinitionDto>> {
            return localVarFp.getProcessDefinitions(processDefinitionId, processDefinitionIdIn, name, nameLike, deploymentId, deployedAfter, deployedAt, key, keysIn, keyLike, category, categoryLike, version, latestVersion, resourceName, resourceNameLike, startableBy, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, includeProcessDefinitionsWithoutTenantId, versionTag, versionTagLike, withoutVersionTag, startableInTasklist, notStartableInTasklist, startablePermissionCheck, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(axios, basePath));
        },
        /**
         * Requests the number of process definitions that fulfill the query criteria. Takes the same filtering parameters as the [Get Definitions](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/get-query/) method.
         * @summary Get List Count
         * @param {string} [processDefinitionId] Filter by process definition id.
         * @param {string} [processDefinitionIdIn] Filter by a comma-separated list of process definition ids.
         * @param {string} [name] Filter by process definition name.
         * @param {string} [nameLike] Filter by process definition names that the parameter is a substring of.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {string} [deployedAfter] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [deployedAt] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [key] Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match.
         * @param {string} [keysIn] Filter by a comma-separated list of process definition keys.
         * @param {string} [keyLike] Filter by process definition keys that the parameter is a substring of.
         * @param {string} [category] Filter by process definition category. Exact match.
         * @param {string} [categoryLike] Filter by process definition categories that the parameter is a substring of.
         * @param {number} [version] Filter by process definition version.
         * @param {boolean} [latestVersion] Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [resourceName] Filter by the name of the process definition resource. Exact match.
         * @param {string} [resourceNameLike] Filter by names of those process definition resources that the parameter is a substring of.
         * @param {string} [startableBy] Filter by a user name who is allowed to start the process.
         * @param {boolean} [active] Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior.
         * @param {boolean} [includeProcessDefinitionsWithoutTenantId] Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [versionTag] Filter by the version tag.
         * @param {string} [versionTagLike] Filter by the version tag that the parameter is a substring of.
         * @param {boolean} [withoutVersionTag] Only include process definitions without a &#x60;versionTag&#x60;.
         * @param {boolean} [startableInTasklist] Filter by process definitions which are startable in Tasklist..
         * @param {boolean} [notStartableInTasklist] Filter by process definitions which are not startable in Tasklist.
         * @param {boolean} [startablePermissionCheck] Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn\&#39;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionsCount(processDefinitionId?: string, processDefinitionIdIn?: string, name?: string, nameLike?: string, deploymentId?: string, deployedAfter?: string, deployedAt?: string, key?: string, keysIn?: string, keyLike?: string, category?: string, categoryLike?: string, version?: number, latestVersion?: boolean, resourceName?: string, resourceNameLike?: string, startableBy?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeProcessDefinitionsWithoutTenantId?: boolean, versionTag?: string, versionTagLike?: string, withoutVersionTag?: boolean, startableInTasklist?: boolean, notStartableInTasklist?: boolean, startablePermissionCheck?: boolean, options?: any): AxiosPromise<CountResultDto> {
            return localVarFp.getProcessDefinitionsCount(processDefinitionId, processDefinitionIdIn, name, nameLike, deploymentId, deployedAfter, deployedAt, key, keysIn, keyLike, category, categoryLike, version, latestVersion, resourceName, resourceNameLike, startableBy, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, includeProcessDefinitionsWithoutTenantId, versionTag, versionTagLike, withoutVersionTag, startableInTasklist, notStartableInTasklist, startablePermissionCheck, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the rendered form for a process definition. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Start Form
         * @param {string} id The id of the process definition to get the rendered start form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRenderedStartForm(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.getRenderedStartForm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves  the rendered form for the latest version of the process definition which belongs to no tenant. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRenderedStartFormByKey(key: string, options?: any): AxiosPromise<any> {
            return localVarFp.getRenderedStartFormByKey(key, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves  the rendered form for the latest version of the process definition for a tenant. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRenderedStartFormByKeyAndTenantId(key: string, tenantId: string, options?: any): AxiosPromise<any> {
            return localVarFp.getRenderedStartFormByKeyAndTenantId(key, tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the key of the start form for a process definition. The form key corresponds to the `FormData#formKey` property in the engine.
         * @summary Get Start Form Key
         * @param {string} id The id of the process definition to get the start form key for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartForm(id: string, options?: any): AxiosPromise<FormDto> {
            return localVarFp.getStartForm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the key of the start form for the latest version of the process definition which belongs to no tenant. The form key corresponds to the `FormData#formKey` property in the engine.
         * @summary Get Start Form Key
         * @param {string} key The key of the process definition (the latest version thereof) for which the form key is to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormByKey(key: string, options?: any): AxiosPromise<FormDto> {
            return localVarFp.getStartFormByKey(key, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the key of the start form for the latest version of the process definition for a tenant. The form key corresponds to the `FormData#formKey` property in the engine.
         * @summary Get Start Form Key
         * @param {string} key The key of the process definition (the latest version thereof) for which the form key is to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormByKeyAndTenantId(key: string, tenantId: string, options?: any): AxiosPromise<FormDto> {
            return localVarFp.getStartFormByKeyAndTenantId(key, tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the start form variables for a process definition (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Start Form Variables
         * @param {string} id The id of the process definition to retrieve the variables for.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormVariables(id: string, variableNames?: string, deserializeValues?: boolean, options?: any): AxiosPromise<{ [key: string]: VariableValueDto; }> {
            return localVarFp.getStartFormVariables(id, variableNames, deserializeValues, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the start form variables for the latest process definition which belongs to no tenant (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Start Form Variables
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormVariablesByKey(key: string, variableNames?: string, deserializeValues?: boolean, options?: any): AxiosPromise<{ [key: string]: VariableValueDto; }> {
            return localVarFp.getStartFormVariablesByKey(key, variableNames, deserializeValues, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the start form variables for the latest process definition for a tenant (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Start Form Variables
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormVariablesByKeyAndTenantId(key: string, tenantId: string, variableNames?: string, deserializeValues?: boolean, options?: any): AxiosPromise<{ [key: string]: VariableValueDto; }> {
            return localVarFp.getStartFormVariablesByKeyAndTenantId(key, tenantId, variableNames, deserializeValues, options).then((request) => request(axios, basePath));
        },
        /**
         * Restarts process instances that were canceled or terminated synchronously. Can also restart completed process instances. It will create a new instance using the original instance information. To execute the restart asynchronously, use the [Restart Process Instance Async](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/post-restart-process-instance-async/) method.  For more information about the difference between synchronous and asynchronous execution, please refer to the related section of the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-restart/#execution).
         * @summary Restart Process Instance
         * @param {string} id The id of the process definition of the process instances to restart.
         * @param {RestartProcessInstanceDto} [restartProcessInstanceDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartProcessInstance(id: string, restartProcessInstanceDto?: RestartProcessInstanceDto, options?: any): AxiosPromise<void> {
            return localVarFp.restartProcessInstance(id, restartProcessInstanceDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Restarts process instances that were canceled or terminated asynchronously. Can also restart completed process instances. It will create a new instance using the original instance information. To execute the restart asynchronously, use the [Restart Process Instance](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/post-restart-process-instance-sync/) method.  For more information about the difference between synchronous and asynchronous execution, please refer to the related section of the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-restart/#execution).
         * @summary Restart Process Instance Async
         * @param {string} id The id of the process definition of the process instances to restart.
         * @param {RestartProcessInstanceDto} [restartProcessInstanceDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartProcessInstanceAsyncOperation(id: string, restartProcessInstanceDto?: RestartProcessInstanceDto, options?: any): AxiosPromise<BatchDto> {
            return localVarFp.restartProcessInstanceAsyncOperation(id, restartProcessInstanceDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Instantiates a given process definition. Process variables and business key may be supplied in the request body.
         * @summary Start Instance
         * @param {string} id The id of the process definition to be retrieved.
         * @param {StartProcessInstanceDto} [startProcessInstanceDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProcessInstance(id: string, startProcessInstanceDto?: StartProcessInstanceDto, options?: any): AxiosPromise<ProcessInstanceWithVariablesDto> {
            return localVarFp.startProcessInstance(id, startProcessInstanceDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Instantiates a given process definition, starts the latest version of the process definition which belongs to no tenant. Process variables and business key may be supplied in the request body.
         * @summary Start Instance
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {StartProcessInstanceDto} [startProcessInstanceDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProcessInstanceByKey(key: string, startProcessInstanceDto?: StartProcessInstanceDto, options?: any): AxiosPromise<ProcessInstanceWithVariablesDto> {
            return localVarFp.startProcessInstanceByKey(key, startProcessInstanceDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Instantiates a given process definition, starts the latest version of the process definition for tenant. Process variables and business key may be supplied in the request body.
         * @summary Start Instance
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {StartProcessInstanceDto} [startProcessInstanceDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProcessInstanceByKeyAndTenantId(key: string, tenantId: string, startProcessInstanceDto?: StartProcessInstanceDto, options?: any): AxiosPromise<ProcessInstanceWithVariablesDto> {
            return localVarFp.startProcessInstanceByKeyAndTenantId(key, tenantId, startProcessInstanceDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Starts a process instance using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Submit Start Form
         * @param {string} id The id of the process definition to submit the form for.
         * @param {StartProcessInstanceFormDto} [startProcessInstanceFormDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitForm(id: string, startProcessInstanceFormDto?: StartProcessInstanceFormDto, options?: any): AxiosPromise<ProcessInstanceDto> {
            return localVarFp.submitForm(id, startProcessInstanceFormDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Starts the latest version of the process definition which belongs to no tenant using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Submit Start Form
         * @param {string} key The key of the process definition to submit the form for.
         * @param {StartProcessInstanceFormDto} [startProcessInstanceFormDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitFormByKey(key: string, startProcessInstanceFormDto?: StartProcessInstanceFormDto, options?: any): AxiosPromise<ProcessInstanceDto> {
            return localVarFp.submitFormByKey(key, startProcessInstanceFormDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Starts the latest version of the process definition for a tenant using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Submit Start Form
         * @param {string} key The key of the process definition to submit the form for.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {StartProcessInstanceFormDto} [startProcessInstanceFormDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitFormByKeyAndTenantId(key: string, tenantId: string, startProcessInstanceFormDto?: StartProcessInstanceFormDto, options?: any): AxiosPromise<ProcessInstanceDto> {
            return localVarFp.submitFormByKeyAndTenantId(key, tenantId, startProcessInstanceFormDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates history time to live for process definition. The field is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
         * @summary Update History Time to Live
         * @param {string} id The id of the process definition to change history time to live.
         * @param {HistoryTimeToLiveDto} [historyTimeToLiveDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHistoryTimeToLiveByProcessDefinitionId(id: string, historyTimeToLiveDto?: HistoryTimeToLiveDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateHistoryTimeToLiveByProcessDefinitionId(id, historyTimeToLiveDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates history time to live for the latest version of the process definition which belongs to no tenant. The field is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
         * @summary Update History Time to Live
         * @param {string} key The key of the process definition to change history time to live.
         * @param {HistoryTimeToLiveDto} [historyTimeToLiveDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHistoryTimeToLiveByProcessDefinitionKey(key: string, historyTimeToLiveDto?: HistoryTimeToLiveDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateHistoryTimeToLiveByProcessDefinitionKey(key, historyTimeToLiveDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates history time to live for the latest version of the process definition for a tenant. The field is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
         * @summary Update History Time to Live
         * @param {string} key The key of the process definition to change history time to live.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {HistoryTimeToLiveDto} [historyTimeToLiveDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId(key: string, tenantId: string, historyTimeToLiveDto?: HistoryTimeToLiveDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId(key, tenantId, historyTimeToLiveDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Activates or suspends process definitions with the given process definition key.
         * @summary Activate/Suspend By Key
         * @param {ProcessDefinitionSuspensionStateDto} [processDefinitionSuspensionStateDto] **Note**: Unallowed property is &#x60;processDefinitionId&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessDefinitionSuspensionState(processDefinitionSuspensionStateDto?: ProcessDefinitionSuspensionStateDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateProcessDefinitionSuspensionState(processDefinitionSuspensionStateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Activates or suspends a given process definition by id.
         * @summary Activate/Suspend By Id
         * @param {string} id The id of the process definition to activate or suspend.
         * @param {ProcessDefinitionSuspensionStateDto} [processDefinitionSuspensionStateDto] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessDefinitionSuspensionStateById(id: string, processDefinitionSuspensionStateDto?: ProcessDefinitionSuspensionStateDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateProcessDefinitionSuspensionStateById(id, processDefinitionSuspensionStateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Activates or suspends a given process definition by latest version of process definition key which belongs to no tenant.
         * @summary Activate/Suspend by Id
         * @param {string} key The key of the process definition (the latest version thereof) to be activated/suspended.
         * @param {ProcessDefinitionSuspensionStateDto} [processDefinitionSuspensionStateDto] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessDefinitionSuspensionStateByKey(key: string, processDefinitionSuspensionStateDto?: ProcessDefinitionSuspensionStateDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateProcessDefinitionSuspensionStateByKey(key, processDefinitionSuspensionStateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Activates or suspends a given process definition by the latest version of the process definition for tenant.
         * @summary Activate/Suspend by Id
         * @param {string} key The key of the process definition (the latest version thereof) to be activated/suspended.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {ProcessDefinitionSuspensionStateDto} [processDefinitionSuspensionStateDto] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessDefinitionSuspensionStateByKeyAndTenantId(key: string, tenantId: string, processDefinitionSuspensionStateDto?: ProcessDefinitionSuspensionStateDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateProcessDefinitionSuspensionStateByKeyAndTenantId(key, tenantId, processDefinitionSuspensionStateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProcessDefinitionApi - object-oriented interface
 * @export
 * @class ProcessDefinitionApi
 * @extends {BaseAPI}
 */
export class ProcessDefinitionApi extends BaseAPI {
    /**
     * Deletes a running process instance by id.
     * @summary Delete
     * @param {string} id The id of the process definition to be deleted.
     * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
     * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
     * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public deleteProcessDefinition(id: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).deleteProcessDefinition(id, cascade, skipCustomListeners, skipIoMappings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes process definitions by a given key which belong to no tenant id.
     * @summary Delete By Key
     * @param {string} key The key of the process definitions to be deleted.
     * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
     * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
     * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public deleteProcessDefinitionsByKey(key: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).deleteProcessDefinitionsByKey(key, cascade, skipCustomListeners, skipIoMappings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes process definitions by a given key and which belong to a tenant id.
     * @summary Delete By Key
     * @param {string} key The key of the process definitions to be deleted.
     * @param {string} tenantId The id of the tenant the process definitions belong to.
     * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
     * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
     * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public deleteProcessDefinitionsByKeyAndTenantId(key: string, tenantId: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).deleteProcessDefinitionsByKeyAndTenantId(key, tenantId, cascade, skipCustomListeners, skipIoMappings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves runtime statistics of a given process definition, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
     * @summary Get Activity Instance Statistics
     * @param {string} id The id of the process definition.
     * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
     * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
     * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getActivityStatistics(id: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).getActivityStatistics(id, failedJobs, incidents, incidentsForType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves runtime statistics of the latest version of the given process definition which belongs to no tenant, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
     * @summary Get Activity Instance Statistics
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
     * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
     * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getActivityStatisticsByProcessDefinitionKey(key: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).getActivityStatisticsByProcessDefinitionKey(key, failedJobs, incidents, incidentsForType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves runtime statistics of the latest version of the given process definition for a tenant, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
     * @summary Get Activity Instance Statistics
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
     * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
     * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getActivityStatisticsByProcessDefinitionKeyAndTenantId(key: string, tenantId: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).getActivityStatisticsByProcessDefinitionKeyAndTenantId(key, tenantId, failedJobs, incidents, incidentsForType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
     * @summary Get Deployed Start Form
     * @param {string} id The id of the process definition to get the deployed start form for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getDeployedStartForm(id: string, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).getDeployedStartForm(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
     * @summary Get Deployed Start Form
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getDeployedStartFormByKey(key: string, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).getDeployedStartFormByKey(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
     * @summary Get Deployed Start Form
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {string} tenantId The id of the tenant the process definitions belong to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getDeployedStartFormByKeyAndTenantId(key: string, tenantId: string, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).getDeployedStartFormByKeyAndTenantId(key, tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the latest version of the process definition for tenant according to the `ProcessDefinition` interface in the engine.
     * @summary Get
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getLatestProcessDefinitionByTenantId(key: string, tenantId: string, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).getLatestProcessDefinitionByTenantId(key, tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a process definition according to the `ProcessDefinition` interface in the engine.
     * @summary Get
     * @param {string} id The id of the process definition to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getProcessDefinition(id: string, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).getProcessDefinition(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the BPMN 2.0 XML of a process definition.
     * @summary Get XML
     * @param {string} id The id of the process definition.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getProcessDefinitionBpmn20Xml(id: string, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).getProcessDefinitionBpmn20Xml(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves latest version the BPMN 2.0 XML of a process definition.
     * @summary Get XML
     * @param {string} key The key of the process definition (the latest version thereof) whose XML should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getProcessDefinitionBpmn20XmlByKey(key: string, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).getProcessDefinitionBpmn20XmlByKey(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves latest version the BPMN 2.0 XML of a process definition. Returns the XML for the latest version of the process definition for tenant.
     * @summary Get XML
     * @param {string} key The key of the process definition (the latest version thereof) whose XML should be retrieved.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getProcessDefinitionBpmn20XmlByKeyAndTenantId(key: string, tenantId: string, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).getProcessDefinitionBpmn20XmlByKeyAndTenantId(key, tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the latest version of the process definition which belongs to no tenant according to the `ProcessDefinition` interface in the engine.
     * @summary Get
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getProcessDefinitionByKey(key: string, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).getProcessDefinitionByKey(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the diagram of a process definition.  If the process definition\'s deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
     * @summary Get Diagram
     * @param {string} id The id of the process definition.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getProcessDefinitionDiagram(id: string, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).getProcessDefinitionDiagram(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the diagram for the latest version of the process definition which belongs to no tenant.  If the process definition\'s deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
     * @summary Get Diagram
     * @param {string} key The key of the process definition.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getProcessDefinitionDiagramByKey(key: string, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).getProcessDefinitionDiagramByKey(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the diagram for the latest version of the process definition for tenant.  If the process definition\'s deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
     * @summary Get Diagram
     * @param {string} key The key of the process definition.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getProcessDefinitionDiagramByKeyAndTenantId(key: string, tenantId: string, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).getProcessDefinitionDiagramByKeyAndTenantId(key, tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves runtime statistics of the process engine, grouped by process definitions. These statistics include the number of running process instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
     * @summary Get Process Instance Statistics
     * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
     * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
     * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param {boolean} [rootIncidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of root incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60; or &#x60;incidents&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getProcessDefinitionStatistics(failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, rootIncidents?: boolean, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).getProcessDefinitionStatistics(failedJobs, incidents, incidentsForType, rootIncidents, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Queries for process definitions that fulfill given parameters. Parameters may be the properties of  process definitions, such as the name, key or version. The size of the result set can be retrieved by using the [Get Definition Count](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/get-query-count/) method.
     * @summary Get List
     * @param {string} [processDefinitionId] Filter by process definition id.
     * @param {string} [processDefinitionIdIn] Filter by a comma-separated list of process definition ids.
     * @param {string} [name] Filter by process definition name.
     * @param {string} [nameLike] Filter by process definition names that the parameter is a substring of.
     * @param {string} [deploymentId] Filter by the deployment the id belongs to.
     * @param {string} [deployedAfter] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
     * @param {string} [deployedAt] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
     * @param {string} [key] Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match.
     * @param {string} [keysIn] Filter by a comma-separated list of process definition keys.
     * @param {string} [keyLike] Filter by process definition keys that the parameter is a substring of.
     * @param {string} [category] Filter by process definition category. Exact match.
     * @param {string} [categoryLike] Filter by process definition categories that the parameter is a substring of.
     * @param {number} [version] Filter by process definition version.
     * @param {boolean} [latestVersion] Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [resourceName] Filter by the name of the process definition resource. Exact match.
     * @param {string} [resourceNameLike] Filter by names of those process definition resources that the parameter is a substring of.
     * @param {string} [startableBy] Filter by a user name who is allowed to start the process.
     * @param {boolean} [active] Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [suspended] Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [incidentId] Filter by the incident id.
     * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param {string} [incidentMessage] Filter by the incident message. Exact match.
     * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
     * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids.
     * @param {boolean} [withoutTenantId] Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior.
     * @param {boolean} [includeProcessDefinitionsWithoutTenantId] Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [versionTag] Filter by the version tag.
     * @param {string} [versionTagLike] Filter by the version tag that the parameter is a substring of.
     * @param {boolean} [withoutVersionTag] Only include process definitions without a &#x60;versionTag&#x60;.
     * @param {boolean} [startableInTasklist] Filter by process definitions which are startable in Tasklist..
     * @param {boolean} [notStartableInTasklist] Filter by process definitions which are not startable in Tasklist.
     * @param {boolean} [startablePermissionCheck] Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn\&#39;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level
     * @param {'category' | 'key' | 'id' | 'name' | 'version' | 'deploymentId' | 'deployTime' | 'tenantId ' | 'versionTag'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getProcessDefinitions(processDefinitionId?: string, processDefinitionIdIn?: string, name?: string, nameLike?: string, deploymentId?: string, deployedAfter?: string, deployedAt?: string, key?: string, keysIn?: string, keyLike?: string, category?: string, categoryLike?: string, version?: number, latestVersion?: boolean, resourceName?: string, resourceNameLike?: string, startableBy?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeProcessDefinitionsWithoutTenantId?: boolean, versionTag?: string, versionTagLike?: string, withoutVersionTag?: boolean, startableInTasklist?: boolean, notStartableInTasklist?: boolean, startablePermissionCheck?: boolean, sortBy?: 'category' | 'key' | 'id' | 'name' | 'version' | 'deploymentId' | 'deployTime' | 'tenantId ' | 'versionTag', sortOrder?: 'asc' | 'desc', firstResult?: number, maxResults?: number, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).getProcessDefinitions(processDefinitionId, processDefinitionIdIn, name, nameLike, deploymentId, deployedAfter, deployedAt, key, keysIn, keyLike, category, categoryLike, version, latestVersion, resourceName, resourceNameLike, startableBy, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, includeProcessDefinitionsWithoutTenantId, versionTag, versionTagLike, withoutVersionTag, startableInTasklist, notStartableInTasklist, startablePermissionCheck, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requests the number of process definitions that fulfill the query criteria. Takes the same filtering parameters as the [Get Definitions](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/get-query/) method.
     * @summary Get List Count
     * @param {string} [processDefinitionId] Filter by process definition id.
     * @param {string} [processDefinitionIdIn] Filter by a comma-separated list of process definition ids.
     * @param {string} [name] Filter by process definition name.
     * @param {string} [nameLike] Filter by process definition names that the parameter is a substring of.
     * @param {string} [deploymentId] Filter by the deployment the id belongs to.
     * @param {string} [deployedAfter] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
     * @param {string} [deployedAt] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
     * @param {string} [key] Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match.
     * @param {string} [keysIn] Filter by a comma-separated list of process definition keys.
     * @param {string} [keyLike] Filter by process definition keys that the parameter is a substring of.
     * @param {string} [category] Filter by process definition category. Exact match.
     * @param {string} [categoryLike] Filter by process definition categories that the parameter is a substring of.
     * @param {number} [version] Filter by process definition version.
     * @param {boolean} [latestVersion] Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [resourceName] Filter by the name of the process definition resource. Exact match.
     * @param {string} [resourceNameLike] Filter by names of those process definition resources that the parameter is a substring of.
     * @param {string} [startableBy] Filter by a user name who is allowed to start the process.
     * @param {boolean} [active] Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [suspended] Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [incidentId] Filter by the incident id.
     * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param {string} [incidentMessage] Filter by the incident message. Exact match.
     * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
     * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids.
     * @param {boolean} [withoutTenantId] Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior.
     * @param {boolean} [includeProcessDefinitionsWithoutTenantId] Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [versionTag] Filter by the version tag.
     * @param {string} [versionTagLike] Filter by the version tag that the parameter is a substring of.
     * @param {boolean} [withoutVersionTag] Only include process definitions without a &#x60;versionTag&#x60;.
     * @param {boolean} [startableInTasklist] Filter by process definitions which are startable in Tasklist..
     * @param {boolean} [notStartableInTasklist] Filter by process definitions which are not startable in Tasklist.
     * @param {boolean} [startablePermissionCheck] Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn\&#39;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getProcessDefinitionsCount(processDefinitionId?: string, processDefinitionIdIn?: string, name?: string, nameLike?: string, deploymentId?: string, deployedAfter?: string, deployedAt?: string, key?: string, keysIn?: string, keyLike?: string, category?: string, categoryLike?: string, version?: number, latestVersion?: boolean, resourceName?: string, resourceNameLike?: string, startableBy?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeProcessDefinitionsWithoutTenantId?: boolean, versionTag?: string, versionTagLike?: string, withoutVersionTag?: boolean, startableInTasklist?: boolean, notStartableInTasklist?: boolean, startablePermissionCheck?: boolean, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).getProcessDefinitionsCount(processDefinitionId, processDefinitionIdIn, name, nameLike, deploymentId, deployedAfter, deployedAt, key, keysIn, keyLike, category, categoryLike, version, latestVersion, resourceName, resourceNameLike, startableBy, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, includeProcessDefinitionsWithoutTenantId, versionTag, versionTagLike, withoutVersionTag, startableInTasklist, notStartableInTasklist, startablePermissionCheck, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the rendered form for a process definition. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
     * @summary Get Rendered Start Form
     * @param {string} id The id of the process definition to get the rendered start form for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getRenderedStartForm(id: string, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).getRenderedStartForm(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves  the rendered form for the latest version of the process definition which belongs to no tenant. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
     * @summary Get Rendered Start Form
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getRenderedStartFormByKey(key: string, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).getRenderedStartFormByKey(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves  the rendered form for the latest version of the process definition for a tenant. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
     * @summary Get Rendered Start Form
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getRenderedStartFormByKeyAndTenantId(key: string, tenantId: string, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).getRenderedStartFormByKeyAndTenantId(key, tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the key of the start form for a process definition. The form key corresponds to the `FormData#formKey` property in the engine.
     * @summary Get Start Form Key
     * @param {string} id The id of the process definition to get the start form key for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getStartForm(id: string, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).getStartForm(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the key of the start form for the latest version of the process definition which belongs to no tenant. The form key corresponds to the `FormData#formKey` property in the engine.
     * @summary Get Start Form Key
     * @param {string} key The key of the process definition (the latest version thereof) for which the form key is to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getStartFormByKey(key: string, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).getStartFormByKey(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the key of the start form for the latest version of the process definition for a tenant. The form key corresponds to the `FormData#formKey` property in the engine.
     * @summary Get Start Form Key
     * @param {string} key The key of the process definition (the latest version thereof) for which the form key is to be retrieved.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getStartFormByKeyAndTenantId(key: string, tenantId: string, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).getStartFormByKeyAndTenantId(key, tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the start form variables for a process definition (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
     * @summary Get Start Form Variables
     * @param {string} id The id of the process definition to retrieve the variables for.
     * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
     * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getStartFormVariables(id: string, variableNames?: string, deserializeValues?: boolean, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).getStartFormVariables(id, variableNames, deserializeValues, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the start form variables for the latest process definition which belongs to no tenant (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
     * @summary Get Start Form Variables
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
     * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getStartFormVariablesByKey(key: string, variableNames?: string, deserializeValues?: boolean, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).getStartFormVariablesByKey(key, variableNames, deserializeValues, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the start form variables for the latest process definition for a tenant (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
     * @summary Get Start Form Variables
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
     * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getStartFormVariablesByKeyAndTenantId(key: string, tenantId: string, variableNames?: string, deserializeValues?: boolean, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).getStartFormVariablesByKeyAndTenantId(key, tenantId, variableNames, deserializeValues, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restarts process instances that were canceled or terminated synchronously. Can also restart completed process instances. It will create a new instance using the original instance information. To execute the restart asynchronously, use the [Restart Process Instance Async](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/post-restart-process-instance-async/) method.  For more information about the difference between synchronous and asynchronous execution, please refer to the related section of the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-restart/#execution).
     * @summary Restart Process Instance
     * @param {string} id The id of the process definition of the process instances to restart.
     * @param {RestartProcessInstanceDto} [restartProcessInstanceDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public restartProcessInstance(id: string, restartProcessInstanceDto?: RestartProcessInstanceDto, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).restartProcessInstance(id, restartProcessInstanceDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restarts process instances that were canceled or terminated asynchronously. Can also restart completed process instances. It will create a new instance using the original instance information. To execute the restart asynchronously, use the [Restart Process Instance](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/post-restart-process-instance-sync/) method.  For more information about the difference between synchronous and asynchronous execution, please refer to the related section of the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-restart/#execution).
     * @summary Restart Process Instance Async
     * @param {string} id The id of the process definition of the process instances to restart.
     * @param {RestartProcessInstanceDto} [restartProcessInstanceDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public restartProcessInstanceAsyncOperation(id: string, restartProcessInstanceDto?: RestartProcessInstanceDto, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).restartProcessInstanceAsyncOperation(id, restartProcessInstanceDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Instantiates a given process definition. Process variables and business key may be supplied in the request body.
     * @summary Start Instance
     * @param {string} id The id of the process definition to be retrieved.
     * @param {StartProcessInstanceDto} [startProcessInstanceDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public startProcessInstance(id: string, startProcessInstanceDto?: StartProcessInstanceDto, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).startProcessInstance(id, startProcessInstanceDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Instantiates a given process definition, starts the latest version of the process definition which belongs to no tenant. Process variables and business key may be supplied in the request body.
     * @summary Start Instance
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {StartProcessInstanceDto} [startProcessInstanceDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public startProcessInstanceByKey(key: string, startProcessInstanceDto?: StartProcessInstanceDto, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).startProcessInstanceByKey(key, startProcessInstanceDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Instantiates a given process definition, starts the latest version of the process definition for tenant. Process variables and business key may be supplied in the request body.
     * @summary Start Instance
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {StartProcessInstanceDto} [startProcessInstanceDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public startProcessInstanceByKeyAndTenantId(key: string, tenantId: string, startProcessInstanceDto?: StartProcessInstanceDto, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).startProcessInstanceByKeyAndTenantId(key, tenantId, startProcessInstanceDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starts a process instance using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
     * @summary Submit Start Form
     * @param {string} id The id of the process definition to submit the form for.
     * @param {StartProcessInstanceFormDto} [startProcessInstanceFormDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public submitForm(id: string, startProcessInstanceFormDto?: StartProcessInstanceFormDto, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).submitForm(id, startProcessInstanceFormDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starts the latest version of the process definition which belongs to no tenant using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
     * @summary Submit Start Form
     * @param {string} key The key of the process definition to submit the form for.
     * @param {StartProcessInstanceFormDto} [startProcessInstanceFormDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public submitFormByKey(key: string, startProcessInstanceFormDto?: StartProcessInstanceFormDto, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).submitFormByKey(key, startProcessInstanceFormDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starts the latest version of the process definition for a tenant using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
     * @summary Submit Start Form
     * @param {string} key The key of the process definition to submit the form for.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {StartProcessInstanceFormDto} [startProcessInstanceFormDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public submitFormByKeyAndTenantId(key: string, tenantId: string, startProcessInstanceFormDto?: StartProcessInstanceFormDto, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).submitFormByKeyAndTenantId(key, tenantId, startProcessInstanceFormDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates history time to live for process definition. The field is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
     * @summary Update History Time to Live
     * @param {string} id The id of the process definition to change history time to live.
     * @param {HistoryTimeToLiveDto} [historyTimeToLiveDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public updateHistoryTimeToLiveByProcessDefinitionId(id: string, historyTimeToLiveDto?: HistoryTimeToLiveDto, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).updateHistoryTimeToLiveByProcessDefinitionId(id, historyTimeToLiveDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates history time to live for the latest version of the process definition which belongs to no tenant. The field is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
     * @summary Update History Time to Live
     * @param {string} key The key of the process definition to change history time to live.
     * @param {HistoryTimeToLiveDto} [historyTimeToLiveDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public updateHistoryTimeToLiveByProcessDefinitionKey(key: string, historyTimeToLiveDto?: HistoryTimeToLiveDto, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).updateHistoryTimeToLiveByProcessDefinitionKey(key, historyTimeToLiveDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates history time to live for the latest version of the process definition for a tenant. The field is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
     * @summary Update History Time to Live
     * @param {string} key The key of the process definition to change history time to live.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {HistoryTimeToLiveDto} [historyTimeToLiveDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId(key: string, tenantId: string, historyTimeToLiveDto?: HistoryTimeToLiveDto, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId(key, tenantId, historyTimeToLiveDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Activates or suspends process definitions with the given process definition key.
     * @summary Activate/Suspend By Key
     * @param {ProcessDefinitionSuspensionStateDto} [processDefinitionSuspensionStateDto] **Note**: Unallowed property is &#x60;processDefinitionId&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public updateProcessDefinitionSuspensionState(processDefinitionSuspensionStateDto?: ProcessDefinitionSuspensionStateDto, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).updateProcessDefinitionSuspensionState(processDefinitionSuspensionStateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Activates or suspends a given process definition by id.
     * @summary Activate/Suspend By Id
     * @param {string} id The id of the process definition to activate or suspend.
     * @param {ProcessDefinitionSuspensionStateDto} [processDefinitionSuspensionStateDto] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public updateProcessDefinitionSuspensionStateById(id: string, processDefinitionSuspensionStateDto?: ProcessDefinitionSuspensionStateDto, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).updateProcessDefinitionSuspensionStateById(id, processDefinitionSuspensionStateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Activates or suspends a given process definition by latest version of process definition key which belongs to no tenant.
     * @summary Activate/Suspend by Id
     * @param {string} key The key of the process definition (the latest version thereof) to be activated/suspended.
     * @param {ProcessDefinitionSuspensionStateDto} [processDefinitionSuspensionStateDto] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public updateProcessDefinitionSuspensionStateByKey(key: string, processDefinitionSuspensionStateDto?: ProcessDefinitionSuspensionStateDto, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).updateProcessDefinitionSuspensionStateByKey(key, processDefinitionSuspensionStateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Activates or suspends a given process definition by the latest version of the process definition for tenant.
     * @summary Activate/Suspend by Id
     * @param {string} key The key of the process definition (the latest version thereof) to be activated/suspended.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {ProcessDefinitionSuspensionStateDto} [processDefinitionSuspensionStateDto] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public updateProcessDefinitionSuspensionStateByKeyAndTenantId(key: string, tenantId: string, processDefinitionSuspensionStateDto?: ProcessDefinitionSuspensionStateDto, options?: AxiosRequestConfig) {
        return ProcessDefinitionApiFp(this.configuration).updateProcessDefinitionSuspensionStateByKeyAndTenantId(key, tenantId, processDefinitionSuspensionStateDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProcessInstanceApi - axios parameter creator
 * @export
 */
export const ProcessInstanceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a set of process instances asynchronously (batch) based on a historic process instance query.
         * @param {DeleteProcessInstancesDto} [deleteProcessInstancesDto] **Unallowed property**: &#x60;processInstanceQuery&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAsyncHistoricQueryBased: async (deleteProcessInstancesDto?: DeleteProcessInstancesDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/process-instance/delete-historic-query-based`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteProcessInstancesDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a running process instance by id.
         * @param {string} id The id of the process instance to be deleted.
         * @param {boolean} [skipCustomListeners] If set to true, the custom listeners will be skipped.
         * @param {boolean} [skipIoMappings] If set to true, the input/output mappings will be skipped.
         * @param {boolean} [skipSubprocesses] If set to true, subprocesses related to deleted processes will be skipped.
         * @param {boolean} [failIfNotExists] If set to false, the request will still be successful if the process id is not found.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessInstance: async (id: string, skipCustomListeners?: boolean, skipIoMappings?: boolean, skipSubprocesses?: boolean, failIfNotExists?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProcessInstance', 'id', id)
            const localVarPath = `/process-instance/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skipCustomListeners !== undefined) {
                localVarQueryParameter['skipCustomListeners'] = skipCustomListeners;
            }

            if (skipIoMappings !== undefined) {
                localVarQueryParameter['skipIoMappings'] = skipIoMappings;
            }

            if (skipSubprocesses !== undefined) {
                localVarQueryParameter['skipSubprocesses'] = skipSubprocesses;
            }

            if (failIfNotExists !== undefined) {
                localVarQueryParameter['failIfNotExists'] = failIfNotExists;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a variable of a process instance by id.
         * @param {string} id The id of the process instance to delete the variable from.
         * @param {string} varName The name of the variable to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessInstanceVariable: async (id: string, varName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProcessInstanceVariable', 'id', id)
            // verify required parameter 'varName' is not null or undefined
            assertParamExists('deleteProcessInstanceVariable', 'varName', varName)
            const localVarPath = `/process-instance/{id}/variables/{varName}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes multiple process instances asynchronously (batch).
         * @param {DeleteProcessInstancesDto} [deleteProcessInstancesDto] **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessInstancesAsyncOperation: async (deleteProcessInstancesDto?: DeleteProcessInstancesDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/process-instance/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteProcessInstancesDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves an Activity Instance (Tree) for a given process instance by id.
         * @param {string} id The id of the process instance for which the activity instance should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityInstanceTree: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getActivityInstanceTree', 'id', id)
            const localVarPath = `/process-instance/{id}/activity-instances`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a variable of a given process instance by id.
         * @param {string} id The id of the process instance to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstanceVariable: async (id: string, varName: string, deserializeValue?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProcessInstanceVariable', 'id', id)
            // verify required parameter 'varName' is not null or undefined
            assertParamExists('getProcessInstanceVariable', 'varName', varName)
            const localVarPath = `/process-instance/{id}/variables/{varName}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (deserializeValue !== undefined) {
                localVarQueryParameter['deserializeValue'] = deserializeValue;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the content of a Process Variable by the Process Instance id and the Process Variable name. Applicable for byte array or file Process Variables.
         * @param {string} id The id of the process instance to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstanceVariableBinary: async (id: string, varName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProcessInstanceVariableBinary', 'id', id)
            // verify required parameter 'varName' is not null or undefined
            assertParamExists('getProcessInstanceVariableBinary', 'varName', varName)
            const localVarPath = `/process-instance/{id}/variables/{varName}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all variables of a given process instance by id.
         * @param {string} id The id of the process instance to retrieve the variables from.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstanceVariables: async (id: string, deserializeValue?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProcessInstanceVariables', 'id', id)
            const localVarPath = `/process-instance/{id}/variables`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (deserializeValue !== undefined) {
                localVarQueryParameter['deserializeValue'] = deserializeValue;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for process instances that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of process instances. The size of the result set can be retrieved by using the Get Instance Count method.
         * @param {'instanceId' | 'definitionKey' | 'definitionId' | 'tenantId' | 'businessKey'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {string} [processInstanceIds] Filter by a comma-separated list of process instance ids.
         * @param {string} [businessKey] Filter by process instance business key.
         * @param {string} [businessKeyLike] Filter by process instance business key that the parameter is a substring of.
         * @param {string} [caseInstanceId] Filter by case instance id.
         * @param {string} [processDefinitionId] Filter by the deployment the id belongs to.
         * @param {string} [processDefinitionKey] Filter by the key of the process definition the instances run on.
         * @param {string} [processDefinitionKeyIn] Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys.
         * @param {string} [processDefinitionKeyNotIn] Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {string} [superProcessInstance] Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id.
         * @param {string} [subProcessInstance] Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id.
         * @param {string} [superCaseInstance] Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.
         * @param {string} [subCaseInstance] Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id.
         * @param {boolean} [active] Only include active process instances. Value may only be true, as false is the default behavior.
         * @param {boolean} [suspended] Only include suspended process instances. Value may only be true, as false is the default behavior.
         * @param {boolean} [withIncident] Filter by presence of incidents. Selects only process instances that have an incident.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process instances which belong to no tenant.
         * @param {boolean} [processDefinitionWithoutTenantId] Only include process instances which process definition has no tenant id.
         * @param {string} [activityIdIn] Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids.
         * @param {boolean} [rootProcessInstances] Restrict the query to all process instances that are top level process instances.
         * @param {boolean} [leafProcessInstances] Restrict the query to all process instances that are leaf instances. (i.e. don\&#39;t have any sub instances).
         * @param {string} [variables] Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstances: async (sortBy?: 'instanceId' | 'definitionKey' | 'definitionId' | 'tenantId' | 'businessKey', sortOrder?: 'asc' | 'desc', firstResult?: number, maxResults?: number, processInstanceIds?: string, businessKey?: string, businessKeyLike?: string, caseInstanceId?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionKeyNotIn?: string, deploymentId?: string, superProcessInstance?: string, subProcessInstance?: string, superCaseInstance?: string, subCaseInstance?: string, active?: boolean, suspended?: boolean, withIncident?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, processDefinitionWithoutTenantId?: boolean, activityIdIn?: string, rootProcessInstances?: boolean, leafProcessInstances?: boolean, variables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/process-instance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }

            if (processInstanceIds !== undefined) {
                localVarQueryParameter['processInstanceIds'] = processInstanceIds;
            }

            if (businessKey !== undefined) {
                localVarQueryParameter['businessKey'] = businessKey;
            }

            if (businessKeyLike !== undefined) {
                localVarQueryParameter['businessKeyLike'] = businessKeyLike;
            }

            if (caseInstanceId !== undefined) {
                localVarQueryParameter['caseInstanceId'] = caseInstanceId;
            }

            if (processDefinitionId !== undefined) {
                localVarQueryParameter['processDefinitionId'] = processDefinitionId;
            }

            if (processDefinitionKey !== undefined) {
                localVarQueryParameter['processDefinitionKey'] = processDefinitionKey;
            }

            if (processDefinitionKeyIn !== undefined) {
                localVarQueryParameter['processDefinitionKeyIn'] = processDefinitionKeyIn;
            }

            if (processDefinitionKeyNotIn !== undefined) {
                localVarQueryParameter['processDefinitionKeyNotIn'] = processDefinitionKeyNotIn;
            }

            if (deploymentId !== undefined) {
                localVarQueryParameter['deploymentId'] = deploymentId;
            }

            if (superProcessInstance !== undefined) {
                localVarQueryParameter['superProcessInstance'] = superProcessInstance;
            }

            if (subProcessInstance !== undefined) {
                localVarQueryParameter['subProcessInstance'] = subProcessInstance;
            }

            if (superCaseInstance !== undefined) {
                localVarQueryParameter['superCaseInstance'] = superCaseInstance;
            }

            if (subCaseInstance !== undefined) {
                localVarQueryParameter['subCaseInstance'] = subCaseInstance;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (suspended !== undefined) {
                localVarQueryParameter['suspended'] = suspended;
            }

            if (withIncident !== undefined) {
                localVarQueryParameter['withIncident'] = withIncident;
            }

            if (incidentId !== undefined) {
                localVarQueryParameter['incidentId'] = incidentId;
            }

            if (incidentType !== undefined) {
                localVarQueryParameter['incidentType'] = incidentType;
            }

            if (incidentMessage !== undefined) {
                localVarQueryParameter['incidentMessage'] = incidentMessage;
            }

            if (incidentMessageLike !== undefined) {
                localVarQueryParameter['incidentMessageLike'] = incidentMessageLike;
            }

            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }

            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }

            if (processDefinitionWithoutTenantId !== undefined) {
                localVarQueryParameter['processDefinitionWithoutTenantId'] = processDefinitionWithoutTenantId;
            }

            if (activityIdIn !== undefined) {
                localVarQueryParameter['activityIdIn'] = activityIdIn;
            }

            if (rootProcessInstances !== undefined) {
                localVarQueryParameter['rootProcessInstances'] = rootProcessInstances;
            }

            if (leafProcessInstances !== undefined) {
                localVarQueryParameter['leafProcessInstances'] = leafProcessInstances;
            }

            if (variables !== undefined) {
                localVarQueryParameter['variables'] = variables;
            }

            if (variableNamesIgnoreCase !== undefined) {
                localVarQueryParameter['variableNamesIgnoreCase'] = variableNamesIgnoreCase;
            }

            if (variableValuesIgnoreCase !== undefined) {
                localVarQueryParameter['variableValuesIgnoreCase'] = variableValuesIgnoreCase;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for the number of process instances that fulfill given parameters.
         * @param {string} [processInstanceIds] Filter by a comma-separated list of process instance ids.
         * @param {string} [businessKey] Filter by process instance business key.
         * @param {string} [businessKeyLike] Filter by process instance business key that the parameter is a substring of.
         * @param {string} [caseInstanceId] Filter by case instance id.
         * @param {string} [processDefinitionId] Filter by the deployment the id belongs to.
         * @param {string} [processDefinitionKey] Filter by the key of the process definition the instances run on.
         * @param {string} [processDefinitionKeyIn] Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys.
         * @param {string} [processDefinitionKeyNotIn] Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {string} [superProcessInstance] Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id.
         * @param {string} [subProcessInstance] Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id.
         * @param {string} [superCaseInstance] Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.
         * @param {string} [subCaseInstance] Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id.
         * @param {boolean} [active] Only include active process instances. Value may only be true, as false is the default behavior.
         * @param {boolean} [suspended] Only include suspended process instances. Value may only be true, as false is the default behavior.
         * @param {boolean} [withIncident] Filter by presence of incidents. Selects only process instances that have an incident.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process instances which belong to no tenant.
         * @param {boolean} [processDefinitionWithoutTenantId] Only include process instances which process definition has no tenant id.
         * @param {string} [activityIdIn] Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids.
         * @param {boolean} [rootProcessInstances] Restrict the query to all process instances that are top level process instances.
         * @param {boolean} [leafProcessInstances] Restrict the query to all process instances that are leaf instances. (i.e. don\&#39;t have any sub instances).
         * @param {string} [variables] Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstancesCount: async (processInstanceIds?: string, businessKey?: string, businessKeyLike?: string, caseInstanceId?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionKeyNotIn?: string, deploymentId?: string, superProcessInstance?: string, subProcessInstance?: string, superCaseInstance?: string, subCaseInstance?: string, active?: boolean, suspended?: boolean, withIncident?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, processDefinitionWithoutTenantId?: boolean, activityIdIn?: string, rootProcessInstances?: boolean, leafProcessInstances?: boolean, variables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/process-instance/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (processInstanceIds !== undefined) {
                localVarQueryParameter['processInstanceIds'] = processInstanceIds;
            }

            if (businessKey !== undefined) {
                localVarQueryParameter['businessKey'] = businessKey;
            }

            if (businessKeyLike !== undefined) {
                localVarQueryParameter['businessKeyLike'] = businessKeyLike;
            }

            if (caseInstanceId !== undefined) {
                localVarQueryParameter['caseInstanceId'] = caseInstanceId;
            }

            if (processDefinitionId !== undefined) {
                localVarQueryParameter['processDefinitionId'] = processDefinitionId;
            }

            if (processDefinitionKey !== undefined) {
                localVarQueryParameter['processDefinitionKey'] = processDefinitionKey;
            }

            if (processDefinitionKeyIn !== undefined) {
                localVarQueryParameter['processDefinitionKeyIn'] = processDefinitionKeyIn;
            }

            if (processDefinitionKeyNotIn !== undefined) {
                localVarQueryParameter['processDefinitionKeyNotIn'] = processDefinitionKeyNotIn;
            }

            if (deploymentId !== undefined) {
                localVarQueryParameter['deploymentId'] = deploymentId;
            }

            if (superProcessInstance !== undefined) {
                localVarQueryParameter['superProcessInstance'] = superProcessInstance;
            }

            if (subProcessInstance !== undefined) {
                localVarQueryParameter['subProcessInstance'] = subProcessInstance;
            }

            if (superCaseInstance !== undefined) {
                localVarQueryParameter['superCaseInstance'] = superCaseInstance;
            }

            if (subCaseInstance !== undefined) {
                localVarQueryParameter['subCaseInstance'] = subCaseInstance;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (suspended !== undefined) {
                localVarQueryParameter['suspended'] = suspended;
            }

            if (withIncident !== undefined) {
                localVarQueryParameter['withIncident'] = withIncident;
            }

            if (incidentId !== undefined) {
                localVarQueryParameter['incidentId'] = incidentId;
            }

            if (incidentType !== undefined) {
                localVarQueryParameter['incidentType'] = incidentType;
            }

            if (incidentMessage !== undefined) {
                localVarQueryParameter['incidentMessage'] = incidentMessage;
            }

            if (incidentMessageLike !== undefined) {
                localVarQueryParameter['incidentMessageLike'] = incidentMessageLike;
            }

            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }

            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }

            if (processDefinitionWithoutTenantId !== undefined) {
                localVarQueryParameter['processDefinitionWithoutTenantId'] = processDefinitionWithoutTenantId;
            }

            if (activityIdIn !== undefined) {
                localVarQueryParameter['activityIdIn'] = activityIdIn;
            }

            if (rootProcessInstances !== undefined) {
                localVarQueryParameter['rootProcessInstances'] = rootProcessInstances;
            }

            if (leafProcessInstances !== undefined) {
                localVarQueryParameter['leafProcessInstances'] = leafProcessInstances;
            }

            if (variables !== undefined) {
                localVarQueryParameter['variables'] = variables;
            }

            if (variableNamesIgnoreCase !== undefined) {
                localVarQueryParameter['variableNamesIgnoreCase'] = variableNamesIgnoreCase;
            }

            if (variableValuesIgnoreCase !== undefined) {
                localVarQueryParameter['variableValuesIgnoreCase'] = variableValuesIgnoreCase;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submits a list of modification instructions to change a process instance\'s execution state. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Canceling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed immediately and in the order they are provided in this request\'s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/develop/user-guide/process-engine/process-instance-modification/).
         * @param {string} id The id of the process instance to modify.
         * @param {ProcessInstanceModificationDto} [processInstanceModificationDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyProcessInstance: async (id: string, processInstanceModificationDto?: ProcessInstanceModificationDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('modifyProcessInstance', 'id', id)
            const localVarPath = `/process-instance/{id}/modification`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(processInstanceModificationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submits a list of modification instructions to change a process instance\'s execution state async. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Cancelling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed asynchronous and in the order they are provided in this request\'s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-modification/).
         * @param {string} id The id of the process instance to modify.
         * @param {ProcessInstanceModificationDto} [processInstanceModificationDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyProcessInstanceAsyncOperation: async (id: string, processInstanceModificationDto?: ProcessInstanceModificationDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('modifyProcessInstanceAsyncOperation', 'id', id)
            const localVarPath = `/process-instance/{id}/modification-async`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(processInstanceModificationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates or deletes the variables of a process instance by id. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
         * @param {string} id The id of the process instance to set variables for.
         * @param {PatchVariablesDto} [patchVariablesDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyProcessInstanceVariables: async (id: string, patchVariablesDto?: PatchVariablesDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('modifyProcessInstanceVariables', 'id', id)
            const localVarPath = `/process-instance/{id}/variables`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchVariablesDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for process instances that fulfill given parameters through a JSON object. This method is slightly more powerful than the Get Instances method because it allows filtering by multiple process variables of types `string`, `number` or `boolean`.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {ProcessInstanceQueryDto} [processInstanceQueryDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryProcessInstances: async (firstResult?: number, maxResults?: number, processInstanceQueryDto?: ProcessInstanceQueryDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/process-instance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(processInstanceQueryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for the number of process instances that fulfill the given parameters. This method takes the same message body as the Get Instances (POST) method and therefore it is slightly more powerful than the Get Instance Count method.
         * @param {ProcessInstanceQueryDto} [processInstanceQueryDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryProcessInstancesCount: async (processInstanceQueryDto?: ProcessInstanceQueryDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/process-instance/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(processInstanceQueryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets a variable of a given process instance by id.
         * @param {string} id The id of the process instance to set the variable for.
         * @param {string} varName The name of the variable to set.
         * @param {VariableValueDto} [variableValueDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProcessInstanceVariable: async (id: string, varName: string, variableValueDto?: VariableValueDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setProcessInstanceVariable', 'id', id)
            // verify required parameter 'varName' is not null or undefined
            assertParamExists('setProcessInstanceVariable', 'varName', varName)
            const localVarPath = `/process-instance/{id}/variables/{varName}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableValueDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the serialized value for a binary variable or the binary value for a file variable.
         * @param {string} id The id of the process instance to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {any} [data] The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory.
         * @param {string} [valueType] The name of the variable type. Either Bytes for a byte array variable or File for a file variable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProcessInstanceVariableBinary: async (id: string, varName: string, data?: any, valueType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setProcessInstanceVariableBinary', 'id', id)
            // verify required parameter 'varName' is not null or undefined
            assertParamExists('setProcessInstanceVariableBinary', 'varName', varName)
            const localVarPath = `/process-instance/{id}/variables/{varName}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (data !== undefined) { 
                localVarFormParams.append('data', data as any);
            }
    
            if (valueType !== undefined) { 
                localVarFormParams.append('valueType', valueType as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a batch to set retries of jobs associated with given processes asynchronously.
         * @param {SetJobRetriesByProcessDto} [setJobRetriesByProcessDto] Please note that if both processInstances and processInstanceQuery are provided, then the resulting execution will be performed on the union of these sets. **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRetriesByProcess: async (setJobRetriesByProcessDto?: SetJobRetriesByProcessDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/process-instance/job-retries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setJobRetriesByProcessDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a batch to set retries of jobs asynchronously based on a historic process instance query.
         * @param {SetJobRetriesByProcessDto} [setJobRetriesByProcessDto] Please note that if both processInstances and historicProcessInstanceQuery are provided, then the resulting execution will be performed on the union of these sets. **Unallowed property**: &#x60;processInstanceQuery&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRetriesByProcessHistoricQueryBased: async (setJobRetriesByProcessDto?: SetJobRetriesByProcessDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/process-instance/job-retries-historic-query-based`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setJobRetriesByProcessDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activates or suspends process instances by providing certain criteria:  # Activate/Suspend Process Instance By Process Definition Id * `suspend` * `processDefinitionId`  # Activate/Suspend Process Instance By Process Definition Key  * `suspend` * `processDefinitionKey` * `processDefinitionTenantId` * `processDefinitionWithoutTenantId`  # Activate/Suspend Process Instance In Group * `suspend` * `processInstanceIds` * `processInstanceQuery` * `historicProcessInstanceQuery`
         * @param {ProcessInstanceSuspensionStateDto} [processInstanceSuspensionStateDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSuspensionState: async (processInstanceSuspensionStateDto?: ProcessInstanceSuspensionStateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/process-instance/suspended`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(processInstanceSuspensionStateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activates or suspends process instances asynchronously with a list of process instance ids, a process instance query, and/or a historical process instance query.
         * @param {ProcessInstanceSuspensionStateAsyncDto} [processInstanceSuspensionStateAsyncDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSuspensionStateAsyncOperation: async (processInstanceSuspensionStateAsyncDto?: ProcessInstanceSuspensionStateAsyncDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/process-instance/suspended-async`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(processInstanceSuspensionStateAsyncDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activates or suspends a given process instance by id.
         * @param {string} id The id of the process instance to activate or suspend.
         * @param {SuspensionStateDto} [suspensionStateDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSuspensionStateById: async (id: string, suspensionStateDto?: SuspensionStateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSuspensionStateById', 'id', id)
            const localVarPath = `/process-instance/{id}/suspended`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(suspensionStateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProcessInstanceApi - functional programming interface
 * @export
 */
export const ProcessInstanceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProcessInstanceApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a set of process instances asynchronously (batch) based on a historic process instance query.
         * @param {DeleteProcessInstancesDto} [deleteProcessInstancesDto] **Unallowed property**: &#x60;processInstanceQuery&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAsyncHistoricQueryBased(deleteProcessInstancesDto?: DeleteProcessInstancesDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAsyncHistoricQueryBased(deleteProcessInstancesDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a running process instance by id.
         * @param {string} id The id of the process instance to be deleted.
         * @param {boolean} [skipCustomListeners] If set to true, the custom listeners will be skipped.
         * @param {boolean} [skipIoMappings] If set to true, the input/output mappings will be skipped.
         * @param {boolean} [skipSubprocesses] If set to true, subprocesses related to deleted processes will be skipped.
         * @param {boolean} [failIfNotExists] If set to false, the request will still be successful if the process id is not found.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProcessInstance(id: string, skipCustomListeners?: boolean, skipIoMappings?: boolean, skipSubprocesses?: boolean, failIfNotExists?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProcessInstance(id, skipCustomListeners, skipIoMappings, skipSubprocesses, failIfNotExists, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a variable of a process instance by id.
         * @param {string} id The id of the process instance to delete the variable from.
         * @param {string} varName The name of the variable to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProcessInstanceVariable(id: string, varName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProcessInstanceVariable(id, varName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes multiple process instances asynchronously (batch).
         * @param {DeleteProcessInstancesDto} [deleteProcessInstancesDto] **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProcessInstancesAsyncOperation(deleteProcessInstancesDto?: DeleteProcessInstancesDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProcessInstancesAsyncOperation(deleteProcessInstancesDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves an Activity Instance (Tree) for a given process instance by id.
         * @param {string} id The id of the process instance for which the activity instance should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivityInstanceTree(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivityInstanceDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivityInstanceTree(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a variable of a given process instance by id.
         * @param {string} id The id of the process instance to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessInstanceVariable(id: string, varName: string, deserializeValue?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableValueDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessInstanceVariable(id, varName, deserializeValue, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the content of a Process Variable by the Process Instance id and the Process Variable name. Applicable for byte array or file Process Variables.
         * @param {string} id The id of the process instance to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessInstanceVariableBinary(id: string, varName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessInstanceVariableBinary(id, varName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves all variables of a given process instance by id.
         * @param {string} id The id of the process instance to retrieve the variables from.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessInstanceVariables(id: string, deserializeValue?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: VariableValueDto; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessInstanceVariables(id, deserializeValue, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Queries for process instances that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of process instances. The size of the result set can be retrieved by using the Get Instance Count method.
         * @param {'instanceId' | 'definitionKey' | 'definitionId' | 'tenantId' | 'businessKey'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {string} [processInstanceIds] Filter by a comma-separated list of process instance ids.
         * @param {string} [businessKey] Filter by process instance business key.
         * @param {string} [businessKeyLike] Filter by process instance business key that the parameter is a substring of.
         * @param {string} [caseInstanceId] Filter by case instance id.
         * @param {string} [processDefinitionId] Filter by the deployment the id belongs to.
         * @param {string} [processDefinitionKey] Filter by the key of the process definition the instances run on.
         * @param {string} [processDefinitionKeyIn] Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys.
         * @param {string} [processDefinitionKeyNotIn] Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {string} [superProcessInstance] Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id.
         * @param {string} [subProcessInstance] Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id.
         * @param {string} [superCaseInstance] Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.
         * @param {string} [subCaseInstance] Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id.
         * @param {boolean} [active] Only include active process instances. Value may only be true, as false is the default behavior.
         * @param {boolean} [suspended] Only include suspended process instances. Value may only be true, as false is the default behavior.
         * @param {boolean} [withIncident] Filter by presence of incidents. Selects only process instances that have an incident.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process instances which belong to no tenant.
         * @param {boolean} [processDefinitionWithoutTenantId] Only include process instances which process definition has no tenant id.
         * @param {string} [activityIdIn] Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids.
         * @param {boolean} [rootProcessInstances] Restrict the query to all process instances that are top level process instances.
         * @param {boolean} [leafProcessInstances] Restrict the query to all process instances that are leaf instances. (i.e. don\&#39;t have any sub instances).
         * @param {string} [variables] Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessInstances(sortBy?: 'instanceId' | 'definitionKey' | 'definitionId' | 'tenantId' | 'businessKey', sortOrder?: 'asc' | 'desc', firstResult?: number, maxResults?: number, processInstanceIds?: string, businessKey?: string, businessKeyLike?: string, caseInstanceId?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionKeyNotIn?: string, deploymentId?: string, superProcessInstance?: string, subProcessInstance?: string, superCaseInstance?: string, subCaseInstance?: string, active?: boolean, suspended?: boolean, withIncident?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, processDefinitionWithoutTenantId?: boolean, activityIdIn?: string, rootProcessInstances?: boolean, leafProcessInstances?: boolean, variables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProcessInstanceDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessInstances(sortBy, sortOrder, firstResult, maxResults, processInstanceIds, businessKey, businessKeyLike, caseInstanceId, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionKeyNotIn, deploymentId, superProcessInstance, subProcessInstance, superCaseInstance, subCaseInstance, active, suspended, withIncident, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, processDefinitionWithoutTenantId, activityIdIn, rootProcessInstances, leafProcessInstances, variables, variableNamesIgnoreCase, variableValuesIgnoreCase, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Queries for the number of process instances that fulfill given parameters.
         * @param {string} [processInstanceIds] Filter by a comma-separated list of process instance ids.
         * @param {string} [businessKey] Filter by process instance business key.
         * @param {string} [businessKeyLike] Filter by process instance business key that the parameter is a substring of.
         * @param {string} [caseInstanceId] Filter by case instance id.
         * @param {string} [processDefinitionId] Filter by the deployment the id belongs to.
         * @param {string} [processDefinitionKey] Filter by the key of the process definition the instances run on.
         * @param {string} [processDefinitionKeyIn] Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys.
         * @param {string} [processDefinitionKeyNotIn] Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {string} [superProcessInstance] Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id.
         * @param {string} [subProcessInstance] Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id.
         * @param {string} [superCaseInstance] Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.
         * @param {string} [subCaseInstance] Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id.
         * @param {boolean} [active] Only include active process instances. Value may only be true, as false is the default behavior.
         * @param {boolean} [suspended] Only include suspended process instances. Value may only be true, as false is the default behavior.
         * @param {boolean} [withIncident] Filter by presence of incidents. Selects only process instances that have an incident.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process instances which belong to no tenant.
         * @param {boolean} [processDefinitionWithoutTenantId] Only include process instances which process definition has no tenant id.
         * @param {string} [activityIdIn] Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids.
         * @param {boolean} [rootProcessInstances] Restrict the query to all process instances that are top level process instances.
         * @param {boolean} [leafProcessInstances] Restrict the query to all process instances that are leaf instances. (i.e. don\&#39;t have any sub instances).
         * @param {string} [variables] Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessInstancesCount(processInstanceIds?: string, businessKey?: string, businessKeyLike?: string, caseInstanceId?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionKeyNotIn?: string, deploymentId?: string, superProcessInstance?: string, subProcessInstance?: string, superCaseInstance?: string, subCaseInstance?: string, active?: boolean, suspended?: boolean, withIncident?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, processDefinitionWithoutTenantId?: boolean, activityIdIn?: string, rootProcessInstances?: boolean, leafProcessInstances?: boolean, variables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessInstancesCount(processInstanceIds, businessKey, businessKeyLike, caseInstanceId, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionKeyNotIn, deploymentId, superProcessInstance, subProcessInstance, superCaseInstance, subCaseInstance, active, suspended, withIncident, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, processDefinitionWithoutTenantId, activityIdIn, rootProcessInstances, leafProcessInstances, variables, variableNamesIgnoreCase, variableValuesIgnoreCase, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Submits a list of modification instructions to change a process instance\'s execution state. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Canceling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed immediately and in the order they are provided in this request\'s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/develop/user-guide/process-engine/process-instance-modification/).
         * @param {string} id The id of the process instance to modify.
         * @param {ProcessInstanceModificationDto} [processInstanceModificationDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyProcessInstance(id: string, processInstanceModificationDto?: ProcessInstanceModificationDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyProcessInstance(id, processInstanceModificationDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Submits a list of modification instructions to change a process instance\'s execution state async. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Cancelling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed asynchronous and in the order they are provided in this request\'s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-modification/).
         * @param {string} id The id of the process instance to modify.
         * @param {ProcessInstanceModificationDto} [processInstanceModificationDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyProcessInstanceAsyncOperation(id: string, processInstanceModificationDto?: ProcessInstanceModificationDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyProcessInstanceAsyncOperation(id, processInstanceModificationDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates or deletes the variables of a process instance by id. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
         * @param {string} id The id of the process instance to set variables for.
         * @param {PatchVariablesDto} [patchVariablesDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyProcessInstanceVariables(id: string, patchVariablesDto?: PatchVariablesDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyProcessInstanceVariables(id, patchVariablesDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Queries for process instances that fulfill given parameters through a JSON object. This method is slightly more powerful than the Get Instances method because it allows filtering by multiple process variables of types `string`, `number` or `boolean`.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {ProcessInstanceQueryDto} [processInstanceQueryDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryProcessInstances(firstResult?: number, maxResults?: number, processInstanceQueryDto?: ProcessInstanceQueryDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProcessInstanceDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryProcessInstances(firstResult, maxResults, processInstanceQueryDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Queries for the number of process instances that fulfill the given parameters. This method takes the same message body as the Get Instances (POST) method and therefore it is slightly more powerful than the Get Instance Count method.
         * @param {ProcessInstanceQueryDto} [processInstanceQueryDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryProcessInstancesCount(processInstanceQueryDto?: ProcessInstanceQueryDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryProcessInstancesCount(processInstanceQueryDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets a variable of a given process instance by id.
         * @param {string} id The id of the process instance to set the variable for.
         * @param {string} varName The name of the variable to set.
         * @param {VariableValueDto} [variableValueDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setProcessInstanceVariable(id: string, varName: string, variableValueDto?: VariableValueDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setProcessInstanceVariable(id, varName, variableValueDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets the serialized value for a binary variable or the binary value for a file variable.
         * @param {string} id The id of the process instance to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {any} [data] The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory.
         * @param {string} [valueType] The name of the variable type. Either Bytes for a byte array variable or File for a file variable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setProcessInstanceVariableBinary(id: string, varName: string, data?: any, valueType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setProcessInstanceVariableBinary(id, varName, data, valueType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a batch to set retries of jobs associated with given processes asynchronously.
         * @param {SetJobRetriesByProcessDto} [setJobRetriesByProcessDto] Please note that if both processInstances and processInstanceQuery are provided, then the resulting execution will be performed on the union of these sets. **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRetriesByProcess(setJobRetriesByProcessDto?: SetJobRetriesByProcessDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setRetriesByProcess(setJobRetriesByProcessDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a batch to set retries of jobs asynchronously based on a historic process instance query.
         * @param {SetJobRetriesByProcessDto} [setJobRetriesByProcessDto] Please note that if both processInstances and historicProcessInstanceQuery are provided, then the resulting execution will be performed on the union of these sets. **Unallowed property**: &#x60;processInstanceQuery&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRetriesByProcessHistoricQueryBased(setJobRetriesByProcessDto?: SetJobRetriesByProcessDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setRetriesByProcessHistoricQueryBased(setJobRetriesByProcessDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Activates or suspends process instances by providing certain criteria:  # Activate/Suspend Process Instance By Process Definition Id * `suspend` * `processDefinitionId`  # Activate/Suspend Process Instance By Process Definition Key  * `suspend` * `processDefinitionKey` * `processDefinitionTenantId` * `processDefinitionWithoutTenantId`  # Activate/Suspend Process Instance In Group * `suspend` * `processInstanceIds` * `processInstanceQuery` * `historicProcessInstanceQuery`
         * @param {ProcessInstanceSuspensionStateDto} [processInstanceSuspensionStateDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSuspensionState(processInstanceSuspensionStateDto?: ProcessInstanceSuspensionStateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSuspensionState(processInstanceSuspensionStateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Activates or suspends process instances asynchronously with a list of process instance ids, a process instance query, and/or a historical process instance query.
         * @param {ProcessInstanceSuspensionStateAsyncDto} [processInstanceSuspensionStateAsyncDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSuspensionStateAsyncOperation(processInstanceSuspensionStateAsyncDto?: ProcessInstanceSuspensionStateAsyncDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSuspensionStateAsyncOperation(processInstanceSuspensionStateAsyncDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Activates or suspends a given process instance by id.
         * @param {string} id The id of the process instance to activate or suspend.
         * @param {SuspensionStateDto} [suspensionStateDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSuspensionStateById(id: string, suspensionStateDto?: SuspensionStateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSuspensionStateById(id, suspensionStateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProcessInstanceApi - factory interface
 * @export
 */
export const ProcessInstanceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProcessInstanceApiFp(configuration)
    return {
        /**
         * Deletes a set of process instances asynchronously (batch) based on a historic process instance query.
         * @param {DeleteProcessInstancesDto} [deleteProcessInstancesDto] **Unallowed property**: &#x60;processInstanceQuery&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAsyncHistoricQueryBased(deleteProcessInstancesDto?: DeleteProcessInstancesDto, options?: any): AxiosPromise<BatchDto> {
            return localVarFp.deleteAsyncHistoricQueryBased(deleteProcessInstancesDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a running process instance by id.
         * @param {string} id The id of the process instance to be deleted.
         * @param {boolean} [skipCustomListeners] If set to true, the custom listeners will be skipped.
         * @param {boolean} [skipIoMappings] If set to true, the input/output mappings will be skipped.
         * @param {boolean} [skipSubprocesses] If set to true, subprocesses related to deleted processes will be skipped.
         * @param {boolean} [failIfNotExists] If set to false, the request will still be successful if the process id is not found.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessInstance(id: string, skipCustomListeners?: boolean, skipIoMappings?: boolean, skipSubprocesses?: boolean, failIfNotExists?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProcessInstance(id, skipCustomListeners, skipIoMappings, skipSubprocesses, failIfNotExists, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a variable of a process instance by id.
         * @param {string} id The id of the process instance to delete the variable from.
         * @param {string} varName The name of the variable to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessInstanceVariable(id: string, varName: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProcessInstanceVariable(id, varName, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes multiple process instances asynchronously (batch).
         * @param {DeleteProcessInstancesDto} [deleteProcessInstancesDto] **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessInstancesAsyncOperation(deleteProcessInstancesDto?: DeleteProcessInstancesDto, options?: any): AxiosPromise<BatchDto> {
            return localVarFp.deleteProcessInstancesAsyncOperation(deleteProcessInstancesDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves an Activity Instance (Tree) for a given process instance by id.
         * @param {string} id The id of the process instance for which the activity instance should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityInstanceTree(id: string, options?: any): AxiosPromise<ActivityInstanceDto> {
            return localVarFp.getActivityInstanceTree(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a variable of a given process instance by id.
         * @param {string} id The id of the process instance to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstanceVariable(id: string, varName: string, deserializeValue?: boolean, options?: any): AxiosPromise<VariableValueDto> {
            return localVarFp.getProcessInstanceVariable(id, varName, deserializeValue, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the content of a Process Variable by the Process Instance id and the Process Variable name. Applicable for byte array or file Process Variables.
         * @param {string} id The id of the process instance to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstanceVariableBinary(id: string, varName: string, options?: any): AxiosPromise<any> {
            return localVarFp.getProcessInstanceVariableBinary(id, varName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all variables of a given process instance by id.
         * @param {string} id The id of the process instance to retrieve the variables from.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstanceVariables(id: string, deserializeValue?: boolean, options?: any): AxiosPromise<{ [key: string]: VariableValueDto; }> {
            return localVarFp.getProcessInstanceVariables(id, deserializeValue, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for process instances that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of process instances. The size of the result set can be retrieved by using the Get Instance Count method.
         * @param {'instanceId' | 'definitionKey' | 'definitionId' | 'tenantId' | 'businessKey'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {string} [processInstanceIds] Filter by a comma-separated list of process instance ids.
         * @param {string} [businessKey] Filter by process instance business key.
         * @param {string} [businessKeyLike] Filter by process instance business key that the parameter is a substring of.
         * @param {string} [caseInstanceId] Filter by case instance id.
         * @param {string} [processDefinitionId] Filter by the deployment the id belongs to.
         * @param {string} [processDefinitionKey] Filter by the key of the process definition the instances run on.
         * @param {string} [processDefinitionKeyIn] Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys.
         * @param {string} [processDefinitionKeyNotIn] Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {string} [superProcessInstance] Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id.
         * @param {string} [subProcessInstance] Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id.
         * @param {string} [superCaseInstance] Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.
         * @param {string} [subCaseInstance] Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id.
         * @param {boolean} [active] Only include active process instances. Value may only be true, as false is the default behavior.
         * @param {boolean} [suspended] Only include suspended process instances. Value may only be true, as false is the default behavior.
         * @param {boolean} [withIncident] Filter by presence of incidents. Selects only process instances that have an incident.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process instances which belong to no tenant.
         * @param {boolean} [processDefinitionWithoutTenantId] Only include process instances which process definition has no tenant id.
         * @param {string} [activityIdIn] Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids.
         * @param {boolean} [rootProcessInstances] Restrict the query to all process instances that are top level process instances.
         * @param {boolean} [leafProcessInstances] Restrict the query to all process instances that are leaf instances. (i.e. don\&#39;t have any sub instances).
         * @param {string} [variables] Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstances(sortBy?: 'instanceId' | 'definitionKey' | 'definitionId' | 'tenantId' | 'businessKey', sortOrder?: 'asc' | 'desc', firstResult?: number, maxResults?: number, processInstanceIds?: string, businessKey?: string, businessKeyLike?: string, caseInstanceId?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionKeyNotIn?: string, deploymentId?: string, superProcessInstance?: string, subProcessInstance?: string, superCaseInstance?: string, subCaseInstance?: string, active?: boolean, suspended?: boolean, withIncident?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, processDefinitionWithoutTenantId?: boolean, activityIdIn?: string, rootProcessInstances?: boolean, leafProcessInstances?: boolean, variables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, options?: any): AxiosPromise<Array<ProcessInstanceDto>> {
            return localVarFp.getProcessInstances(sortBy, sortOrder, firstResult, maxResults, processInstanceIds, businessKey, businessKeyLike, caseInstanceId, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionKeyNotIn, deploymentId, superProcessInstance, subProcessInstance, superCaseInstance, subCaseInstance, active, suspended, withIncident, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, processDefinitionWithoutTenantId, activityIdIn, rootProcessInstances, leafProcessInstances, variables, variableNamesIgnoreCase, variableValuesIgnoreCase, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for the number of process instances that fulfill given parameters.
         * @param {string} [processInstanceIds] Filter by a comma-separated list of process instance ids.
         * @param {string} [businessKey] Filter by process instance business key.
         * @param {string} [businessKeyLike] Filter by process instance business key that the parameter is a substring of.
         * @param {string} [caseInstanceId] Filter by case instance id.
         * @param {string} [processDefinitionId] Filter by the deployment the id belongs to.
         * @param {string} [processDefinitionKey] Filter by the key of the process definition the instances run on.
         * @param {string} [processDefinitionKeyIn] Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys.
         * @param {string} [processDefinitionKeyNotIn] Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {string} [superProcessInstance] Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id.
         * @param {string} [subProcessInstance] Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id.
         * @param {string} [superCaseInstance] Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.
         * @param {string} [subCaseInstance] Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id.
         * @param {boolean} [active] Only include active process instances. Value may only be true, as false is the default behavior.
         * @param {boolean} [suspended] Only include suspended process instances. Value may only be true, as false is the default behavior.
         * @param {boolean} [withIncident] Filter by presence of incidents. Selects only process instances that have an incident.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process instances which belong to no tenant.
         * @param {boolean} [processDefinitionWithoutTenantId] Only include process instances which process definition has no tenant id.
         * @param {string} [activityIdIn] Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids.
         * @param {boolean} [rootProcessInstances] Restrict the query to all process instances that are top level process instances.
         * @param {boolean} [leafProcessInstances] Restrict the query to all process instances that are leaf instances. (i.e. don\&#39;t have any sub instances).
         * @param {string} [variables] Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstancesCount(processInstanceIds?: string, businessKey?: string, businessKeyLike?: string, caseInstanceId?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionKeyNotIn?: string, deploymentId?: string, superProcessInstance?: string, subProcessInstance?: string, superCaseInstance?: string, subCaseInstance?: string, active?: boolean, suspended?: boolean, withIncident?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, processDefinitionWithoutTenantId?: boolean, activityIdIn?: string, rootProcessInstances?: boolean, leafProcessInstances?: boolean, variables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, options?: any): AxiosPromise<CountResultDto> {
            return localVarFp.getProcessInstancesCount(processInstanceIds, businessKey, businessKeyLike, caseInstanceId, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionKeyNotIn, deploymentId, superProcessInstance, subProcessInstance, superCaseInstance, subCaseInstance, active, suspended, withIncident, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, processDefinitionWithoutTenantId, activityIdIn, rootProcessInstances, leafProcessInstances, variables, variableNamesIgnoreCase, variableValuesIgnoreCase, options).then((request) => request(axios, basePath));
        },
        /**
         * Submits a list of modification instructions to change a process instance\'s execution state. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Canceling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed immediately and in the order they are provided in this request\'s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/develop/user-guide/process-engine/process-instance-modification/).
         * @param {string} id The id of the process instance to modify.
         * @param {ProcessInstanceModificationDto} [processInstanceModificationDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyProcessInstance(id: string, processInstanceModificationDto?: ProcessInstanceModificationDto, options?: any): AxiosPromise<void> {
            return localVarFp.modifyProcessInstance(id, processInstanceModificationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Submits a list of modification instructions to change a process instance\'s execution state async. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Cancelling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed asynchronous and in the order they are provided in this request\'s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-modification/).
         * @param {string} id The id of the process instance to modify.
         * @param {ProcessInstanceModificationDto} [processInstanceModificationDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyProcessInstanceAsyncOperation(id: string, processInstanceModificationDto?: ProcessInstanceModificationDto, options?: any): AxiosPromise<BatchDto> {
            return localVarFp.modifyProcessInstanceAsyncOperation(id, processInstanceModificationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates or deletes the variables of a process instance by id. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
         * @param {string} id The id of the process instance to set variables for.
         * @param {PatchVariablesDto} [patchVariablesDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyProcessInstanceVariables(id: string, patchVariablesDto?: PatchVariablesDto, options?: any): AxiosPromise<void> {
            return localVarFp.modifyProcessInstanceVariables(id, patchVariablesDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for process instances that fulfill given parameters through a JSON object. This method is slightly more powerful than the Get Instances method because it allows filtering by multiple process variables of types `string`, `number` or `boolean`.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {ProcessInstanceQueryDto} [processInstanceQueryDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryProcessInstances(firstResult?: number, maxResults?: number, processInstanceQueryDto?: ProcessInstanceQueryDto, options?: any): AxiosPromise<Array<ProcessInstanceDto>> {
            return localVarFp.queryProcessInstances(firstResult, maxResults, processInstanceQueryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for the number of process instances that fulfill the given parameters. This method takes the same message body as the Get Instances (POST) method and therefore it is slightly more powerful than the Get Instance Count method.
         * @param {ProcessInstanceQueryDto} [processInstanceQueryDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryProcessInstancesCount(processInstanceQueryDto?: ProcessInstanceQueryDto, options?: any): AxiosPromise<CountResultDto> {
            return localVarFp.queryProcessInstancesCount(processInstanceQueryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets a variable of a given process instance by id.
         * @param {string} id The id of the process instance to set the variable for.
         * @param {string} varName The name of the variable to set.
         * @param {VariableValueDto} [variableValueDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProcessInstanceVariable(id: string, varName: string, variableValueDto?: VariableValueDto, options?: any): AxiosPromise<void> {
            return localVarFp.setProcessInstanceVariable(id, varName, variableValueDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the serialized value for a binary variable or the binary value for a file variable.
         * @param {string} id The id of the process instance to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {any} [data] The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory.
         * @param {string} [valueType] The name of the variable type. Either Bytes for a byte array variable or File for a file variable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProcessInstanceVariableBinary(id: string, varName: string, data?: any, valueType?: string, options?: any): AxiosPromise<void> {
            return localVarFp.setProcessInstanceVariableBinary(id, varName, data, valueType, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a batch to set retries of jobs associated with given processes asynchronously.
         * @param {SetJobRetriesByProcessDto} [setJobRetriesByProcessDto] Please note that if both processInstances and processInstanceQuery are provided, then the resulting execution will be performed on the union of these sets. **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRetriesByProcess(setJobRetriesByProcessDto?: SetJobRetriesByProcessDto, options?: any): AxiosPromise<BatchDto> {
            return localVarFp.setRetriesByProcess(setJobRetriesByProcessDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a batch to set retries of jobs asynchronously based on a historic process instance query.
         * @param {SetJobRetriesByProcessDto} [setJobRetriesByProcessDto] Please note that if both processInstances and historicProcessInstanceQuery are provided, then the resulting execution will be performed on the union of these sets. **Unallowed property**: &#x60;processInstanceQuery&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRetriesByProcessHistoricQueryBased(setJobRetriesByProcessDto?: SetJobRetriesByProcessDto, options?: any): AxiosPromise<BatchDto> {
            return localVarFp.setRetriesByProcessHistoricQueryBased(setJobRetriesByProcessDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Activates or suspends process instances by providing certain criteria:  # Activate/Suspend Process Instance By Process Definition Id * `suspend` * `processDefinitionId`  # Activate/Suspend Process Instance By Process Definition Key  * `suspend` * `processDefinitionKey` * `processDefinitionTenantId` * `processDefinitionWithoutTenantId`  # Activate/Suspend Process Instance In Group * `suspend` * `processInstanceIds` * `processInstanceQuery` * `historicProcessInstanceQuery`
         * @param {ProcessInstanceSuspensionStateDto} [processInstanceSuspensionStateDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSuspensionState(processInstanceSuspensionStateDto?: ProcessInstanceSuspensionStateDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateSuspensionState(processInstanceSuspensionStateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Activates or suspends process instances asynchronously with a list of process instance ids, a process instance query, and/or a historical process instance query.
         * @param {ProcessInstanceSuspensionStateAsyncDto} [processInstanceSuspensionStateAsyncDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSuspensionStateAsyncOperation(processInstanceSuspensionStateAsyncDto?: ProcessInstanceSuspensionStateAsyncDto, options?: any): AxiosPromise<BatchDto> {
            return localVarFp.updateSuspensionStateAsyncOperation(processInstanceSuspensionStateAsyncDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Activates or suspends a given process instance by id.
         * @param {string} id The id of the process instance to activate or suspend.
         * @param {SuspensionStateDto} [suspensionStateDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSuspensionStateById(id: string, suspensionStateDto?: SuspensionStateDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateSuspensionStateById(id, suspensionStateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProcessInstanceApi - object-oriented interface
 * @export
 * @class ProcessInstanceApi
 * @extends {BaseAPI}
 */
export class ProcessInstanceApi extends BaseAPI {
    /**
     * Deletes a set of process instances asynchronously (batch) based on a historic process instance query.
     * @param {DeleteProcessInstancesDto} [deleteProcessInstancesDto] **Unallowed property**: &#x60;processInstanceQuery&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public deleteAsyncHistoricQueryBased(deleteProcessInstancesDto?: DeleteProcessInstancesDto, options?: AxiosRequestConfig) {
        return ProcessInstanceApiFp(this.configuration).deleteAsyncHistoricQueryBased(deleteProcessInstancesDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a running process instance by id.
     * @param {string} id The id of the process instance to be deleted.
     * @param {boolean} [skipCustomListeners] If set to true, the custom listeners will be skipped.
     * @param {boolean} [skipIoMappings] If set to true, the input/output mappings will be skipped.
     * @param {boolean} [skipSubprocesses] If set to true, subprocesses related to deleted processes will be skipped.
     * @param {boolean} [failIfNotExists] If set to false, the request will still be successful if the process id is not found.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public deleteProcessInstance(id: string, skipCustomListeners?: boolean, skipIoMappings?: boolean, skipSubprocesses?: boolean, failIfNotExists?: boolean, options?: AxiosRequestConfig) {
        return ProcessInstanceApiFp(this.configuration).deleteProcessInstance(id, skipCustomListeners, skipIoMappings, skipSubprocesses, failIfNotExists, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a variable of a process instance by id.
     * @param {string} id The id of the process instance to delete the variable from.
     * @param {string} varName The name of the variable to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public deleteProcessInstanceVariable(id: string, varName: string, options?: AxiosRequestConfig) {
        return ProcessInstanceApiFp(this.configuration).deleteProcessInstanceVariable(id, varName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes multiple process instances asynchronously (batch).
     * @param {DeleteProcessInstancesDto} [deleteProcessInstancesDto] **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public deleteProcessInstancesAsyncOperation(deleteProcessInstancesDto?: DeleteProcessInstancesDto, options?: AxiosRequestConfig) {
        return ProcessInstanceApiFp(this.configuration).deleteProcessInstancesAsyncOperation(deleteProcessInstancesDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves an Activity Instance (Tree) for a given process instance by id.
     * @param {string} id The id of the process instance for which the activity instance should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public getActivityInstanceTree(id: string, options?: AxiosRequestConfig) {
        return ProcessInstanceApiFp(this.configuration).getActivityInstanceTree(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a variable of a given process instance by id.
     * @param {string} id The id of the process instance to retrieve the variable for.
     * @param {string} varName The name of the variable to retrieve.
     * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public getProcessInstanceVariable(id: string, varName: string, deserializeValue?: boolean, options?: AxiosRequestConfig) {
        return ProcessInstanceApiFp(this.configuration).getProcessInstanceVariable(id, varName, deserializeValue, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the content of a Process Variable by the Process Instance id and the Process Variable name. Applicable for byte array or file Process Variables.
     * @param {string} id The id of the process instance to retrieve the variable for.
     * @param {string} varName The name of the variable to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public getProcessInstanceVariableBinary(id: string, varName: string, options?: AxiosRequestConfig) {
        return ProcessInstanceApiFp(this.configuration).getProcessInstanceVariableBinary(id, varName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all variables of a given process instance by id.
     * @param {string} id The id of the process instance to retrieve the variables from.
     * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public getProcessInstanceVariables(id: string, deserializeValue?: boolean, options?: AxiosRequestConfig) {
        return ProcessInstanceApiFp(this.configuration).getProcessInstanceVariables(id, deserializeValue, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Queries for process instances that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of process instances. The size of the result set can be retrieved by using the Get Instance Count method.
     * @param {'instanceId' | 'definitionKey' | 'definitionId' | 'tenantId' | 'businessKey'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {string} [processInstanceIds] Filter by a comma-separated list of process instance ids.
     * @param {string} [businessKey] Filter by process instance business key.
     * @param {string} [businessKeyLike] Filter by process instance business key that the parameter is a substring of.
     * @param {string} [caseInstanceId] Filter by case instance id.
     * @param {string} [processDefinitionId] Filter by the deployment the id belongs to.
     * @param {string} [processDefinitionKey] Filter by the key of the process definition the instances run on.
     * @param {string} [processDefinitionKeyIn] Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys.
     * @param {string} [processDefinitionKeyNotIn] Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys.
     * @param {string} [deploymentId] Filter by the deployment the id belongs to.
     * @param {string} [superProcessInstance] Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id.
     * @param {string} [subProcessInstance] Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id.
     * @param {string} [superCaseInstance] Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.
     * @param {string} [subCaseInstance] Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id.
     * @param {boolean} [active] Only include active process instances. Value may only be true, as false is the default behavior.
     * @param {boolean} [suspended] Only include suspended process instances. Value may only be true, as false is the default behavior.
     * @param {boolean} [withIncident] Filter by presence of incidents. Selects only process instances that have an incident.
     * @param {string} [incidentId] Filter by the incident id.
     * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param {string} [incidentMessage] Filter by the incident message. Exact match.
     * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
     * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids.
     * @param {boolean} [withoutTenantId] Only include process instances which belong to no tenant.
     * @param {boolean} [processDefinitionWithoutTenantId] Only include process instances which process definition has no tenant id.
     * @param {string} [activityIdIn] Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids.
     * @param {boolean} [rootProcessInstances] Restrict the query to all process instances that are top level process instances.
     * @param {boolean} [leafProcessInstances] Restrict the query to all process instances that are leaf instances. (i.e. don\&#39;t have any sub instances).
     * @param {string} [variables] Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal.
     * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public getProcessInstances(sortBy?: 'instanceId' | 'definitionKey' | 'definitionId' | 'tenantId' | 'businessKey', sortOrder?: 'asc' | 'desc', firstResult?: number, maxResults?: number, processInstanceIds?: string, businessKey?: string, businessKeyLike?: string, caseInstanceId?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionKeyNotIn?: string, deploymentId?: string, superProcessInstance?: string, subProcessInstance?: string, superCaseInstance?: string, subCaseInstance?: string, active?: boolean, suspended?: boolean, withIncident?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, processDefinitionWithoutTenantId?: boolean, activityIdIn?: string, rootProcessInstances?: boolean, leafProcessInstances?: boolean, variables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, options?: AxiosRequestConfig) {
        return ProcessInstanceApiFp(this.configuration).getProcessInstances(sortBy, sortOrder, firstResult, maxResults, processInstanceIds, businessKey, businessKeyLike, caseInstanceId, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionKeyNotIn, deploymentId, superProcessInstance, subProcessInstance, superCaseInstance, subCaseInstance, active, suspended, withIncident, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, processDefinitionWithoutTenantId, activityIdIn, rootProcessInstances, leafProcessInstances, variables, variableNamesIgnoreCase, variableValuesIgnoreCase, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Queries for the number of process instances that fulfill given parameters.
     * @param {string} [processInstanceIds] Filter by a comma-separated list of process instance ids.
     * @param {string} [businessKey] Filter by process instance business key.
     * @param {string} [businessKeyLike] Filter by process instance business key that the parameter is a substring of.
     * @param {string} [caseInstanceId] Filter by case instance id.
     * @param {string} [processDefinitionId] Filter by the deployment the id belongs to.
     * @param {string} [processDefinitionKey] Filter by the key of the process definition the instances run on.
     * @param {string} [processDefinitionKeyIn] Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys.
     * @param {string} [processDefinitionKeyNotIn] Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys.
     * @param {string} [deploymentId] Filter by the deployment the id belongs to.
     * @param {string} [superProcessInstance] Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id.
     * @param {string} [subProcessInstance] Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id.
     * @param {string} [superCaseInstance] Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.
     * @param {string} [subCaseInstance] Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id.
     * @param {boolean} [active] Only include active process instances. Value may only be true, as false is the default behavior.
     * @param {boolean} [suspended] Only include suspended process instances. Value may only be true, as false is the default behavior.
     * @param {boolean} [withIncident] Filter by presence of incidents. Selects only process instances that have an incident.
     * @param {string} [incidentId] Filter by the incident id.
     * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param {string} [incidentMessage] Filter by the incident message. Exact match.
     * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
     * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids.
     * @param {boolean} [withoutTenantId] Only include process instances which belong to no tenant.
     * @param {boolean} [processDefinitionWithoutTenantId] Only include process instances which process definition has no tenant id.
     * @param {string} [activityIdIn] Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids.
     * @param {boolean} [rootProcessInstances] Restrict the query to all process instances that are top level process instances.
     * @param {boolean} [leafProcessInstances] Restrict the query to all process instances that are leaf instances. (i.e. don\&#39;t have any sub instances).
     * @param {string} [variables] Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal.
     * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public getProcessInstancesCount(processInstanceIds?: string, businessKey?: string, businessKeyLike?: string, caseInstanceId?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionKeyNotIn?: string, deploymentId?: string, superProcessInstance?: string, subProcessInstance?: string, superCaseInstance?: string, subCaseInstance?: string, active?: boolean, suspended?: boolean, withIncident?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, processDefinitionWithoutTenantId?: boolean, activityIdIn?: string, rootProcessInstances?: boolean, leafProcessInstances?: boolean, variables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, options?: AxiosRequestConfig) {
        return ProcessInstanceApiFp(this.configuration).getProcessInstancesCount(processInstanceIds, businessKey, businessKeyLike, caseInstanceId, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionKeyNotIn, deploymentId, superProcessInstance, subProcessInstance, superCaseInstance, subCaseInstance, active, suspended, withIncident, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, processDefinitionWithoutTenantId, activityIdIn, rootProcessInstances, leafProcessInstances, variables, variableNamesIgnoreCase, variableValuesIgnoreCase, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submits a list of modification instructions to change a process instance\'s execution state. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Canceling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed immediately and in the order they are provided in this request\'s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/develop/user-guide/process-engine/process-instance-modification/).
     * @param {string} id The id of the process instance to modify.
     * @param {ProcessInstanceModificationDto} [processInstanceModificationDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public modifyProcessInstance(id: string, processInstanceModificationDto?: ProcessInstanceModificationDto, options?: AxiosRequestConfig) {
        return ProcessInstanceApiFp(this.configuration).modifyProcessInstance(id, processInstanceModificationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submits a list of modification instructions to change a process instance\'s execution state async. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Cancelling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed asynchronous and in the order they are provided in this request\'s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-modification/).
     * @param {string} id The id of the process instance to modify.
     * @param {ProcessInstanceModificationDto} [processInstanceModificationDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public modifyProcessInstanceAsyncOperation(id: string, processInstanceModificationDto?: ProcessInstanceModificationDto, options?: AxiosRequestConfig) {
        return ProcessInstanceApiFp(this.configuration).modifyProcessInstanceAsyncOperation(id, processInstanceModificationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates or deletes the variables of a process instance by id. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
     * @param {string} id The id of the process instance to set variables for.
     * @param {PatchVariablesDto} [patchVariablesDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public modifyProcessInstanceVariables(id: string, patchVariablesDto?: PatchVariablesDto, options?: AxiosRequestConfig) {
        return ProcessInstanceApiFp(this.configuration).modifyProcessInstanceVariables(id, patchVariablesDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Queries for process instances that fulfill given parameters through a JSON object. This method is slightly more powerful than the Get Instances method because it allows filtering by multiple process variables of types `string`, `number` or `boolean`.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {ProcessInstanceQueryDto} [processInstanceQueryDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public queryProcessInstances(firstResult?: number, maxResults?: number, processInstanceQueryDto?: ProcessInstanceQueryDto, options?: AxiosRequestConfig) {
        return ProcessInstanceApiFp(this.configuration).queryProcessInstances(firstResult, maxResults, processInstanceQueryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Queries for the number of process instances that fulfill the given parameters. This method takes the same message body as the Get Instances (POST) method and therefore it is slightly more powerful than the Get Instance Count method.
     * @param {ProcessInstanceQueryDto} [processInstanceQueryDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public queryProcessInstancesCount(processInstanceQueryDto?: ProcessInstanceQueryDto, options?: AxiosRequestConfig) {
        return ProcessInstanceApiFp(this.configuration).queryProcessInstancesCount(processInstanceQueryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets a variable of a given process instance by id.
     * @param {string} id The id of the process instance to set the variable for.
     * @param {string} varName The name of the variable to set.
     * @param {VariableValueDto} [variableValueDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public setProcessInstanceVariable(id: string, varName: string, variableValueDto?: VariableValueDto, options?: AxiosRequestConfig) {
        return ProcessInstanceApiFp(this.configuration).setProcessInstanceVariable(id, varName, variableValueDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets the serialized value for a binary variable or the binary value for a file variable.
     * @param {string} id The id of the process instance to retrieve the variable for.
     * @param {string} varName The name of the variable to retrieve.
     * @param {any} [data] The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory.
     * @param {string} [valueType] The name of the variable type. Either Bytes for a byte array variable or File for a file variable.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public setProcessInstanceVariableBinary(id: string, varName: string, data?: any, valueType?: string, options?: AxiosRequestConfig) {
        return ProcessInstanceApiFp(this.configuration).setProcessInstanceVariableBinary(id, varName, data, valueType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a batch to set retries of jobs associated with given processes asynchronously.
     * @param {SetJobRetriesByProcessDto} [setJobRetriesByProcessDto] Please note that if both processInstances and processInstanceQuery are provided, then the resulting execution will be performed on the union of these sets. **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public setRetriesByProcess(setJobRetriesByProcessDto?: SetJobRetriesByProcessDto, options?: AxiosRequestConfig) {
        return ProcessInstanceApiFp(this.configuration).setRetriesByProcess(setJobRetriesByProcessDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a batch to set retries of jobs asynchronously based on a historic process instance query.
     * @param {SetJobRetriesByProcessDto} [setJobRetriesByProcessDto] Please note that if both processInstances and historicProcessInstanceQuery are provided, then the resulting execution will be performed on the union of these sets. **Unallowed property**: &#x60;processInstanceQuery&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public setRetriesByProcessHistoricQueryBased(setJobRetriesByProcessDto?: SetJobRetriesByProcessDto, options?: AxiosRequestConfig) {
        return ProcessInstanceApiFp(this.configuration).setRetriesByProcessHistoricQueryBased(setJobRetriesByProcessDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Activates or suspends process instances by providing certain criteria:  # Activate/Suspend Process Instance By Process Definition Id * `suspend` * `processDefinitionId`  # Activate/Suspend Process Instance By Process Definition Key  * `suspend` * `processDefinitionKey` * `processDefinitionTenantId` * `processDefinitionWithoutTenantId`  # Activate/Suspend Process Instance In Group * `suspend` * `processInstanceIds` * `processInstanceQuery` * `historicProcessInstanceQuery`
     * @param {ProcessInstanceSuspensionStateDto} [processInstanceSuspensionStateDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public updateSuspensionState(processInstanceSuspensionStateDto?: ProcessInstanceSuspensionStateDto, options?: AxiosRequestConfig) {
        return ProcessInstanceApiFp(this.configuration).updateSuspensionState(processInstanceSuspensionStateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Activates or suspends process instances asynchronously with a list of process instance ids, a process instance query, and/or a historical process instance query.
     * @param {ProcessInstanceSuspensionStateAsyncDto} [processInstanceSuspensionStateAsyncDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public updateSuspensionStateAsyncOperation(processInstanceSuspensionStateAsyncDto?: ProcessInstanceSuspensionStateAsyncDto, options?: AxiosRequestConfig) {
        return ProcessInstanceApiFp(this.configuration).updateSuspensionStateAsyncOperation(processInstanceSuspensionStateAsyncDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Activates or suspends a given process instance by id.
     * @param {string} id The id of the process instance to activate or suspend.
     * @param {SuspensionStateDto} [suspensionStateDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public updateSuspensionStateById(id: string, suspensionStateDto?: SuspensionStateDto, options?: AxiosRequestConfig) {
        return ProcessInstanceApiFp(this.configuration).updateSuspensionStateById(id, suspensionStateDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SchemaLogApi - axios parameter creator
 * @export
 */
export const SchemaLogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Queries for schema log entries that fulfill given parameters.
         * @param {string} [version] Only return schema log entries with a specific version.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchemaLog: async (version?: string, firstResult?: number, maxResults?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/schema/log`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for schema log entries that fulfill given parameters.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {SchemaLogQueryDto} [schemaLogQueryDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querySchemaLog: async (firstResult?: number, maxResults?: number, schemaLogQueryDto?: SchemaLogQueryDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/schema/log`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(schemaLogQueryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchemaLogApi - functional programming interface
 * @export
 */
export const SchemaLogApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchemaLogApiAxiosParamCreator(configuration)
    return {
        /**
         * Queries for schema log entries that fulfill given parameters.
         * @param {string} [version] Only return schema log entries with a specific version.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchemaLog(version?: string, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SchemaLogEntryDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchemaLog(version, firstResult, maxResults, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Queries for schema log entries that fulfill given parameters.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {SchemaLogQueryDto} [schemaLogQueryDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async querySchemaLog(firstResult?: number, maxResults?: number, schemaLogQueryDto?: SchemaLogQueryDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SchemaLogEntryDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.querySchemaLog(firstResult, maxResults, schemaLogQueryDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SchemaLogApi - factory interface
 * @export
 */
export const SchemaLogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchemaLogApiFp(configuration)
    return {
        /**
         * Queries for schema log entries that fulfill given parameters.
         * @param {string} [version] Only return schema log entries with a specific version.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchemaLog(version?: string, firstResult?: number, maxResults?: number, options?: any): AxiosPromise<Array<SchemaLogEntryDto>> {
            return localVarFp.getSchemaLog(version, firstResult, maxResults, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for schema log entries that fulfill given parameters.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {SchemaLogQueryDto} [schemaLogQueryDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querySchemaLog(firstResult?: number, maxResults?: number, schemaLogQueryDto?: SchemaLogQueryDto, options?: any): AxiosPromise<Array<SchemaLogEntryDto>> {
            return localVarFp.querySchemaLog(firstResult, maxResults, schemaLogQueryDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchemaLogApi - object-oriented interface
 * @export
 * @class SchemaLogApi
 * @extends {BaseAPI}
 */
export class SchemaLogApi extends BaseAPI {
    /**
     * Queries for schema log entries that fulfill given parameters.
     * @param {string} [version] Only return schema log entries with a specific version.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaLogApi
     */
    public getSchemaLog(version?: string, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig) {
        return SchemaLogApiFp(this.configuration).getSchemaLog(version, firstResult, maxResults, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Queries for schema log entries that fulfill given parameters.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {SchemaLogQueryDto} [schemaLogQueryDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaLogApi
     */
    public querySchemaLog(firstResult?: number, maxResults?: number, schemaLogQueryDto?: SchemaLogQueryDto, options?: AxiosRequestConfig) {
        return SchemaLogApiFp(this.configuration).querySchemaLog(firstResult, maxResults, schemaLogQueryDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SignalApi - axios parameter creator
 * @export
 */
export const SignalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A signal is an event of global scope (broadcast semantics) and is delivered to all active handlers. Internally this maps to the engine\'s signal event received builder method `RuntimeService#createSignalEvent()`. For more information about the signal behavior, see the [Signal Events](https://docs.camunda.org/manual/7.13/reference/bpmn20/events/signal-events/) section of the [BPMN 2.0 Implementation Reference](https://docs.camunda.org/manual/7.13/reference/bpmn20/).
         * @param {SignalDto} [signalDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        throwSignal: async (signalDto?: SignalDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/signal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signalDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SignalApi - functional programming interface
 * @export
 */
export const SignalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SignalApiAxiosParamCreator(configuration)
    return {
        /**
         * A signal is an event of global scope (broadcast semantics) and is delivered to all active handlers. Internally this maps to the engine\'s signal event received builder method `RuntimeService#createSignalEvent()`. For more information about the signal behavior, see the [Signal Events](https://docs.camunda.org/manual/7.13/reference/bpmn20/events/signal-events/) section of the [BPMN 2.0 Implementation Reference](https://docs.camunda.org/manual/7.13/reference/bpmn20/).
         * @param {SignalDto} [signalDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async throwSignal(signalDto?: SignalDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.throwSignal(signalDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SignalApi - factory interface
 * @export
 */
export const SignalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SignalApiFp(configuration)
    return {
        /**
         * A signal is an event of global scope (broadcast semantics) and is delivered to all active handlers. Internally this maps to the engine\'s signal event received builder method `RuntimeService#createSignalEvent()`. For more information about the signal behavior, see the [Signal Events](https://docs.camunda.org/manual/7.13/reference/bpmn20/events/signal-events/) section of the [BPMN 2.0 Implementation Reference](https://docs.camunda.org/manual/7.13/reference/bpmn20/).
         * @param {SignalDto} [signalDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        throwSignal(signalDto?: SignalDto, options?: any): AxiosPromise<void> {
            return localVarFp.throwSignal(signalDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SignalApi - object-oriented interface
 * @export
 * @class SignalApi
 * @extends {BaseAPI}
 */
export class SignalApi extends BaseAPI {
    /**
     * A signal is an event of global scope (broadcast semantics) and is delivered to all active handlers. Internally this maps to the engine\'s signal event received builder method `RuntimeService#createSignalEvent()`. For more information about the signal behavior, see the [Signal Events](https://docs.camunda.org/manual/7.13/reference/bpmn20/events/signal-events/) section of the [BPMN 2.0 Implementation Reference](https://docs.camunda.org/manual/7.13/reference/bpmn20/).
     * @param {SignalDto} [signalDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignalApi
     */
    public throwSignal(signalDto?: SignalDto, options?: AxiosRequestConfig) {
        return SignalApiFp(this.configuration).throwSignal(signalDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TaskApi - axios parameter creator
 * @export
 */
export const TaskApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Claims a task for a specific user.  **Note:** The difference with the [Set Assignee](https://docs.camunda.org/manual/7.13/reference/rest/task/post-assignee/) method is that here a check is performed to see if the task already has a user assigned to it.
         * @param {string} id The id of the task to claim.
         * @param {UserIdDto} [userIdDto] Provide the id of the user that claims the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claim: async (id: string, userIdDto?: UserIdDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('claim', 'id', id)
            const localVarPath = `/task/{id}/claim`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userIdDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Completes a task and updates process variables.
         * @param {string} id The id of the task to complete.
         * @param {CompleteTaskDto} [completeTaskDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        complete: async (id: string, completeTaskDto?: CompleteTaskDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('complete', 'id', id)
            const localVarPath = `/task/{id}/complete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(completeTaskDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new task.
         * @param {TaskDto} [taskDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTask: async (taskDto?: TaskDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/task/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taskDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delegates a task to another user.
         * @param {string} id The id of the task to delegate.
         * @param {UserIdDto} [userIdDto] Provide the id of the user that the task should be delegated to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegateTask: async (id: string, userIdDto?: UserIdDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('delegateTask', 'id', id)
            const localVarPath = `/task/{id}/delegate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userIdDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a task by id.
         * @param {string} id The id of the task to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTask: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTask', 'id', id)
            const localVarPath = `/task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the deployed form that is referenced from a given task. For further information please refer to the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
         * @param {string} id The id of the task to get the deployed form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedForm: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDeployedForm', 'id', id)
            const localVarPath = `/task/{id}/deployed-form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the form key for a task. The form key corresponds to the `FormData#formKey` property in the engine. This key can be used to do task-specific form rendering in client applications. Additionally, the context path of the containing process application is returned.
         * @param {string} id The id of the task to retrieve the form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForm: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getForm', 'id', id)
            const localVarPath = `/task/{id}/form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the form variables for a task. The form variables take form data specified on the task into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @param {string} id The id of the task to retrieve the variables for.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFormVariables: async (id: string, variableNames?: string, deserializeValues?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFormVariables', 'id', id)
            const localVarPath = `/task/{id}/form-variables`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (variableNames !== undefined) {
                localVarQueryParameter['variableNames'] = variableNames;
            }

            if (deserializeValues !== undefined) {
                localVarQueryParameter['deserializeValues'] = deserializeValues;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the rendered form for a task. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @param {string} id The id of the task to get the rendered form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRenderedForm: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRenderedForm', 'id', id)
            const localVarPath = `/task/{id}/rendered-form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a task by id.
         * @param {string} id The id of the task to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTask', 'id', id)
            const localVarPath = `/task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for tasks that fulfill a given filter. The size of the result set can be retrieved by using the Get Task Count method.  **Security Consideration:** There are several query parameters (such as assigneeExpression) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) for custom code in the user guide for details.
         * @param {string} [processInstanceId] Restrict to tasks that belong to process instances with the given id.
         * @param {string} [processInstanceIdIn] Restrict to tasks that belong to process instances with the given ids.
         * @param {string} [processInstanceBusinessKey] Restrict to tasks that belong to process instances with the given business key.
         * @param {string} [processInstanceBusinessKeyExpression] Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {string} [processInstanceBusinessKeyIn] Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
         * @param {string} [processInstanceBusinessKeyLike] Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
         * @param {string} [processInstanceBusinessKeyLikeExpression] Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [processDefinitionId] Restrict to tasks that belong to a process definition with the given id.
         * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
         * @param {string} [processDefinitionKeyIn] Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
         * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
         * @param {string} [processDefinitionNameLike] Restrict to tasks that have a process definition name that has the parameter value as  a substring.
         * @param {string} [executionId] Restrict to tasks that belong to an execution with the given id.
         * @param {string} [caseInstanceId] Restrict to tasks that belong to case instances with the given id.
         * @param {string} [caseInstanceBusinessKey] Restrict to tasks that belong to case instances with the given business key.
         * @param {string} [caseInstanceBusinessKeyLike] Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
         * @param {string} [caseDefinitionId] Restrict to tasks that belong to a case definition with the given id.
         * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
         * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
         * @param {string} [caseDefinitionNameLike] Restrict to tasks that have a case definition name that has the parameter value as a  substring.
         * @param {string} [caseExecutionId] Restrict to tasks that belong to a case execution with the given id.
         * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
         * @param {string} [tenantIdIn] Only include tasks which belong to one of the passed and comma-separated  tenant ids.
         * @param {boolean} [withoutTenantId] Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
         * @param {string} [assignee] Restrict to tasks that the given user is assigned to.
         * @param {string} [assigneeExpression] Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeLike] Restrict to tasks that have an assignee that has the parameter  value as a substring.
         * @param {string} [assigneeLikeExpression] Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeIn] Only include tasks which are assigned to one of the passed and  comma-separated user ids.
         * @param {string} [owner] Restrict to tasks that the given user owns.
         * @param {string} [ownerExpression] Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateGroup] Only include tasks that are offered to the given group.
         * @param {string} [candidateGroupExpression] Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateUser] Only include tasks that are offered to the given user or to one of his groups.
         * @param {string} [candidateUserExpression] Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {boolean} [includeAssignedTasks] Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
         * @param {string} [involvedUser] Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
         * @param {string} [involvedUserExpression] Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
         * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
         * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
         * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
         * @param {string} [taskDefinitionKeyLike] Restrict to tasks that have a key that has the parameter value as a substring.
         * @param {string} [name] Restrict to tasks that have the given name.
         * @param {string} [nameNotEqual] Restrict to tasks that do not have the given name.
         * @param {string} [nameLike] Restrict to tasks that have a name with the given parameter value as substring.
         * @param {string} [nameNotLike] Restrict to tasks that do not have a name with the given parameter value as substring.
         * @param {string} [description] Restrict to tasks that have the given description.
         * @param {string} [descriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
         * @param {number} [priority] Restrict to tasks that have the given priority.
         * @param {number} [maxPriority] Restrict to tasks that have a lower or equal priority.
         * @param {number} [minPriority] Restrict to tasks that have a higher or equal priority.
         * @param {string} [dueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [dueDateExpression] Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
         * @param {string} [dueAfterExpression] Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
         * @param {string} [dueBeforeExpression] Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [followUpDateExpression] Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
         * @param {string} [followUpAfterExpression] Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
         * @param {string} [followUpBeforeExpression] Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBeforeOrNotExistent] Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
         * @param {string} [followUpBeforeOrNotExistentExpression] Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdOn] Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
         * @param {string} [createdOnExpression] Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdAfter] Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [createdAfterExpression] Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdBefore] Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
         * @param {string} [createdBeforeExpression] Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {'PENDING' | 'RESOLVED'} [delegationState] Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
         * @param {string} [candidateGroups] Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
         * @param {string} [candidateGroupsExpression] Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
         * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withCandidateUsers] Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateUsers] Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [caseInstanceVariables] Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
         * @param {string} [parentTaskId] Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
         * @param {'instanceId' | 'caseInstanceId' | 'dueDate' | 'executionId' | 'caseExecutionId' | 'assignee' | 'created' | 'description' | 'id' | 'name' | 'nameCaseInsensitive' | 'priority' | 'processVariable' | 'executionVariable' | 'taskVariable' | 'caseExecutionVariable' | 'caseInstanceVariable'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks: async (processInstanceId?: string, processInstanceIdIn?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyExpression?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, processInstanceBusinessKeyLikeExpression?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionName?: string, processDefinitionNameLike?: string, executionId?: string, caseInstanceId?: string, caseInstanceBusinessKey?: string, caseInstanceBusinessKeyLike?: string, caseDefinitionId?: string, caseDefinitionKey?: string, caseDefinitionName?: string, caseDefinitionNameLike?: string, caseExecutionId?: string, activityInstanceIdIn?: string, tenantIdIn?: string, withoutTenantId?: boolean, assignee?: string, assigneeExpression?: string, assigneeLike?: string, assigneeLikeExpression?: string, assigneeIn?: string, owner?: string, ownerExpression?: string, candidateGroup?: string, candidateGroupExpression?: string, candidateUser?: string, candidateUserExpression?: string, includeAssignedTasks?: boolean, involvedUser?: string, involvedUserExpression?: string, assigned?: boolean, unassigned?: boolean, taskDefinitionKey?: string, taskDefinitionKeyIn?: string, taskDefinitionKeyLike?: string, name?: string, nameNotEqual?: string, nameLike?: string, nameNotLike?: string, description?: string, descriptionLike?: string, priority?: number, maxPriority?: number, minPriority?: number, dueDate?: string, dueDateExpression?: string, dueAfter?: string, dueAfterExpression?: string, dueBefore?: string, dueBeforeExpression?: string, followUpDate?: string, followUpDateExpression?: string, followUpAfter?: string, followUpAfterExpression?: string, followUpBefore?: string, followUpBeforeExpression?: string, followUpBeforeOrNotExistent?: string, followUpBeforeOrNotExistentExpression?: string, createdOn?: string, createdOnExpression?: string, createdAfter?: string, createdAfterExpression?: string, createdBefore?: string, createdBeforeExpression?: string, delegationState?: 'PENDING' | 'RESOLVED', candidateGroups?: string, candidateGroupsExpression?: string, withCandidateGroups?: boolean, withoutCandidateGroups?: boolean, withCandidateUsers?: boolean, withoutCandidateUsers?: boolean, active?: boolean, suspended?: boolean, taskVariables?: string, processVariables?: string, caseInstanceVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, parentTaskId?: string, sortBy?: 'instanceId' | 'caseInstanceId' | 'dueDate' | 'executionId' | 'caseExecutionId' | 'assignee' | 'created' | 'description' | 'id' | 'name' | 'nameCaseInsensitive' | 'priority' | 'processVariable' | 'executionVariable' | 'taskVariable' | 'caseExecutionVariable' | 'caseInstanceVariable', sortOrder?: 'asc' | 'desc', firstResult?: number, maxResults?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/task`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (processInstanceId !== undefined) {
                localVarQueryParameter['processInstanceId'] = processInstanceId;
            }

            if (processInstanceIdIn !== undefined) {
                localVarQueryParameter['processInstanceIdIn'] = processInstanceIdIn;
            }

            if (processInstanceBusinessKey !== undefined) {
                localVarQueryParameter['processInstanceBusinessKey'] = processInstanceBusinessKey;
            }

            if (processInstanceBusinessKeyExpression !== undefined) {
                localVarQueryParameter['processInstanceBusinessKeyExpression'] = processInstanceBusinessKeyExpression;
            }

            if (processInstanceBusinessKeyIn !== undefined) {
                localVarQueryParameter['processInstanceBusinessKeyIn'] = processInstanceBusinessKeyIn;
            }

            if (processInstanceBusinessKeyLike !== undefined) {
                localVarQueryParameter['processInstanceBusinessKeyLike'] = processInstanceBusinessKeyLike;
            }

            if (processInstanceBusinessKeyLikeExpression !== undefined) {
                localVarQueryParameter['processInstanceBusinessKeyLikeExpression'] = processInstanceBusinessKeyLikeExpression;
            }

            if (processDefinitionId !== undefined) {
                localVarQueryParameter['processDefinitionId'] = processDefinitionId;
            }

            if (processDefinitionKey !== undefined) {
                localVarQueryParameter['processDefinitionKey'] = processDefinitionKey;
            }

            if (processDefinitionKeyIn !== undefined) {
                localVarQueryParameter['processDefinitionKeyIn'] = processDefinitionKeyIn;
            }

            if (processDefinitionName !== undefined) {
                localVarQueryParameter['processDefinitionName'] = processDefinitionName;
            }

            if (processDefinitionNameLike !== undefined) {
                localVarQueryParameter['processDefinitionNameLike'] = processDefinitionNameLike;
            }

            if (executionId !== undefined) {
                localVarQueryParameter['executionId'] = executionId;
            }

            if (caseInstanceId !== undefined) {
                localVarQueryParameter['caseInstanceId'] = caseInstanceId;
            }

            if (caseInstanceBusinessKey !== undefined) {
                localVarQueryParameter['caseInstanceBusinessKey'] = caseInstanceBusinessKey;
            }

            if (caseInstanceBusinessKeyLike !== undefined) {
                localVarQueryParameter['caseInstanceBusinessKeyLike'] = caseInstanceBusinessKeyLike;
            }

            if (caseDefinitionId !== undefined) {
                localVarQueryParameter['caseDefinitionId'] = caseDefinitionId;
            }

            if (caseDefinitionKey !== undefined) {
                localVarQueryParameter['caseDefinitionKey'] = caseDefinitionKey;
            }

            if (caseDefinitionName !== undefined) {
                localVarQueryParameter['caseDefinitionName'] = caseDefinitionName;
            }

            if (caseDefinitionNameLike !== undefined) {
                localVarQueryParameter['caseDefinitionNameLike'] = caseDefinitionNameLike;
            }

            if (caseExecutionId !== undefined) {
                localVarQueryParameter['caseExecutionId'] = caseExecutionId;
            }

            if (activityInstanceIdIn !== undefined) {
                localVarQueryParameter['activityInstanceIdIn'] = activityInstanceIdIn;
            }

            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }

            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }

            if (assignee !== undefined) {
                localVarQueryParameter['assignee'] = assignee;
            }

            if (assigneeExpression !== undefined) {
                localVarQueryParameter['assigneeExpression'] = assigneeExpression;
            }

            if (assigneeLike !== undefined) {
                localVarQueryParameter['assigneeLike'] = assigneeLike;
            }

            if (assigneeLikeExpression !== undefined) {
                localVarQueryParameter['assigneeLikeExpression'] = assigneeLikeExpression;
            }

            if (assigneeIn !== undefined) {
                localVarQueryParameter['assigneeIn'] = assigneeIn;
            }

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }

            if (ownerExpression !== undefined) {
                localVarQueryParameter['ownerExpression'] = ownerExpression;
            }

            if (candidateGroup !== undefined) {
                localVarQueryParameter['candidateGroup'] = candidateGroup;
            }

            if (candidateGroupExpression !== undefined) {
                localVarQueryParameter['candidateGroupExpression'] = candidateGroupExpression;
            }

            if (candidateUser !== undefined) {
                localVarQueryParameter['candidateUser'] = candidateUser;
            }

            if (candidateUserExpression !== undefined) {
                localVarQueryParameter['candidateUserExpression'] = candidateUserExpression;
            }

            if (includeAssignedTasks !== undefined) {
                localVarQueryParameter['includeAssignedTasks'] = includeAssignedTasks;
            }

            if (involvedUser !== undefined) {
                localVarQueryParameter['involvedUser'] = involvedUser;
            }

            if (involvedUserExpression !== undefined) {
                localVarQueryParameter['involvedUserExpression'] = involvedUserExpression;
            }

            if (assigned !== undefined) {
                localVarQueryParameter['assigned'] = assigned;
            }

            if (unassigned !== undefined) {
                localVarQueryParameter['unassigned'] = unassigned;
            }

            if (taskDefinitionKey !== undefined) {
                localVarQueryParameter['taskDefinitionKey'] = taskDefinitionKey;
            }

            if (taskDefinitionKeyIn !== undefined) {
                localVarQueryParameter['taskDefinitionKeyIn'] = taskDefinitionKeyIn;
            }

            if (taskDefinitionKeyLike !== undefined) {
                localVarQueryParameter['taskDefinitionKeyLike'] = taskDefinitionKeyLike;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameNotEqual !== undefined) {
                localVarQueryParameter['nameNotEqual'] = nameNotEqual;
            }

            if (nameLike !== undefined) {
                localVarQueryParameter['nameLike'] = nameLike;
            }

            if (nameNotLike !== undefined) {
                localVarQueryParameter['nameNotLike'] = nameNotLike;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (descriptionLike !== undefined) {
                localVarQueryParameter['descriptionLike'] = descriptionLike;
            }

            if (priority !== undefined) {
                localVarQueryParameter['priority'] = priority;
            }

            if (maxPriority !== undefined) {
                localVarQueryParameter['maxPriority'] = maxPriority;
            }

            if (minPriority !== undefined) {
                localVarQueryParameter['minPriority'] = minPriority;
            }

            if (dueDate !== undefined) {
                localVarQueryParameter['dueDate'] = dueDate;
            }

            if (dueDateExpression !== undefined) {
                localVarQueryParameter['dueDateExpression'] = dueDateExpression;
            }

            if (dueAfter !== undefined) {
                localVarQueryParameter['dueAfter'] = dueAfter;
            }

            if (dueAfterExpression !== undefined) {
                localVarQueryParameter['dueAfterExpression'] = dueAfterExpression;
            }

            if (dueBefore !== undefined) {
                localVarQueryParameter['dueBefore'] = dueBefore;
            }

            if (dueBeforeExpression !== undefined) {
                localVarQueryParameter['dueBeforeExpression'] = dueBeforeExpression;
            }

            if (followUpDate !== undefined) {
                localVarQueryParameter['followUpDate'] = followUpDate;
            }

            if (followUpDateExpression !== undefined) {
                localVarQueryParameter['followUpDateExpression'] = followUpDateExpression;
            }

            if (followUpAfter !== undefined) {
                localVarQueryParameter['followUpAfter'] = followUpAfter;
            }

            if (followUpAfterExpression !== undefined) {
                localVarQueryParameter['followUpAfterExpression'] = followUpAfterExpression;
            }

            if (followUpBefore !== undefined) {
                localVarQueryParameter['followUpBefore'] = followUpBefore;
            }

            if (followUpBeforeExpression !== undefined) {
                localVarQueryParameter['followUpBeforeExpression'] = followUpBeforeExpression;
            }

            if (followUpBeforeOrNotExistent !== undefined) {
                localVarQueryParameter['followUpBeforeOrNotExistent'] = followUpBeforeOrNotExistent;
            }

            if (followUpBeforeOrNotExistentExpression !== undefined) {
                localVarQueryParameter['followUpBeforeOrNotExistentExpression'] = followUpBeforeOrNotExistentExpression;
            }

            if (createdOn !== undefined) {
                localVarQueryParameter['createdOn'] = createdOn;
            }

            if (createdOnExpression !== undefined) {
                localVarQueryParameter['createdOnExpression'] = createdOnExpression;
            }

            if (createdAfter !== undefined) {
                localVarQueryParameter['createdAfter'] = createdAfter;
            }

            if (createdAfterExpression !== undefined) {
                localVarQueryParameter['createdAfterExpression'] = createdAfterExpression;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['createdBefore'] = createdBefore;
            }

            if (createdBeforeExpression !== undefined) {
                localVarQueryParameter['createdBeforeExpression'] = createdBeforeExpression;
            }

            if (delegationState !== undefined) {
                localVarQueryParameter['delegationState'] = delegationState;
            }

            if (candidateGroups !== undefined) {
                localVarQueryParameter['candidateGroups'] = candidateGroups;
            }

            if (candidateGroupsExpression !== undefined) {
                localVarQueryParameter['candidateGroupsExpression'] = candidateGroupsExpression;
            }

            if (withCandidateGroups !== undefined) {
                localVarQueryParameter['withCandidateGroups'] = withCandidateGroups;
            }

            if (withoutCandidateGroups !== undefined) {
                localVarQueryParameter['withoutCandidateGroups'] = withoutCandidateGroups;
            }

            if (withCandidateUsers !== undefined) {
                localVarQueryParameter['withCandidateUsers'] = withCandidateUsers;
            }

            if (withoutCandidateUsers !== undefined) {
                localVarQueryParameter['withoutCandidateUsers'] = withoutCandidateUsers;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (suspended !== undefined) {
                localVarQueryParameter['suspended'] = suspended;
            }

            if (taskVariables !== undefined) {
                localVarQueryParameter['taskVariables'] = taskVariables;
            }

            if (processVariables !== undefined) {
                localVarQueryParameter['processVariables'] = processVariables;
            }

            if (caseInstanceVariables !== undefined) {
                localVarQueryParameter['caseInstanceVariables'] = caseInstanceVariables;
            }

            if (variableNamesIgnoreCase !== undefined) {
                localVarQueryParameter['variableNamesIgnoreCase'] = variableNamesIgnoreCase;
            }

            if (variableValuesIgnoreCase !== undefined) {
                localVarQueryParameter['variableValuesIgnoreCase'] = variableValuesIgnoreCase;
            }

            if (parentTaskId !== undefined) {
                localVarQueryParameter['parentTaskId'] = parentTaskId;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the number of tasks that fulfill a provided filter. Corresponds to the size of the result set when using the [Get Tasks](https://docs.camunda.org/manual/7.13/reference/rest/task/) method.  **Security Consideration:** There are several query parameters (such as assigneeExpression) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) for custom code in the user guide for details.
         * @param {string} [processInstanceId] Restrict to tasks that belong to process instances with the given id.
         * @param {string} [processInstanceIdIn] Restrict to tasks that belong to process instances with the given ids.
         * @param {string} [processInstanceBusinessKey] Restrict to tasks that belong to process instances with the given business key.
         * @param {string} [processInstanceBusinessKeyExpression] Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {string} [processInstanceBusinessKeyIn] Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
         * @param {string} [processInstanceBusinessKeyLike] Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
         * @param {string} [processInstanceBusinessKeyLikeExpression] Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [processDefinitionId] Restrict to tasks that belong to a process definition with the given id.
         * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
         * @param {string} [processDefinitionKeyIn] Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
         * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
         * @param {string} [processDefinitionNameLike] Restrict to tasks that have a process definition name that has the parameter value as  a substring.
         * @param {string} [executionId] Restrict to tasks that belong to an execution with the given id.
         * @param {string} [caseInstanceId] Restrict to tasks that belong to case instances with the given id.
         * @param {string} [caseInstanceBusinessKey] Restrict to tasks that belong to case instances with the given business key.
         * @param {string} [caseInstanceBusinessKeyLike] Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
         * @param {string} [caseDefinitionId] Restrict to tasks that belong to a case definition with the given id.
         * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
         * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
         * @param {string} [caseDefinitionNameLike] Restrict to tasks that have a case definition name that has the parameter value as a  substring.
         * @param {string} [caseExecutionId] Restrict to tasks that belong to a case execution with the given id.
         * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
         * @param {string} [tenantIdIn] Only include tasks which belong to one of the passed and comma-separated  tenant ids.
         * @param {boolean} [withoutTenantId] Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
         * @param {string} [assignee] Restrict to tasks that the given user is assigned to.
         * @param {string} [assigneeExpression] Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeLike] Restrict to tasks that have an assignee that has the parameter  value as a substring.
         * @param {string} [assigneeLikeExpression] Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeIn] Only include tasks which are assigned to one of the passed and  comma-separated user ids.
         * @param {string} [owner] Restrict to tasks that the given user owns.
         * @param {string} [ownerExpression] Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateGroup] Only include tasks that are offered to the given group.
         * @param {string} [candidateGroupExpression] Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateUser] Only include tasks that are offered to the given user or to one of his groups.
         * @param {string} [candidateUserExpression] Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {boolean} [includeAssignedTasks] Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
         * @param {string} [involvedUser] Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
         * @param {string} [involvedUserExpression] Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
         * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
         * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
         * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
         * @param {string} [taskDefinitionKeyLike] Restrict to tasks that have a key that has the parameter value as a substring.
         * @param {string} [name] Restrict to tasks that have the given name.
         * @param {string} [nameNotEqual] Restrict to tasks that do not have the given name.
         * @param {string} [nameLike] Restrict to tasks that have a name with the given parameter value as substring.
         * @param {string} [nameNotLike] Restrict to tasks that do not have a name with the given parameter value as substring.
         * @param {string} [description] Restrict to tasks that have the given description.
         * @param {string} [descriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
         * @param {number} [priority] Restrict to tasks that have the given priority.
         * @param {number} [maxPriority] Restrict to tasks that have a lower or equal priority.
         * @param {number} [minPriority] Restrict to tasks that have a higher or equal priority.
         * @param {string} [dueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [dueDateExpression] Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
         * @param {string} [dueAfterExpression] Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
         * @param {string} [dueBeforeExpression] Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [followUpDateExpression] Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
         * @param {string} [followUpAfterExpression] Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
         * @param {string} [followUpBeforeExpression] Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBeforeOrNotExistent] Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
         * @param {string} [followUpBeforeOrNotExistentExpression] Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdOn] Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
         * @param {string} [createdOnExpression] Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdAfter] Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [createdAfterExpression] Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdBefore] Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
         * @param {string} [createdBeforeExpression] Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {'PENDING' | 'RESOLVED'} [delegationState] Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
         * @param {string} [candidateGroups] Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
         * @param {string} [candidateGroupsExpression] Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
         * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withCandidateUsers] Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateUsers] Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [caseInstanceVariables] Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
         * @param {string} [parentTaskId] Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksCount: async (processInstanceId?: string, processInstanceIdIn?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyExpression?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, processInstanceBusinessKeyLikeExpression?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionName?: string, processDefinitionNameLike?: string, executionId?: string, caseInstanceId?: string, caseInstanceBusinessKey?: string, caseInstanceBusinessKeyLike?: string, caseDefinitionId?: string, caseDefinitionKey?: string, caseDefinitionName?: string, caseDefinitionNameLike?: string, caseExecutionId?: string, activityInstanceIdIn?: string, tenantIdIn?: string, withoutTenantId?: boolean, assignee?: string, assigneeExpression?: string, assigneeLike?: string, assigneeLikeExpression?: string, assigneeIn?: string, owner?: string, ownerExpression?: string, candidateGroup?: string, candidateGroupExpression?: string, candidateUser?: string, candidateUserExpression?: string, includeAssignedTasks?: boolean, involvedUser?: string, involvedUserExpression?: string, assigned?: boolean, unassigned?: boolean, taskDefinitionKey?: string, taskDefinitionKeyIn?: string, taskDefinitionKeyLike?: string, name?: string, nameNotEqual?: string, nameLike?: string, nameNotLike?: string, description?: string, descriptionLike?: string, priority?: number, maxPriority?: number, minPriority?: number, dueDate?: string, dueDateExpression?: string, dueAfter?: string, dueAfterExpression?: string, dueBefore?: string, dueBeforeExpression?: string, followUpDate?: string, followUpDateExpression?: string, followUpAfter?: string, followUpAfterExpression?: string, followUpBefore?: string, followUpBeforeExpression?: string, followUpBeforeOrNotExistent?: string, followUpBeforeOrNotExistentExpression?: string, createdOn?: string, createdOnExpression?: string, createdAfter?: string, createdAfterExpression?: string, createdBefore?: string, createdBeforeExpression?: string, delegationState?: 'PENDING' | 'RESOLVED', candidateGroups?: string, candidateGroupsExpression?: string, withCandidateGroups?: boolean, withoutCandidateGroups?: boolean, withCandidateUsers?: boolean, withoutCandidateUsers?: boolean, active?: boolean, suspended?: boolean, taskVariables?: string, processVariables?: string, caseInstanceVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, parentTaskId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/task/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (processInstanceId !== undefined) {
                localVarQueryParameter['processInstanceId'] = processInstanceId;
            }

            if (processInstanceIdIn !== undefined) {
                localVarQueryParameter['processInstanceIdIn'] = processInstanceIdIn;
            }

            if (processInstanceBusinessKey !== undefined) {
                localVarQueryParameter['processInstanceBusinessKey'] = processInstanceBusinessKey;
            }

            if (processInstanceBusinessKeyExpression !== undefined) {
                localVarQueryParameter['processInstanceBusinessKeyExpression'] = processInstanceBusinessKeyExpression;
            }

            if (processInstanceBusinessKeyIn !== undefined) {
                localVarQueryParameter['processInstanceBusinessKeyIn'] = processInstanceBusinessKeyIn;
            }

            if (processInstanceBusinessKeyLike !== undefined) {
                localVarQueryParameter['processInstanceBusinessKeyLike'] = processInstanceBusinessKeyLike;
            }

            if (processInstanceBusinessKeyLikeExpression !== undefined) {
                localVarQueryParameter['processInstanceBusinessKeyLikeExpression'] = processInstanceBusinessKeyLikeExpression;
            }

            if (processDefinitionId !== undefined) {
                localVarQueryParameter['processDefinitionId'] = processDefinitionId;
            }

            if (processDefinitionKey !== undefined) {
                localVarQueryParameter['processDefinitionKey'] = processDefinitionKey;
            }

            if (processDefinitionKeyIn !== undefined) {
                localVarQueryParameter['processDefinitionKeyIn'] = processDefinitionKeyIn;
            }

            if (processDefinitionName !== undefined) {
                localVarQueryParameter['processDefinitionName'] = processDefinitionName;
            }

            if (processDefinitionNameLike !== undefined) {
                localVarQueryParameter['processDefinitionNameLike'] = processDefinitionNameLike;
            }

            if (executionId !== undefined) {
                localVarQueryParameter['executionId'] = executionId;
            }

            if (caseInstanceId !== undefined) {
                localVarQueryParameter['caseInstanceId'] = caseInstanceId;
            }

            if (caseInstanceBusinessKey !== undefined) {
                localVarQueryParameter['caseInstanceBusinessKey'] = caseInstanceBusinessKey;
            }

            if (caseInstanceBusinessKeyLike !== undefined) {
                localVarQueryParameter['caseInstanceBusinessKeyLike'] = caseInstanceBusinessKeyLike;
            }

            if (caseDefinitionId !== undefined) {
                localVarQueryParameter['caseDefinitionId'] = caseDefinitionId;
            }

            if (caseDefinitionKey !== undefined) {
                localVarQueryParameter['caseDefinitionKey'] = caseDefinitionKey;
            }

            if (caseDefinitionName !== undefined) {
                localVarQueryParameter['caseDefinitionName'] = caseDefinitionName;
            }

            if (caseDefinitionNameLike !== undefined) {
                localVarQueryParameter['caseDefinitionNameLike'] = caseDefinitionNameLike;
            }

            if (caseExecutionId !== undefined) {
                localVarQueryParameter['caseExecutionId'] = caseExecutionId;
            }

            if (activityInstanceIdIn !== undefined) {
                localVarQueryParameter['activityInstanceIdIn'] = activityInstanceIdIn;
            }

            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }

            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }

            if (assignee !== undefined) {
                localVarQueryParameter['assignee'] = assignee;
            }

            if (assigneeExpression !== undefined) {
                localVarQueryParameter['assigneeExpression'] = assigneeExpression;
            }

            if (assigneeLike !== undefined) {
                localVarQueryParameter['assigneeLike'] = assigneeLike;
            }

            if (assigneeLikeExpression !== undefined) {
                localVarQueryParameter['assigneeLikeExpression'] = assigneeLikeExpression;
            }

            if (assigneeIn !== undefined) {
                localVarQueryParameter['assigneeIn'] = assigneeIn;
            }

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }

            if (ownerExpression !== undefined) {
                localVarQueryParameter['ownerExpression'] = ownerExpression;
            }

            if (candidateGroup !== undefined) {
                localVarQueryParameter['candidateGroup'] = candidateGroup;
            }

            if (candidateGroupExpression !== undefined) {
                localVarQueryParameter['candidateGroupExpression'] = candidateGroupExpression;
            }

            if (candidateUser !== undefined) {
                localVarQueryParameter['candidateUser'] = candidateUser;
            }

            if (candidateUserExpression !== undefined) {
                localVarQueryParameter['candidateUserExpression'] = candidateUserExpression;
            }

            if (includeAssignedTasks !== undefined) {
                localVarQueryParameter['includeAssignedTasks'] = includeAssignedTasks;
            }

            if (involvedUser !== undefined) {
                localVarQueryParameter['involvedUser'] = involvedUser;
            }

            if (involvedUserExpression !== undefined) {
                localVarQueryParameter['involvedUserExpression'] = involvedUserExpression;
            }

            if (assigned !== undefined) {
                localVarQueryParameter['assigned'] = assigned;
            }

            if (unassigned !== undefined) {
                localVarQueryParameter['unassigned'] = unassigned;
            }

            if (taskDefinitionKey !== undefined) {
                localVarQueryParameter['taskDefinitionKey'] = taskDefinitionKey;
            }

            if (taskDefinitionKeyIn !== undefined) {
                localVarQueryParameter['taskDefinitionKeyIn'] = taskDefinitionKeyIn;
            }

            if (taskDefinitionKeyLike !== undefined) {
                localVarQueryParameter['taskDefinitionKeyLike'] = taskDefinitionKeyLike;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameNotEqual !== undefined) {
                localVarQueryParameter['nameNotEqual'] = nameNotEqual;
            }

            if (nameLike !== undefined) {
                localVarQueryParameter['nameLike'] = nameLike;
            }

            if (nameNotLike !== undefined) {
                localVarQueryParameter['nameNotLike'] = nameNotLike;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (descriptionLike !== undefined) {
                localVarQueryParameter['descriptionLike'] = descriptionLike;
            }

            if (priority !== undefined) {
                localVarQueryParameter['priority'] = priority;
            }

            if (maxPriority !== undefined) {
                localVarQueryParameter['maxPriority'] = maxPriority;
            }

            if (minPriority !== undefined) {
                localVarQueryParameter['minPriority'] = minPriority;
            }

            if (dueDate !== undefined) {
                localVarQueryParameter['dueDate'] = dueDate;
            }

            if (dueDateExpression !== undefined) {
                localVarQueryParameter['dueDateExpression'] = dueDateExpression;
            }

            if (dueAfter !== undefined) {
                localVarQueryParameter['dueAfter'] = dueAfter;
            }

            if (dueAfterExpression !== undefined) {
                localVarQueryParameter['dueAfterExpression'] = dueAfterExpression;
            }

            if (dueBefore !== undefined) {
                localVarQueryParameter['dueBefore'] = dueBefore;
            }

            if (dueBeforeExpression !== undefined) {
                localVarQueryParameter['dueBeforeExpression'] = dueBeforeExpression;
            }

            if (followUpDate !== undefined) {
                localVarQueryParameter['followUpDate'] = followUpDate;
            }

            if (followUpDateExpression !== undefined) {
                localVarQueryParameter['followUpDateExpression'] = followUpDateExpression;
            }

            if (followUpAfter !== undefined) {
                localVarQueryParameter['followUpAfter'] = followUpAfter;
            }

            if (followUpAfterExpression !== undefined) {
                localVarQueryParameter['followUpAfterExpression'] = followUpAfterExpression;
            }

            if (followUpBefore !== undefined) {
                localVarQueryParameter['followUpBefore'] = followUpBefore;
            }

            if (followUpBeforeExpression !== undefined) {
                localVarQueryParameter['followUpBeforeExpression'] = followUpBeforeExpression;
            }

            if (followUpBeforeOrNotExistent !== undefined) {
                localVarQueryParameter['followUpBeforeOrNotExistent'] = followUpBeforeOrNotExistent;
            }

            if (followUpBeforeOrNotExistentExpression !== undefined) {
                localVarQueryParameter['followUpBeforeOrNotExistentExpression'] = followUpBeforeOrNotExistentExpression;
            }

            if (createdOn !== undefined) {
                localVarQueryParameter['createdOn'] = createdOn;
            }

            if (createdOnExpression !== undefined) {
                localVarQueryParameter['createdOnExpression'] = createdOnExpression;
            }

            if (createdAfter !== undefined) {
                localVarQueryParameter['createdAfter'] = createdAfter;
            }

            if (createdAfterExpression !== undefined) {
                localVarQueryParameter['createdAfterExpression'] = createdAfterExpression;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['createdBefore'] = createdBefore;
            }

            if (createdBeforeExpression !== undefined) {
                localVarQueryParameter['createdBeforeExpression'] = createdBeforeExpression;
            }

            if (delegationState !== undefined) {
                localVarQueryParameter['delegationState'] = delegationState;
            }

            if (candidateGroups !== undefined) {
                localVarQueryParameter['candidateGroups'] = candidateGroups;
            }

            if (candidateGroupsExpression !== undefined) {
                localVarQueryParameter['candidateGroupsExpression'] = candidateGroupsExpression;
            }

            if (withCandidateGroups !== undefined) {
                localVarQueryParameter['withCandidateGroups'] = withCandidateGroups;
            }

            if (withoutCandidateGroups !== undefined) {
                localVarQueryParameter['withoutCandidateGroups'] = withoutCandidateGroups;
            }

            if (withCandidateUsers !== undefined) {
                localVarQueryParameter['withCandidateUsers'] = withCandidateUsers;
            }

            if (withoutCandidateUsers !== undefined) {
                localVarQueryParameter['withoutCandidateUsers'] = withoutCandidateUsers;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (suspended !== undefined) {
                localVarQueryParameter['suspended'] = suspended;
            }

            if (taskVariables !== undefined) {
                localVarQueryParameter['taskVariables'] = taskVariables;
            }

            if (processVariables !== undefined) {
                localVarQueryParameter['processVariables'] = processVariables;
            }

            if (caseInstanceVariables !== undefined) {
                localVarQueryParameter['caseInstanceVariables'] = caseInstanceVariables;
            }

            if (variableNamesIgnoreCase !== undefined) {
                localVarQueryParameter['variableNamesIgnoreCase'] = variableNamesIgnoreCase;
            }

            if (variableValuesIgnoreCase !== undefined) {
                localVarQueryParameter['variableValuesIgnoreCase'] = variableValuesIgnoreCase;
            }

            if (parentTaskId !== undefined) {
                localVarQueryParameter['parentTaskId'] = parentTaskId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reports a business error in the context of a running task by id. The error code must be specified to identify the BPMN error handler. See the documentation for [Reporting Bpmn Error](https://docs.camunda.org/manual/7.13/reference/bpmn20/tasks/user-task/#reporting-bpmn-error) in User Tasks.
         * @param {string} id The id of the task a BPMN error is reported for.
         * @param {TaskBpmnErrorDto} [taskBpmnErrorDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleBpmnError: async (id: string, taskBpmnErrorDto?: TaskBpmnErrorDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('handleBpmnError', 'id', id)
            const localVarPath = `/task/{id}/bpmnError`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taskBpmnErrorDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reports an escalation in the context of a running task by id. The escalation code must be specified to identify the escalation handler. See the documentation for [Reporting Bpmn Escalation](https://docs.camunda.org/manual/7.13/reference/bpmn20/tasks/user-task/#reporting-bpmn-escalation) in User Tasks.
         * @param {string} id The id of the task in which context a BPMN escalation is reported.
         * @param {TaskEscalationDto} [taskEscalationDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleEscalation: async (id: string, taskEscalationDto?: TaskEscalationDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('handleEscalation', 'id', id)
            const localVarPath = `/task/{id}/bpmnEscalation`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taskEscalationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for tasks that fulfill a given filter. This method is slightly more powerful than the [Get Tasks](https://docs.camunda.org/manual/7.13/reference/rest/task/get-query/) method because it allows filtering by multiple process or task variables of types `String`, `Number` or `Boolean`. The size of the result set can be retrieved by using the [Get Task Count (POST)](https://docs.camunda.org/manual/7.13/reference/rest/task/post-query-count/) method.  **Security Consideration**: There are several parameters (such as `assigneeExpression`) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) in the user guide for details.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {TaskQueryDto} [taskQueryDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryTasks: async (firstResult?: number, maxResults?: number, taskQueryDto?: TaskQueryDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/task`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taskQueryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the number of tasks that fulfill the given filter. Corresponds to the size of the result set of the [Get Tasks (POST)](https://docs.camunda.org/manual/7.13/reference/rest/task/post-query/) method and takes the same parameters.  **Security Consideration**: There are several parameters (such as `assigneeExpression`) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) in the user guide for details.
         * @param {TaskQueryDto} [taskQueryDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryTasksCount: async (taskQueryDto?: TaskQueryDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/task/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taskQueryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resolves a task and updates execution variables.  Resolving a task marks that the assignee is done with the task delegated to them, and that it can be sent back to the owner. Can only be executed when the task has been delegated. The assignee will be set to the owner, who performed the delegation.
         * @param {string} id The id of the task to resolve.
         * @param {CompleteTaskDto} [completeTaskDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolve: async (id: string, completeTaskDto?: CompleteTaskDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('resolve', 'id', id)
            const localVarPath = `/task/{id}/resolve`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(completeTaskDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes the assignee of a task to a specific user.  **Note:** The difference with the [Claim Task](https://docs.camunda.org/manual/7.13/reference/rest/task/post-claim/) method is that this method does not check if the task already has a user assigned to it.
         * @param {string} id The id of the task to set the assignee for.
         * @param {UserIdDto} [userIdDto] Provide the id of the user that will be the assignee of the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAssignee: async (id: string, userIdDto?: UserIdDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setAssignee', 'id', id)
            const localVarPath = `/task/{id}/assignee`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userIdDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Completes a task and updates process variables using a form submit. There are two difference between this method and the `complete` method:  * If the task is in state `PENDING` - i.e., has been delegated before, it is not completed but resolved. Otherwise it will be completed. * If the task has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See the [Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/_index/#generated-task-forms) section of the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/) for more information.
         * @param {string} id The id of the task to submit the form for.
         * @param {CompleteTaskDto} [completeTaskDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submit: async (id: string, completeTaskDto?: CompleteTaskDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submit', 'id', id)
            const localVarPath = `/task/{id}/submit-form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(completeTaskDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resets a task\'s assignee. If successful, the task is not assigned to a user.
         * @param {string} id The id of the task to unclaim.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unclaim: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unclaim', 'id', id)
            const localVarPath = `/task/{id}/unclaim`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a task.
         * @param {string} id The id of the task to be updated.
         * @param {TaskDto} [taskDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask: async (id: string, taskDto?: TaskDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTask', 'id', id)
            const localVarPath = `/task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taskDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskApi - functional programming interface
 * @export
 */
export const TaskApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaskApiAxiosParamCreator(configuration)
    return {
        /**
         * Claims a task for a specific user.  **Note:** The difference with the [Set Assignee](https://docs.camunda.org/manual/7.13/reference/rest/task/post-assignee/) method is that here a check is performed to see if the task already has a user assigned to it.
         * @param {string} id The id of the task to claim.
         * @param {UserIdDto} [userIdDto] Provide the id of the user that claims the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async claim(id: string, userIdDto?: UserIdDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.claim(id, userIdDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Completes a task and updates process variables.
         * @param {string} id The id of the task to complete.
         * @param {CompleteTaskDto} [completeTaskDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async complete(id: string, completeTaskDto?: CompleteTaskDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: VariableValueDto; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.complete(id, completeTaskDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new task.
         * @param {TaskDto} [taskDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTask(taskDto?: TaskDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTask(taskDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delegates a task to another user.
         * @param {string} id The id of the task to delegate.
         * @param {UserIdDto} [userIdDto] Provide the id of the user that the task should be delegated to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delegateTask(id: string, userIdDto?: UserIdDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delegateTask(id, userIdDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes a task by id.
         * @param {string} id The id of the task to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTask(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTask(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the deployed form that is referenced from a given task. For further information please refer to the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
         * @param {string} id The id of the task to get the deployed form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeployedForm(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeployedForm(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the form key for a task. The form key corresponds to the `FormData#formKey` property in the engine. This key can be used to do task-specific form rendering in client applications. Additionally, the context path of the containing process application is returned.
         * @param {string} id The id of the task to retrieve the form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForm(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForm(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the form variables for a task. The form variables take form data specified on the task into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @param {string} id The id of the task to retrieve the variables for.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFormVariables(id: string, variableNames?: string, deserializeValues?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: VariableValueDto; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFormVariables(id, variableNames, deserializeValues, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the rendered form for a task. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @param {string} id The id of the task to get the rendered form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRenderedForm(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRenderedForm(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a task by id.
         * @param {string} id The id of the task to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTask(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTask(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Queries for tasks that fulfill a given filter. The size of the result set can be retrieved by using the Get Task Count method.  **Security Consideration:** There are several query parameters (such as assigneeExpression) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) for custom code in the user guide for details.
         * @param {string} [processInstanceId] Restrict to tasks that belong to process instances with the given id.
         * @param {string} [processInstanceIdIn] Restrict to tasks that belong to process instances with the given ids.
         * @param {string} [processInstanceBusinessKey] Restrict to tasks that belong to process instances with the given business key.
         * @param {string} [processInstanceBusinessKeyExpression] Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {string} [processInstanceBusinessKeyIn] Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
         * @param {string} [processInstanceBusinessKeyLike] Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
         * @param {string} [processInstanceBusinessKeyLikeExpression] Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [processDefinitionId] Restrict to tasks that belong to a process definition with the given id.
         * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
         * @param {string} [processDefinitionKeyIn] Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
         * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
         * @param {string} [processDefinitionNameLike] Restrict to tasks that have a process definition name that has the parameter value as  a substring.
         * @param {string} [executionId] Restrict to tasks that belong to an execution with the given id.
         * @param {string} [caseInstanceId] Restrict to tasks that belong to case instances with the given id.
         * @param {string} [caseInstanceBusinessKey] Restrict to tasks that belong to case instances with the given business key.
         * @param {string} [caseInstanceBusinessKeyLike] Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
         * @param {string} [caseDefinitionId] Restrict to tasks that belong to a case definition with the given id.
         * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
         * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
         * @param {string} [caseDefinitionNameLike] Restrict to tasks that have a case definition name that has the parameter value as a  substring.
         * @param {string} [caseExecutionId] Restrict to tasks that belong to a case execution with the given id.
         * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
         * @param {string} [tenantIdIn] Only include tasks which belong to one of the passed and comma-separated  tenant ids.
         * @param {boolean} [withoutTenantId] Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
         * @param {string} [assignee] Restrict to tasks that the given user is assigned to.
         * @param {string} [assigneeExpression] Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeLike] Restrict to tasks that have an assignee that has the parameter  value as a substring.
         * @param {string} [assigneeLikeExpression] Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeIn] Only include tasks which are assigned to one of the passed and  comma-separated user ids.
         * @param {string} [owner] Restrict to tasks that the given user owns.
         * @param {string} [ownerExpression] Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateGroup] Only include tasks that are offered to the given group.
         * @param {string} [candidateGroupExpression] Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateUser] Only include tasks that are offered to the given user or to one of his groups.
         * @param {string} [candidateUserExpression] Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {boolean} [includeAssignedTasks] Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
         * @param {string} [involvedUser] Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
         * @param {string} [involvedUserExpression] Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
         * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
         * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
         * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
         * @param {string} [taskDefinitionKeyLike] Restrict to tasks that have a key that has the parameter value as a substring.
         * @param {string} [name] Restrict to tasks that have the given name.
         * @param {string} [nameNotEqual] Restrict to tasks that do not have the given name.
         * @param {string} [nameLike] Restrict to tasks that have a name with the given parameter value as substring.
         * @param {string} [nameNotLike] Restrict to tasks that do not have a name with the given parameter value as substring.
         * @param {string} [description] Restrict to tasks that have the given description.
         * @param {string} [descriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
         * @param {number} [priority] Restrict to tasks that have the given priority.
         * @param {number} [maxPriority] Restrict to tasks that have a lower or equal priority.
         * @param {number} [minPriority] Restrict to tasks that have a higher or equal priority.
         * @param {string} [dueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [dueDateExpression] Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
         * @param {string} [dueAfterExpression] Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
         * @param {string} [dueBeforeExpression] Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [followUpDateExpression] Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
         * @param {string} [followUpAfterExpression] Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
         * @param {string} [followUpBeforeExpression] Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBeforeOrNotExistent] Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
         * @param {string} [followUpBeforeOrNotExistentExpression] Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdOn] Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
         * @param {string} [createdOnExpression] Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdAfter] Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [createdAfterExpression] Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdBefore] Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
         * @param {string} [createdBeforeExpression] Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {'PENDING' | 'RESOLVED'} [delegationState] Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
         * @param {string} [candidateGroups] Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
         * @param {string} [candidateGroupsExpression] Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
         * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withCandidateUsers] Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateUsers] Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [caseInstanceVariables] Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
         * @param {string} [parentTaskId] Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
         * @param {'instanceId' | 'caseInstanceId' | 'dueDate' | 'executionId' | 'caseExecutionId' | 'assignee' | 'created' | 'description' | 'id' | 'name' | 'nameCaseInsensitive' | 'priority' | 'processVariable' | 'executionVariable' | 'taskVariable' | 'caseExecutionVariable' | 'caseInstanceVariable'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTasks(processInstanceId?: string, processInstanceIdIn?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyExpression?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, processInstanceBusinessKeyLikeExpression?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionName?: string, processDefinitionNameLike?: string, executionId?: string, caseInstanceId?: string, caseInstanceBusinessKey?: string, caseInstanceBusinessKeyLike?: string, caseDefinitionId?: string, caseDefinitionKey?: string, caseDefinitionName?: string, caseDefinitionNameLike?: string, caseExecutionId?: string, activityInstanceIdIn?: string, tenantIdIn?: string, withoutTenantId?: boolean, assignee?: string, assigneeExpression?: string, assigneeLike?: string, assigneeLikeExpression?: string, assigneeIn?: string, owner?: string, ownerExpression?: string, candidateGroup?: string, candidateGroupExpression?: string, candidateUser?: string, candidateUserExpression?: string, includeAssignedTasks?: boolean, involvedUser?: string, involvedUserExpression?: string, assigned?: boolean, unassigned?: boolean, taskDefinitionKey?: string, taskDefinitionKeyIn?: string, taskDefinitionKeyLike?: string, name?: string, nameNotEqual?: string, nameLike?: string, nameNotLike?: string, description?: string, descriptionLike?: string, priority?: number, maxPriority?: number, minPriority?: number, dueDate?: string, dueDateExpression?: string, dueAfter?: string, dueAfterExpression?: string, dueBefore?: string, dueBeforeExpression?: string, followUpDate?: string, followUpDateExpression?: string, followUpAfter?: string, followUpAfterExpression?: string, followUpBefore?: string, followUpBeforeExpression?: string, followUpBeforeOrNotExistent?: string, followUpBeforeOrNotExistentExpression?: string, createdOn?: string, createdOnExpression?: string, createdAfter?: string, createdAfterExpression?: string, createdBefore?: string, createdBeforeExpression?: string, delegationState?: 'PENDING' | 'RESOLVED', candidateGroups?: string, candidateGroupsExpression?: string, withCandidateGroups?: boolean, withoutCandidateGroups?: boolean, withCandidateUsers?: boolean, withoutCandidateUsers?: boolean, active?: boolean, suspended?: boolean, taskVariables?: string, processVariables?: string, caseInstanceVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, parentTaskId?: string, sortBy?: 'instanceId' | 'caseInstanceId' | 'dueDate' | 'executionId' | 'caseExecutionId' | 'assignee' | 'created' | 'description' | 'id' | 'name' | 'nameCaseInsensitive' | 'priority' | 'processVariable' | 'executionVariable' | 'taskVariable' | 'caseExecutionVariable' | 'caseInstanceVariable', sortOrder?: 'asc' | 'desc', firstResult?: number, maxResults?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTasks(processInstanceId, processInstanceIdIn, processInstanceBusinessKey, processInstanceBusinessKeyExpression, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, processInstanceBusinessKeyLikeExpression, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionName, processDefinitionNameLike, executionId, caseInstanceId, caseInstanceBusinessKey, caseInstanceBusinessKeyLike, caseDefinitionId, caseDefinitionKey, caseDefinitionName, caseDefinitionNameLike, caseExecutionId, activityInstanceIdIn, tenantIdIn, withoutTenantId, assignee, assigneeExpression, assigneeLike, assigneeLikeExpression, assigneeIn, owner, ownerExpression, candidateGroup, candidateGroupExpression, candidateUser, candidateUserExpression, includeAssignedTasks, involvedUser, involvedUserExpression, assigned, unassigned, taskDefinitionKey, taskDefinitionKeyIn, taskDefinitionKeyLike, name, nameNotEqual, nameLike, nameNotLike, description, descriptionLike, priority, maxPriority, minPriority, dueDate, dueDateExpression, dueAfter, dueAfterExpression, dueBefore, dueBeforeExpression, followUpDate, followUpDateExpression, followUpAfter, followUpAfterExpression, followUpBefore, followUpBeforeExpression, followUpBeforeOrNotExistent, followUpBeforeOrNotExistentExpression, createdOn, createdOnExpression, createdAfter, createdAfterExpression, createdBefore, createdBeforeExpression, delegationState, candidateGroups, candidateGroupsExpression, withCandidateGroups, withoutCandidateGroups, withCandidateUsers, withoutCandidateUsers, active, suspended, taskVariables, processVariables, caseInstanceVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, parentTaskId, sortBy, sortOrder, firstResult, maxResults, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the number of tasks that fulfill a provided filter. Corresponds to the size of the result set when using the [Get Tasks](https://docs.camunda.org/manual/7.13/reference/rest/task/) method.  **Security Consideration:** There are several query parameters (such as assigneeExpression) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) for custom code in the user guide for details.
         * @param {string} [processInstanceId] Restrict to tasks that belong to process instances with the given id.
         * @param {string} [processInstanceIdIn] Restrict to tasks that belong to process instances with the given ids.
         * @param {string} [processInstanceBusinessKey] Restrict to tasks that belong to process instances with the given business key.
         * @param {string} [processInstanceBusinessKeyExpression] Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {string} [processInstanceBusinessKeyIn] Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
         * @param {string} [processInstanceBusinessKeyLike] Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
         * @param {string} [processInstanceBusinessKeyLikeExpression] Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [processDefinitionId] Restrict to tasks that belong to a process definition with the given id.
         * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
         * @param {string} [processDefinitionKeyIn] Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
         * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
         * @param {string} [processDefinitionNameLike] Restrict to tasks that have a process definition name that has the parameter value as  a substring.
         * @param {string} [executionId] Restrict to tasks that belong to an execution with the given id.
         * @param {string} [caseInstanceId] Restrict to tasks that belong to case instances with the given id.
         * @param {string} [caseInstanceBusinessKey] Restrict to tasks that belong to case instances with the given business key.
         * @param {string} [caseInstanceBusinessKeyLike] Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
         * @param {string} [caseDefinitionId] Restrict to tasks that belong to a case definition with the given id.
         * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
         * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
         * @param {string} [caseDefinitionNameLike] Restrict to tasks that have a case definition name that has the parameter value as a  substring.
         * @param {string} [caseExecutionId] Restrict to tasks that belong to a case execution with the given id.
         * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
         * @param {string} [tenantIdIn] Only include tasks which belong to one of the passed and comma-separated  tenant ids.
         * @param {boolean} [withoutTenantId] Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
         * @param {string} [assignee] Restrict to tasks that the given user is assigned to.
         * @param {string} [assigneeExpression] Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeLike] Restrict to tasks that have an assignee that has the parameter  value as a substring.
         * @param {string} [assigneeLikeExpression] Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeIn] Only include tasks which are assigned to one of the passed and  comma-separated user ids.
         * @param {string} [owner] Restrict to tasks that the given user owns.
         * @param {string} [ownerExpression] Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateGroup] Only include tasks that are offered to the given group.
         * @param {string} [candidateGroupExpression] Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateUser] Only include tasks that are offered to the given user or to one of his groups.
         * @param {string} [candidateUserExpression] Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {boolean} [includeAssignedTasks] Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
         * @param {string} [involvedUser] Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
         * @param {string} [involvedUserExpression] Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
         * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
         * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
         * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
         * @param {string} [taskDefinitionKeyLike] Restrict to tasks that have a key that has the parameter value as a substring.
         * @param {string} [name] Restrict to tasks that have the given name.
         * @param {string} [nameNotEqual] Restrict to tasks that do not have the given name.
         * @param {string} [nameLike] Restrict to tasks that have a name with the given parameter value as substring.
         * @param {string} [nameNotLike] Restrict to tasks that do not have a name with the given parameter value as substring.
         * @param {string} [description] Restrict to tasks that have the given description.
         * @param {string} [descriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
         * @param {number} [priority] Restrict to tasks that have the given priority.
         * @param {number} [maxPriority] Restrict to tasks that have a lower or equal priority.
         * @param {number} [minPriority] Restrict to tasks that have a higher or equal priority.
         * @param {string} [dueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [dueDateExpression] Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
         * @param {string} [dueAfterExpression] Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
         * @param {string} [dueBeforeExpression] Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [followUpDateExpression] Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
         * @param {string} [followUpAfterExpression] Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
         * @param {string} [followUpBeforeExpression] Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBeforeOrNotExistent] Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
         * @param {string} [followUpBeforeOrNotExistentExpression] Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdOn] Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
         * @param {string} [createdOnExpression] Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdAfter] Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [createdAfterExpression] Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdBefore] Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
         * @param {string} [createdBeforeExpression] Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {'PENDING' | 'RESOLVED'} [delegationState] Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
         * @param {string} [candidateGroups] Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
         * @param {string} [candidateGroupsExpression] Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
         * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withCandidateUsers] Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateUsers] Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [caseInstanceVariables] Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
         * @param {string} [parentTaskId] Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTasksCount(processInstanceId?: string, processInstanceIdIn?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyExpression?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, processInstanceBusinessKeyLikeExpression?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionName?: string, processDefinitionNameLike?: string, executionId?: string, caseInstanceId?: string, caseInstanceBusinessKey?: string, caseInstanceBusinessKeyLike?: string, caseDefinitionId?: string, caseDefinitionKey?: string, caseDefinitionName?: string, caseDefinitionNameLike?: string, caseExecutionId?: string, activityInstanceIdIn?: string, tenantIdIn?: string, withoutTenantId?: boolean, assignee?: string, assigneeExpression?: string, assigneeLike?: string, assigneeLikeExpression?: string, assigneeIn?: string, owner?: string, ownerExpression?: string, candidateGroup?: string, candidateGroupExpression?: string, candidateUser?: string, candidateUserExpression?: string, includeAssignedTasks?: boolean, involvedUser?: string, involvedUserExpression?: string, assigned?: boolean, unassigned?: boolean, taskDefinitionKey?: string, taskDefinitionKeyIn?: string, taskDefinitionKeyLike?: string, name?: string, nameNotEqual?: string, nameLike?: string, nameNotLike?: string, description?: string, descriptionLike?: string, priority?: number, maxPriority?: number, minPriority?: number, dueDate?: string, dueDateExpression?: string, dueAfter?: string, dueAfterExpression?: string, dueBefore?: string, dueBeforeExpression?: string, followUpDate?: string, followUpDateExpression?: string, followUpAfter?: string, followUpAfterExpression?: string, followUpBefore?: string, followUpBeforeExpression?: string, followUpBeforeOrNotExistent?: string, followUpBeforeOrNotExistentExpression?: string, createdOn?: string, createdOnExpression?: string, createdAfter?: string, createdAfterExpression?: string, createdBefore?: string, createdBeforeExpression?: string, delegationState?: 'PENDING' | 'RESOLVED', candidateGroups?: string, candidateGroupsExpression?: string, withCandidateGroups?: boolean, withoutCandidateGroups?: boolean, withCandidateUsers?: boolean, withoutCandidateUsers?: boolean, active?: boolean, suspended?: boolean, taskVariables?: string, processVariables?: string, caseInstanceVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, parentTaskId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTasksCount(processInstanceId, processInstanceIdIn, processInstanceBusinessKey, processInstanceBusinessKeyExpression, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, processInstanceBusinessKeyLikeExpression, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionName, processDefinitionNameLike, executionId, caseInstanceId, caseInstanceBusinessKey, caseInstanceBusinessKeyLike, caseDefinitionId, caseDefinitionKey, caseDefinitionName, caseDefinitionNameLike, caseExecutionId, activityInstanceIdIn, tenantIdIn, withoutTenantId, assignee, assigneeExpression, assigneeLike, assigneeLikeExpression, assigneeIn, owner, ownerExpression, candidateGroup, candidateGroupExpression, candidateUser, candidateUserExpression, includeAssignedTasks, involvedUser, involvedUserExpression, assigned, unassigned, taskDefinitionKey, taskDefinitionKeyIn, taskDefinitionKeyLike, name, nameNotEqual, nameLike, nameNotLike, description, descriptionLike, priority, maxPriority, minPriority, dueDate, dueDateExpression, dueAfter, dueAfterExpression, dueBefore, dueBeforeExpression, followUpDate, followUpDateExpression, followUpAfter, followUpAfterExpression, followUpBefore, followUpBeforeExpression, followUpBeforeOrNotExistent, followUpBeforeOrNotExistentExpression, createdOn, createdOnExpression, createdAfter, createdAfterExpression, createdBefore, createdBeforeExpression, delegationState, candidateGroups, candidateGroupsExpression, withCandidateGroups, withoutCandidateGroups, withCandidateUsers, withoutCandidateUsers, active, suspended, taskVariables, processVariables, caseInstanceVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, parentTaskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reports a business error in the context of a running task by id. The error code must be specified to identify the BPMN error handler. See the documentation for [Reporting Bpmn Error](https://docs.camunda.org/manual/7.13/reference/bpmn20/tasks/user-task/#reporting-bpmn-error) in User Tasks.
         * @param {string} id The id of the task a BPMN error is reported for.
         * @param {TaskBpmnErrorDto} [taskBpmnErrorDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleBpmnError(id: string, taskBpmnErrorDto?: TaskBpmnErrorDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleBpmnError(id, taskBpmnErrorDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reports an escalation in the context of a running task by id. The escalation code must be specified to identify the escalation handler. See the documentation for [Reporting Bpmn Escalation](https://docs.camunda.org/manual/7.13/reference/bpmn20/tasks/user-task/#reporting-bpmn-escalation) in User Tasks.
         * @param {string} id The id of the task in which context a BPMN escalation is reported.
         * @param {TaskEscalationDto} [taskEscalationDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleEscalation(id: string, taskEscalationDto?: TaskEscalationDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleEscalation(id, taskEscalationDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Queries for tasks that fulfill a given filter. This method is slightly more powerful than the [Get Tasks](https://docs.camunda.org/manual/7.13/reference/rest/task/get-query/) method because it allows filtering by multiple process or task variables of types `String`, `Number` or `Boolean`. The size of the result set can be retrieved by using the [Get Task Count (POST)](https://docs.camunda.org/manual/7.13/reference/rest/task/post-query-count/) method.  **Security Consideration**: There are several parameters (such as `assigneeExpression`) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) in the user guide for details.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {TaskQueryDto} [taskQueryDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryTasks(firstResult?: number, maxResults?: number, taskQueryDto?: TaskQueryDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryTasks(firstResult, maxResults, taskQueryDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the number of tasks that fulfill the given filter. Corresponds to the size of the result set of the [Get Tasks (POST)](https://docs.camunda.org/manual/7.13/reference/rest/task/post-query/) method and takes the same parameters.  **Security Consideration**: There are several parameters (such as `assigneeExpression`) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) in the user guide for details.
         * @param {TaskQueryDto} [taskQueryDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryTasksCount(taskQueryDto?: TaskQueryDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryTasksCount(taskQueryDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resolves a task and updates execution variables.  Resolving a task marks that the assignee is done with the task delegated to them, and that it can be sent back to the owner. Can only be executed when the task has been delegated. The assignee will be set to the owner, who performed the delegation.
         * @param {string} id The id of the task to resolve.
         * @param {CompleteTaskDto} [completeTaskDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolve(id: string, completeTaskDto?: CompleteTaskDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resolve(id, completeTaskDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Changes the assignee of a task to a specific user.  **Note:** The difference with the [Claim Task](https://docs.camunda.org/manual/7.13/reference/rest/task/post-claim/) method is that this method does not check if the task already has a user assigned to it.
         * @param {string} id The id of the task to set the assignee for.
         * @param {UserIdDto} [userIdDto] Provide the id of the user that will be the assignee of the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setAssignee(id: string, userIdDto?: UserIdDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setAssignee(id, userIdDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Completes a task and updates process variables using a form submit. There are two difference between this method and the `complete` method:  * If the task is in state `PENDING` - i.e., has been delegated before, it is not completed but resolved. Otherwise it will be completed. * If the task has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See the [Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/_index/#generated-task-forms) section of the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/) for more information.
         * @param {string} id The id of the task to submit the form for.
         * @param {CompleteTaskDto} [completeTaskDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submit(id: string, completeTaskDto?: CompleteTaskDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: VariableValueDto; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submit(id, completeTaskDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resets a task\'s assignee. If successful, the task is not assigned to a user.
         * @param {string} id The id of the task to unclaim.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unclaim(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unclaim(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a task.
         * @param {string} id The id of the task to be updated.
         * @param {TaskDto} [taskDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTask(id: string, taskDto?: TaskDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTask(id, taskDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TaskApi - factory interface
 * @export
 */
export const TaskApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaskApiFp(configuration)
    return {
        /**
         * Claims a task for a specific user.  **Note:** The difference with the [Set Assignee](https://docs.camunda.org/manual/7.13/reference/rest/task/post-assignee/) method is that here a check is performed to see if the task already has a user assigned to it.
         * @param {string} id The id of the task to claim.
         * @param {UserIdDto} [userIdDto] Provide the id of the user that claims the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claim(id: string, userIdDto?: UserIdDto, options?: any): AxiosPromise<void> {
            return localVarFp.claim(id, userIdDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Completes a task and updates process variables.
         * @param {string} id The id of the task to complete.
         * @param {CompleteTaskDto} [completeTaskDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        complete(id: string, completeTaskDto?: CompleteTaskDto, options?: any): AxiosPromise<{ [key: string]: VariableValueDto; }> {
            return localVarFp.complete(id, completeTaskDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new task.
         * @param {TaskDto} [taskDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTask(taskDto?: TaskDto, options?: any): AxiosPromise<void> {
            return localVarFp.createTask(taskDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Delegates a task to another user.
         * @param {string} id The id of the task to delegate.
         * @param {UserIdDto} [userIdDto] Provide the id of the user that the task should be delegated to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegateTask(id: string, userIdDto?: UserIdDto, options?: any): AxiosPromise<void> {
            return localVarFp.delegateTask(id, userIdDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a task by id.
         * @param {string} id The id of the task to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTask(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTask(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the deployed form that is referenced from a given task. For further information please refer to the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
         * @param {string} id The id of the task to get the deployed form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedForm(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.getDeployedForm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the form key for a task. The form key corresponds to the `FormData#formKey` property in the engine. This key can be used to do task-specific form rendering in client applications. Additionally, the context path of the containing process application is returned.
         * @param {string} id The id of the task to retrieve the form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForm(id: string, options?: any): AxiosPromise<FormDto> {
            return localVarFp.getForm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the form variables for a task. The form variables take form data specified on the task into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @param {string} id The id of the task to retrieve the variables for.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFormVariables(id: string, variableNames?: string, deserializeValues?: boolean, options?: any): AxiosPromise<{ [key: string]: VariableValueDto; }> {
            return localVarFp.getFormVariables(id, variableNames, deserializeValues, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the rendered form for a task. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @param {string} id The id of the task to get the rendered form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRenderedForm(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.getRenderedForm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a task by id.
         * @param {string} id The id of the task to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask(id: string, options?: any): AxiosPromise<TaskDto> {
            return localVarFp.getTask(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for tasks that fulfill a given filter. The size of the result set can be retrieved by using the Get Task Count method.  **Security Consideration:** There are several query parameters (such as assigneeExpression) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) for custom code in the user guide for details.
         * @param {string} [processInstanceId] Restrict to tasks that belong to process instances with the given id.
         * @param {string} [processInstanceIdIn] Restrict to tasks that belong to process instances with the given ids.
         * @param {string} [processInstanceBusinessKey] Restrict to tasks that belong to process instances with the given business key.
         * @param {string} [processInstanceBusinessKeyExpression] Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {string} [processInstanceBusinessKeyIn] Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
         * @param {string} [processInstanceBusinessKeyLike] Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
         * @param {string} [processInstanceBusinessKeyLikeExpression] Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [processDefinitionId] Restrict to tasks that belong to a process definition with the given id.
         * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
         * @param {string} [processDefinitionKeyIn] Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
         * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
         * @param {string} [processDefinitionNameLike] Restrict to tasks that have a process definition name that has the parameter value as  a substring.
         * @param {string} [executionId] Restrict to tasks that belong to an execution with the given id.
         * @param {string} [caseInstanceId] Restrict to tasks that belong to case instances with the given id.
         * @param {string} [caseInstanceBusinessKey] Restrict to tasks that belong to case instances with the given business key.
         * @param {string} [caseInstanceBusinessKeyLike] Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
         * @param {string} [caseDefinitionId] Restrict to tasks that belong to a case definition with the given id.
         * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
         * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
         * @param {string} [caseDefinitionNameLike] Restrict to tasks that have a case definition name that has the parameter value as a  substring.
         * @param {string} [caseExecutionId] Restrict to tasks that belong to a case execution with the given id.
         * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
         * @param {string} [tenantIdIn] Only include tasks which belong to one of the passed and comma-separated  tenant ids.
         * @param {boolean} [withoutTenantId] Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
         * @param {string} [assignee] Restrict to tasks that the given user is assigned to.
         * @param {string} [assigneeExpression] Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeLike] Restrict to tasks that have an assignee that has the parameter  value as a substring.
         * @param {string} [assigneeLikeExpression] Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeIn] Only include tasks which are assigned to one of the passed and  comma-separated user ids.
         * @param {string} [owner] Restrict to tasks that the given user owns.
         * @param {string} [ownerExpression] Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateGroup] Only include tasks that are offered to the given group.
         * @param {string} [candidateGroupExpression] Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateUser] Only include tasks that are offered to the given user or to one of his groups.
         * @param {string} [candidateUserExpression] Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {boolean} [includeAssignedTasks] Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
         * @param {string} [involvedUser] Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
         * @param {string} [involvedUserExpression] Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
         * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
         * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
         * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
         * @param {string} [taskDefinitionKeyLike] Restrict to tasks that have a key that has the parameter value as a substring.
         * @param {string} [name] Restrict to tasks that have the given name.
         * @param {string} [nameNotEqual] Restrict to tasks that do not have the given name.
         * @param {string} [nameLike] Restrict to tasks that have a name with the given parameter value as substring.
         * @param {string} [nameNotLike] Restrict to tasks that do not have a name with the given parameter value as substring.
         * @param {string} [description] Restrict to tasks that have the given description.
         * @param {string} [descriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
         * @param {number} [priority] Restrict to tasks that have the given priority.
         * @param {number} [maxPriority] Restrict to tasks that have a lower or equal priority.
         * @param {number} [minPriority] Restrict to tasks that have a higher or equal priority.
         * @param {string} [dueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [dueDateExpression] Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
         * @param {string} [dueAfterExpression] Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
         * @param {string} [dueBeforeExpression] Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [followUpDateExpression] Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
         * @param {string} [followUpAfterExpression] Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
         * @param {string} [followUpBeforeExpression] Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBeforeOrNotExistent] Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
         * @param {string} [followUpBeforeOrNotExistentExpression] Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdOn] Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
         * @param {string} [createdOnExpression] Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdAfter] Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [createdAfterExpression] Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdBefore] Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
         * @param {string} [createdBeforeExpression] Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {'PENDING' | 'RESOLVED'} [delegationState] Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
         * @param {string} [candidateGroups] Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
         * @param {string} [candidateGroupsExpression] Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
         * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withCandidateUsers] Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateUsers] Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [caseInstanceVariables] Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
         * @param {string} [parentTaskId] Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
         * @param {'instanceId' | 'caseInstanceId' | 'dueDate' | 'executionId' | 'caseExecutionId' | 'assignee' | 'created' | 'description' | 'id' | 'name' | 'nameCaseInsensitive' | 'priority' | 'processVariable' | 'executionVariable' | 'taskVariable' | 'caseExecutionVariable' | 'caseInstanceVariable'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks(processInstanceId?: string, processInstanceIdIn?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyExpression?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, processInstanceBusinessKeyLikeExpression?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionName?: string, processDefinitionNameLike?: string, executionId?: string, caseInstanceId?: string, caseInstanceBusinessKey?: string, caseInstanceBusinessKeyLike?: string, caseDefinitionId?: string, caseDefinitionKey?: string, caseDefinitionName?: string, caseDefinitionNameLike?: string, caseExecutionId?: string, activityInstanceIdIn?: string, tenantIdIn?: string, withoutTenantId?: boolean, assignee?: string, assigneeExpression?: string, assigneeLike?: string, assigneeLikeExpression?: string, assigneeIn?: string, owner?: string, ownerExpression?: string, candidateGroup?: string, candidateGroupExpression?: string, candidateUser?: string, candidateUserExpression?: string, includeAssignedTasks?: boolean, involvedUser?: string, involvedUserExpression?: string, assigned?: boolean, unassigned?: boolean, taskDefinitionKey?: string, taskDefinitionKeyIn?: string, taskDefinitionKeyLike?: string, name?: string, nameNotEqual?: string, nameLike?: string, nameNotLike?: string, description?: string, descriptionLike?: string, priority?: number, maxPriority?: number, minPriority?: number, dueDate?: string, dueDateExpression?: string, dueAfter?: string, dueAfterExpression?: string, dueBefore?: string, dueBeforeExpression?: string, followUpDate?: string, followUpDateExpression?: string, followUpAfter?: string, followUpAfterExpression?: string, followUpBefore?: string, followUpBeforeExpression?: string, followUpBeforeOrNotExistent?: string, followUpBeforeOrNotExistentExpression?: string, createdOn?: string, createdOnExpression?: string, createdAfter?: string, createdAfterExpression?: string, createdBefore?: string, createdBeforeExpression?: string, delegationState?: 'PENDING' | 'RESOLVED', candidateGroups?: string, candidateGroupsExpression?: string, withCandidateGroups?: boolean, withoutCandidateGroups?: boolean, withCandidateUsers?: boolean, withoutCandidateUsers?: boolean, active?: boolean, suspended?: boolean, taskVariables?: string, processVariables?: string, caseInstanceVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, parentTaskId?: string, sortBy?: 'instanceId' | 'caseInstanceId' | 'dueDate' | 'executionId' | 'caseExecutionId' | 'assignee' | 'created' | 'description' | 'id' | 'name' | 'nameCaseInsensitive' | 'priority' | 'processVariable' | 'executionVariable' | 'taskVariable' | 'caseExecutionVariable' | 'caseInstanceVariable', sortOrder?: 'asc' | 'desc', firstResult?: number, maxResults?: number, options?: any): AxiosPromise<Array<TaskDto>> {
            return localVarFp.getTasks(processInstanceId, processInstanceIdIn, processInstanceBusinessKey, processInstanceBusinessKeyExpression, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, processInstanceBusinessKeyLikeExpression, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionName, processDefinitionNameLike, executionId, caseInstanceId, caseInstanceBusinessKey, caseInstanceBusinessKeyLike, caseDefinitionId, caseDefinitionKey, caseDefinitionName, caseDefinitionNameLike, caseExecutionId, activityInstanceIdIn, tenantIdIn, withoutTenantId, assignee, assigneeExpression, assigneeLike, assigneeLikeExpression, assigneeIn, owner, ownerExpression, candidateGroup, candidateGroupExpression, candidateUser, candidateUserExpression, includeAssignedTasks, involvedUser, involvedUserExpression, assigned, unassigned, taskDefinitionKey, taskDefinitionKeyIn, taskDefinitionKeyLike, name, nameNotEqual, nameLike, nameNotLike, description, descriptionLike, priority, maxPriority, minPriority, dueDate, dueDateExpression, dueAfter, dueAfterExpression, dueBefore, dueBeforeExpression, followUpDate, followUpDateExpression, followUpAfter, followUpAfterExpression, followUpBefore, followUpBeforeExpression, followUpBeforeOrNotExistent, followUpBeforeOrNotExistentExpression, createdOn, createdOnExpression, createdAfter, createdAfterExpression, createdBefore, createdBeforeExpression, delegationState, candidateGroups, candidateGroupsExpression, withCandidateGroups, withoutCandidateGroups, withCandidateUsers, withoutCandidateUsers, active, suspended, taskVariables, processVariables, caseInstanceVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, parentTaskId, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the number of tasks that fulfill a provided filter. Corresponds to the size of the result set when using the [Get Tasks](https://docs.camunda.org/manual/7.13/reference/rest/task/) method.  **Security Consideration:** There are several query parameters (such as assigneeExpression) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) for custom code in the user guide for details.
         * @param {string} [processInstanceId] Restrict to tasks that belong to process instances with the given id.
         * @param {string} [processInstanceIdIn] Restrict to tasks that belong to process instances with the given ids.
         * @param {string} [processInstanceBusinessKey] Restrict to tasks that belong to process instances with the given business key.
         * @param {string} [processInstanceBusinessKeyExpression] Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {string} [processInstanceBusinessKeyIn] Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
         * @param {string} [processInstanceBusinessKeyLike] Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
         * @param {string} [processInstanceBusinessKeyLikeExpression] Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [processDefinitionId] Restrict to tasks that belong to a process definition with the given id.
         * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
         * @param {string} [processDefinitionKeyIn] Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
         * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
         * @param {string} [processDefinitionNameLike] Restrict to tasks that have a process definition name that has the parameter value as  a substring.
         * @param {string} [executionId] Restrict to tasks that belong to an execution with the given id.
         * @param {string} [caseInstanceId] Restrict to tasks that belong to case instances with the given id.
         * @param {string} [caseInstanceBusinessKey] Restrict to tasks that belong to case instances with the given business key.
         * @param {string} [caseInstanceBusinessKeyLike] Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
         * @param {string} [caseDefinitionId] Restrict to tasks that belong to a case definition with the given id.
         * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
         * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
         * @param {string} [caseDefinitionNameLike] Restrict to tasks that have a case definition name that has the parameter value as a  substring.
         * @param {string} [caseExecutionId] Restrict to tasks that belong to a case execution with the given id.
         * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
         * @param {string} [tenantIdIn] Only include tasks which belong to one of the passed and comma-separated  tenant ids.
         * @param {boolean} [withoutTenantId] Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
         * @param {string} [assignee] Restrict to tasks that the given user is assigned to.
         * @param {string} [assigneeExpression] Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeLike] Restrict to tasks that have an assignee that has the parameter  value as a substring.
         * @param {string} [assigneeLikeExpression] Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeIn] Only include tasks which are assigned to one of the passed and  comma-separated user ids.
         * @param {string} [owner] Restrict to tasks that the given user owns.
         * @param {string} [ownerExpression] Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateGroup] Only include tasks that are offered to the given group.
         * @param {string} [candidateGroupExpression] Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateUser] Only include tasks that are offered to the given user or to one of his groups.
         * @param {string} [candidateUserExpression] Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {boolean} [includeAssignedTasks] Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
         * @param {string} [involvedUser] Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
         * @param {string} [involvedUserExpression] Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
         * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
         * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
         * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
         * @param {string} [taskDefinitionKeyLike] Restrict to tasks that have a key that has the parameter value as a substring.
         * @param {string} [name] Restrict to tasks that have the given name.
         * @param {string} [nameNotEqual] Restrict to tasks that do not have the given name.
         * @param {string} [nameLike] Restrict to tasks that have a name with the given parameter value as substring.
         * @param {string} [nameNotLike] Restrict to tasks that do not have a name with the given parameter value as substring.
         * @param {string} [description] Restrict to tasks that have the given description.
         * @param {string} [descriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
         * @param {number} [priority] Restrict to tasks that have the given priority.
         * @param {number} [maxPriority] Restrict to tasks that have a lower or equal priority.
         * @param {number} [minPriority] Restrict to tasks that have a higher or equal priority.
         * @param {string} [dueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [dueDateExpression] Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
         * @param {string} [dueAfterExpression] Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
         * @param {string} [dueBeforeExpression] Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [followUpDateExpression] Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
         * @param {string} [followUpAfterExpression] Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
         * @param {string} [followUpBeforeExpression] Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBeforeOrNotExistent] Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
         * @param {string} [followUpBeforeOrNotExistentExpression] Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdOn] Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
         * @param {string} [createdOnExpression] Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdAfter] Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [createdAfterExpression] Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdBefore] Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
         * @param {string} [createdBeforeExpression] Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {'PENDING' | 'RESOLVED'} [delegationState] Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
         * @param {string} [candidateGroups] Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
         * @param {string} [candidateGroupsExpression] Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
         * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withCandidateUsers] Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateUsers] Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [caseInstanceVariables] Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
         * @param {string} [parentTaskId] Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksCount(processInstanceId?: string, processInstanceIdIn?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyExpression?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, processInstanceBusinessKeyLikeExpression?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionName?: string, processDefinitionNameLike?: string, executionId?: string, caseInstanceId?: string, caseInstanceBusinessKey?: string, caseInstanceBusinessKeyLike?: string, caseDefinitionId?: string, caseDefinitionKey?: string, caseDefinitionName?: string, caseDefinitionNameLike?: string, caseExecutionId?: string, activityInstanceIdIn?: string, tenantIdIn?: string, withoutTenantId?: boolean, assignee?: string, assigneeExpression?: string, assigneeLike?: string, assigneeLikeExpression?: string, assigneeIn?: string, owner?: string, ownerExpression?: string, candidateGroup?: string, candidateGroupExpression?: string, candidateUser?: string, candidateUserExpression?: string, includeAssignedTasks?: boolean, involvedUser?: string, involvedUserExpression?: string, assigned?: boolean, unassigned?: boolean, taskDefinitionKey?: string, taskDefinitionKeyIn?: string, taskDefinitionKeyLike?: string, name?: string, nameNotEqual?: string, nameLike?: string, nameNotLike?: string, description?: string, descriptionLike?: string, priority?: number, maxPriority?: number, minPriority?: number, dueDate?: string, dueDateExpression?: string, dueAfter?: string, dueAfterExpression?: string, dueBefore?: string, dueBeforeExpression?: string, followUpDate?: string, followUpDateExpression?: string, followUpAfter?: string, followUpAfterExpression?: string, followUpBefore?: string, followUpBeforeExpression?: string, followUpBeforeOrNotExistent?: string, followUpBeforeOrNotExistentExpression?: string, createdOn?: string, createdOnExpression?: string, createdAfter?: string, createdAfterExpression?: string, createdBefore?: string, createdBeforeExpression?: string, delegationState?: 'PENDING' | 'RESOLVED', candidateGroups?: string, candidateGroupsExpression?: string, withCandidateGroups?: boolean, withoutCandidateGroups?: boolean, withCandidateUsers?: boolean, withoutCandidateUsers?: boolean, active?: boolean, suspended?: boolean, taskVariables?: string, processVariables?: string, caseInstanceVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, parentTaskId?: string, options?: any): AxiosPromise<CountResultDto> {
            return localVarFp.getTasksCount(processInstanceId, processInstanceIdIn, processInstanceBusinessKey, processInstanceBusinessKeyExpression, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, processInstanceBusinessKeyLikeExpression, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionName, processDefinitionNameLike, executionId, caseInstanceId, caseInstanceBusinessKey, caseInstanceBusinessKeyLike, caseDefinitionId, caseDefinitionKey, caseDefinitionName, caseDefinitionNameLike, caseExecutionId, activityInstanceIdIn, tenantIdIn, withoutTenantId, assignee, assigneeExpression, assigneeLike, assigneeLikeExpression, assigneeIn, owner, ownerExpression, candidateGroup, candidateGroupExpression, candidateUser, candidateUserExpression, includeAssignedTasks, involvedUser, involvedUserExpression, assigned, unassigned, taskDefinitionKey, taskDefinitionKeyIn, taskDefinitionKeyLike, name, nameNotEqual, nameLike, nameNotLike, description, descriptionLike, priority, maxPriority, minPriority, dueDate, dueDateExpression, dueAfter, dueAfterExpression, dueBefore, dueBeforeExpression, followUpDate, followUpDateExpression, followUpAfter, followUpAfterExpression, followUpBefore, followUpBeforeExpression, followUpBeforeOrNotExistent, followUpBeforeOrNotExistentExpression, createdOn, createdOnExpression, createdAfter, createdAfterExpression, createdBefore, createdBeforeExpression, delegationState, candidateGroups, candidateGroupsExpression, withCandidateGroups, withoutCandidateGroups, withCandidateUsers, withoutCandidateUsers, active, suspended, taskVariables, processVariables, caseInstanceVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, parentTaskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Reports a business error in the context of a running task by id. The error code must be specified to identify the BPMN error handler. See the documentation for [Reporting Bpmn Error](https://docs.camunda.org/manual/7.13/reference/bpmn20/tasks/user-task/#reporting-bpmn-error) in User Tasks.
         * @param {string} id The id of the task a BPMN error is reported for.
         * @param {TaskBpmnErrorDto} [taskBpmnErrorDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleBpmnError(id: string, taskBpmnErrorDto?: TaskBpmnErrorDto, options?: any): AxiosPromise<void> {
            return localVarFp.handleBpmnError(id, taskBpmnErrorDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Reports an escalation in the context of a running task by id. The escalation code must be specified to identify the escalation handler. See the documentation for [Reporting Bpmn Escalation](https://docs.camunda.org/manual/7.13/reference/bpmn20/tasks/user-task/#reporting-bpmn-escalation) in User Tasks.
         * @param {string} id The id of the task in which context a BPMN escalation is reported.
         * @param {TaskEscalationDto} [taskEscalationDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleEscalation(id: string, taskEscalationDto?: TaskEscalationDto, options?: any): AxiosPromise<void> {
            return localVarFp.handleEscalation(id, taskEscalationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for tasks that fulfill a given filter. This method is slightly more powerful than the [Get Tasks](https://docs.camunda.org/manual/7.13/reference/rest/task/get-query/) method because it allows filtering by multiple process or task variables of types `String`, `Number` or `Boolean`. The size of the result set can be retrieved by using the [Get Task Count (POST)](https://docs.camunda.org/manual/7.13/reference/rest/task/post-query-count/) method.  **Security Consideration**: There are several parameters (such as `assigneeExpression`) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) in the user guide for details.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {TaskQueryDto} [taskQueryDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryTasks(firstResult?: number, maxResults?: number, taskQueryDto?: TaskQueryDto, options?: any): AxiosPromise<Array<TaskDto>> {
            return localVarFp.queryTasks(firstResult, maxResults, taskQueryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the number of tasks that fulfill the given filter. Corresponds to the size of the result set of the [Get Tasks (POST)](https://docs.camunda.org/manual/7.13/reference/rest/task/post-query/) method and takes the same parameters.  **Security Consideration**: There are several parameters (such as `assigneeExpression`) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) in the user guide for details.
         * @param {TaskQueryDto} [taskQueryDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryTasksCount(taskQueryDto?: TaskQueryDto, options?: any): AxiosPromise<CountResultDto> {
            return localVarFp.queryTasksCount(taskQueryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Resolves a task and updates execution variables.  Resolving a task marks that the assignee is done with the task delegated to them, and that it can be sent back to the owner. Can only be executed when the task has been delegated. The assignee will be set to the owner, who performed the delegation.
         * @param {string} id The id of the task to resolve.
         * @param {CompleteTaskDto} [completeTaskDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolve(id: string, completeTaskDto?: CompleteTaskDto, options?: any): AxiosPromise<void> {
            return localVarFp.resolve(id, completeTaskDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes the assignee of a task to a specific user.  **Note:** The difference with the [Claim Task](https://docs.camunda.org/manual/7.13/reference/rest/task/post-claim/) method is that this method does not check if the task already has a user assigned to it.
         * @param {string} id The id of the task to set the assignee for.
         * @param {UserIdDto} [userIdDto] Provide the id of the user that will be the assignee of the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAssignee(id: string, userIdDto?: UserIdDto, options?: any): AxiosPromise<void> {
            return localVarFp.setAssignee(id, userIdDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Completes a task and updates process variables using a form submit. There are two difference between this method and the `complete` method:  * If the task is in state `PENDING` - i.e., has been delegated before, it is not completed but resolved. Otherwise it will be completed. * If the task has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See the [Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/_index/#generated-task-forms) section of the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/) for more information.
         * @param {string} id The id of the task to submit the form for.
         * @param {CompleteTaskDto} [completeTaskDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submit(id: string, completeTaskDto?: CompleteTaskDto, options?: any): AxiosPromise<{ [key: string]: VariableValueDto; }> {
            return localVarFp.submit(id, completeTaskDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Resets a task\'s assignee. If successful, the task is not assigned to a user.
         * @param {string} id The id of the task to unclaim.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unclaim(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.unclaim(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a task.
         * @param {string} id The id of the task to be updated.
         * @param {TaskDto} [taskDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask(id: string, taskDto?: TaskDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateTask(id, taskDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TaskApi - object-oriented interface
 * @export
 * @class TaskApi
 * @extends {BaseAPI}
 */
export class TaskApi extends BaseAPI {
    /**
     * Claims a task for a specific user.  **Note:** The difference with the [Set Assignee](https://docs.camunda.org/manual/7.13/reference/rest/task/post-assignee/) method is that here a check is performed to see if the task already has a user assigned to it.
     * @param {string} id The id of the task to claim.
     * @param {UserIdDto} [userIdDto] Provide the id of the user that claims the task.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public claim(id: string, userIdDto?: UserIdDto, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).claim(id, userIdDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Completes a task and updates process variables.
     * @param {string} id The id of the task to complete.
     * @param {CompleteTaskDto} [completeTaskDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public complete(id: string, completeTaskDto?: CompleteTaskDto, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).complete(id, completeTaskDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new task.
     * @param {TaskDto} [taskDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public createTask(taskDto?: TaskDto, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).createTask(taskDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delegates a task to another user.
     * @param {string} id The id of the task to delegate.
     * @param {UserIdDto} [userIdDto] Provide the id of the user that the task should be delegated to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public delegateTask(id: string, userIdDto?: UserIdDto, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).delegateTask(id, userIdDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a task by id.
     * @param {string} id The id of the task to be removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public deleteTask(id: string, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).deleteTask(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the deployed form that is referenced from a given task. For further information please refer to the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
     * @param {string} id The id of the task to get the deployed form for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getDeployedForm(id: string, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).getDeployedForm(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the form key for a task. The form key corresponds to the `FormData#formKey` property in the engine. This key can be used to do task-specific form rendering in client applications. Additionally, the context path of the containing process application is returned.
     * @param {string} id The id of the task to retrieve the form for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getForm(id: string, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).getForm(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the form variables for a task. The form variables take form data specified on the task into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
     * @param {string} id The id of the task to retrieve the variables for.
     * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
     * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getFormVariables(id: string, variableNames?: string, deserializeValues?: boolean, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).getFormVariables(id, variableNames, deserializeValues, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the rendered form for a task. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
     * @param {string} id The id of the task to get the rendered form for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getRenderedForm(id: string, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).getRenderedForm(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a task by id.
     * @param {string} id The id of the task to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getTask(id: string, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).getTask(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Queries for tasks that fulfill a given filter. The size of the result set can be retrieved by using the Get Task Count method.  **Security Consideration:** There are several query parameters (such as assigneeExpression) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) for custom code in the user guide for details.
     * @param {string} [processInstanceId] Restrict to tasks that belong to process instances with the given id.
     * @param {string} [processInstanceIdIn] Restrict to tasks that belong to process instances with the given ids.
     * @param {string} [processInstanceBusinessKey] Restrict to tasks that belong to process instances with the given business key.
     * @param {string} [processInstanceBusinessKeyExpression] Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
     * @param {string} [processInstanceBusinessKeyIn] Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
     * @param {string} [processInstanceBusinessKeyLike] Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
     * @param {string} [processInstanceBusinessKeyLikeExpression] Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [processDefinitionId] Restrict to tasks that belong to a process definition with the given id.
     * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
     * @param {string} [processDefinitionKeyIn] Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
     * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
     * @param {string} [processDefinitionNameLike] Restrict to tasks that have a process definition name that has the parameter value as  a substring.
     * @param {string} [executionId] Restrict to tasks that belong to an execution with the given id.
     * @param {string} [caseInstanceId] Restrict to tasks that belong to case instances with the given id.
     * @param {string} [caseInstanceBusinessKey] Restrict to tasks that belong to case instances with the given business key.
     * @param {string} [caseInstanceBusinessKeyLike] Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
     * @param {string} [caseDefinitionId] Restrict to tasks that belong to a case definition with the given id.
     * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
     * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
     * @param {string} [caseDefinitionNameLike] Restrict to tasks that have a case definition name that has the parameter value as a  substring.
     * @param {string} [caseExecutionId] Restrict to tasks that belong to a case execution with the given id.
     * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
     * @param {string} [tenantIdIn] Only include tasks which belong to one of the passed and comma-separated  tenant ids.
     * @param {boolean} [withoutTenantId] Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
     * @param {string} [assignee] Restrict to tasks that the given user is assigned to.
     * @param {string} [assigneeExpression] Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [assigneeLike] Restrict to tasks that have an assignee that has the parameter  value as a substring.
     * @param {string} [assigneeLikeExpression] Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [assigneeIn] Only include tasks which are assigned to one of the passed and  comma-separated user ids.
     * @param {string} [owner] Restrict to tasks that the given user owns.
     * @param {string} [ownerExpression] Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [candidateGroup] Only include tasks that are offered to the given group.
     * @param {string} [candidateGroupExpression] Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [candidateUser] Only include tasks that are offered to the given user or to one of his groups.
     * @param {string} [candidateUserExpression] Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {boolean} [includeAssignedTasks] Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
     * @param {string} [involvedUser] Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
     * @param {string} [involvedUserExpression] Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
     * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
     * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
     * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
     * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
     * @param {string} [taskDefinitionKeyLike] Restrict to tasks that have a key that has the parameter value as a substring.
     * @param {string} [name] Restrict to tasks that have the given name.
     * @param {string} [nameNotEqual] Restrict to tasks that do not have the given name.
     * @param {string} [nameLike] Restrict to tasks that have a name with the given parameter value as substring.
     * @param {string} [nameNotLike] Restrict to tasks that do not have a name with the given parameter value as substring.
     * @param {string} [description] Restrict to tasks that have the given description.
     * @param {string} [descriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
     * @param {number} [priority] Restrict to tasks that have the given priority.
     * @param {number} [maxPriority] Restrict to tasks that have a lower or equal priority.
     * @param {number} [minPriority] Restrict to tasks that have a higher or equal priority.
     * @param {string} [dueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
     * @param {string} [dueDateExpression] Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [dueAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
     * @param {string} [dueAfterExpression] Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [dueBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
     * @param {string} [dueBeforeExpression] Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [followUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
     * @param {string} [followUpDateExpression] Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [followUpAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
     * @param {string} [followUpAfterExpression] Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [followUpBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
     * @param {string} [followUpBeforeExpression] Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [followUpBeforeOrNotExistent] Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
     * @param {string} [followUpBeforeOrNotExistentExpression] Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [createdOn] Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
     * @param {string} [createdOnExpression] Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [createdAfter] Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
     * @param {string} [createdAfterExpression] Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [createdBefore] Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
     * @param {string} [createdBeforeExpression] Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {'PENDING' | 'RESOLVED'} [delegationState] Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
     * @param {string} [candidateGroups] Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
     * @param {string} [candidateGroupsExpression] Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
     * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [withCandidateUsers] Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [withoutCandidateUsers] Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {string} [caseInstanceVariables] Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
     * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
     * @param {string} [parentTaskId] Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
     * @param {'instanceId' | 'caseInstanceId' | 'dueDate' | 'executionId' | 'caseExecutionId' | 'assignee' | 'created' | 'description' | 'id' | 'name' | 'nameCaseInsensitive' | 'priority' | 'processVariable' | 'executionVariable' | 'taskVariable' | 'caseExecutionVariable' | 'caseInstanceVariable'} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @param {'asc' | 'desc'} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getTasks(processInstanceId?: string, processInstanceIdIn?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyExpression?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, processInstanceBusinessKeyLikeExpression?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionName?: string, processDefinitionNameLike?: string, executionId?: string, caseInstanceId?: string, caseInstanceBusinessKey?: string, caseInstanceBusinessKeyLike?: string, caseDefinitionId?: string, caseDefinitionKey?: string, caseDefinitionName?: string, caseDefinitionNameLike?: string, caseExecutionId?: string, activityInstanceIdIn?: string, tenantIdIn?: string, withoutTenantId?: boolean, assignee?: string, assigneeExpression?: string, assigneeLike?: string, assigneeLikeExpression?: string, assigneeIn?: string, owner?: string, ownerExpression?: string, candidateGroup?: string, candidateGroupExpression?: string, candidateUser?: string, candidateUserExpression?: string, includeAssignedTasks?: boolean, involvedUser?: string, involvedUserExpression?: string, assigned?: boolean, unassigned?: boolean, taskDefinitionKey?: string, taskDefinitionKeyIn?: string, taskDefinitionKeyLike?: string, name?: string, nameNotEqual?: string, nameLike?: string, nameNotLike?: string, description?: string, descriptionLike?: string, priority?: number, maxPriority?: number, minPriority?: number, dueDate?: string, dueDateExpression?: string, dueAfter?: string, dueAfterExpression?: string, dueBefore?: string, dueBeforeExpression?: string, followUpDate?: string, followUpDateExpression?: string, followUpAfter?: string, followUpAfterExpression?: string, followUpBefore?: string, followUpBeforeExpression?: string, followUpBeforeOrNotExistent?: string, followUpBeforeOrNotExistentExpression?: string, createdOn?: string, createdOnExpression?: string, createdAfter?: string, createdAfterExpression?: string, createdBefore?: string, createdBeforeExpression?: string, delegationState?: 'PENDING' | 'RESOLVED', candidateGroups?: string, candidateGroupsExpression?: string, withCandidateGroups?: boolean, withoutCandidateGroups?: boolean, withCandidateUsers?: boolean, withoutCandidateUsers?: boolean, active?: boolean, suspended?: boolean, taskVariables?: string, processVariables?: string, caseInstanceVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, parentTaskId?: string, sortBy?: 'instanceId' | 'caseInstanceId' | 'dueDate' | 'executionId' | 'caseExecutionId' | 'assignee' | 'created' | 'description' | 'id' | 'name' | 'nameCaseInsensitive' | 'priority' | 'processVariable' | 'executionVariable' | 'taskVariable' | 'caseExecutionVariable' | 'caseInstanceVariable', sortOrder?: 'asc' | 'desc', firstResult?: number, maxResults?: number, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).getTasks(processInstanceId, processInstanceIdIn, processInstanceBusinessKey, processInstanceBusinessKeyExpression, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, processInstanceBusinessKeyLikeExpression, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionName, processDefinitionNameLike, executionId, caseInstanceId, caseInstanceBusinessKey, caseInstanceBusinessKeyLike, caseDefinitionId, caseDefinitionKey, caseDefinitionName, caseDefinitionNameLike, caseExecutionId, activityInstanceIdIn, tenantIdIn, withoutTenantId, assignee, assigneeExpression, assigneeLike, assigneeLikeExpression, assigneeIn, owner, ownerExpression, candidateGroup, candidateGroupExpression, candidateUser, candidateUserExpression, includeAssignedTasks, involvedUser, involvedUserExpression, assigned, unassigned, taskDefinitionKey, taskDefinitionKeyIn, taskDefinitionKeyLike, name, nameNotEqual, nameLike, nameNotLike, description, descriptionLike, priority, maxPriority, minPriority, dueDate, dueDateExpression, dueAfter, dueAfterExpression, dueBefore, dueBeforeExpression, followUpDate, followUpDateExpression, followUpAfter, followUpAfterExpression, followUpBefore, followUpBeforeExpression, followUpBeforeOrNotExistent, followUpBeforeOrNotExistentExpression, createdOn, createdOnExpression, createdAfter, createdAfterExpression, createdBefore, createdBeforeExpression, delegationState, candidateGroups, candidateGroupsExpression, withCandidateGroups, withoutCandidateGroups, withCandidateUsers, withoutCandidateUsers, active, suspended, taskVariables, processVariables, caseInstanceVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, parentTaskId, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the number of tasks that fulfill a provided filter. Corresponds to the size of the result set when using the [Get Tasks](https://docs.camunda.org/manual/7.13/reference/rest/task/) method.  **Security Consideration:** There are several query parameters (such as assigneeExpression) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) for custom code in the user guide for details.
     * @param {string} [processInstanceId] Restrict to tasks that belong to process instances with the given id.
     * @param {string} [processInstanceIdIn] Restrict to tasks that belong to process instances with the given ids.
     * @param {string} [processInstanceBusinessKey] Restrict to tasks that belong to process instances with the given business key.
     * @param {string} [processInstanceBusinessKeyExpression] Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
     * @param {string} [processInstanceBusinessKeyIn] Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
     * @param {string} [processInstanceBusinessKeyLike] Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
     * @param {string} [processInstanceBusinessKeyLikeExpression] Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [processDefinitionId] Restrict to tasks that belong to a process definition with the given id.
     * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
     * @param {string} [processDefinitionKeyIn] Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
     * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
     * @param {string} [processDefinitionNameLike] Restrict to tasks that have a process definition name that has the parameter value as  a substring.
     * @param {string} [executionId] Restrict to tasks that belong to an execution with the given id.
     * @param {string} [caseInstanceId] Restrict to tasks that belong to case instances with the given id.
     * @param {string} [caseInstanceBusinessKey] Restrict to tasks that belong to case instances with the given business key.
     * @param {string} [caseInstanceBusinessKeyLike] Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
     * @param {string} [caseDefinitionId] Restrict to tasks that belong to a case definition with the given id.
     * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
     * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
     * @param {string} [caseDefinitionNameLike] Restrict to tasks that have a case definition name that has the parameter value as a  substring.
     * @param {string} [caseExecutionId] Restrict to tasks that belong to a case execution with the given id.
     * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
     * @param {string} [tenantIdIn] Only include tasks which belong to one of the passed and comma-separated  tenant ids.
     * @param {boolean} [withoutTenantId] Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
     * @param {string} [assignee] Restrict to tasks that the given user is assigned to.
     * @param {string} [assigneeExpression] Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [assigneeLike] Restrict to tasks that have an assignee that has the parameter  value as a substring.
     * @param {string} [assigneeLikeExpression] Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [assigneeIn] Only include tasks which are assigned to one of the passed and  comma-separated user ids.
     * @param {string} [owner] Restrict to tasks that the given user owns.
     * @param {string} [ownerExpression] Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [candidateGroup] Only include tasks that are offered to the given group.
     * @param {string} [candidateGroupExpression] Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [candidateUser] Only include tasks that are offered to the given user or to one of his groups.
     * @param {string} [candidateUserExpression] Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {boolean} [includeAssignedTasks] Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
     * @param {string} [involvedUser] Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
     * @param {string} [involvedUserExpression] Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
     * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
     * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
     * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
     * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
     * @param {string} [taskDefinitionKeyLike] Restrict to tasks that have a key that has the parameter value as a substring.
     * @param {string} [name] Restrict to tasks that have the given name.
     * @param {string} [nameNotEqual] Restrict to tasks that do not have the given name.
     * @param {string} [nameLike] Restrict to tasks that have a name with the given parameter value as substring.
     * @param {string} [nameNotLike] Restrict to tasks that do not have a name with the given parameter value as substring.
     * @param {string} [description] Restrict to tasks that have the given description.
     * @param {string} [descriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
     * @param {number} [priority] Restrict to tasks that have the given priority.
     * @param {number} [maxPriority] Restrict to tasks that have a lower or equal priority.
     * @param {number} [minPriority] Restrict to tasks that have a higher or equal priority.
     * @param {string} [dueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
     * @param {string} [dueDateExpression] Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [dueAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
     * @param {string} [dueAfterExpression] Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [dueBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
     * @param {string} [dueBeforeExpression] Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [followUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
     * @param {string} [followUpDateExpression] Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [followUpAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
     * @param {string} [followUpAfterExpression] Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [followUpBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
     * @param {string} [followUpBeforeExpression] Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [followUpBeforeOrNotExistent] Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
     * @param {string} [followUpBeforeOrNotExistentExpression] Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [createdOn] Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
     * @param {string} [createdOnExpression] Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [createdAfter] Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
     * @param {string} [createdAfterExpression] Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [createdBefore] Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
     * @param {string} [createdBeforeExpression] Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {'PENDING' | 'RESOLVED'} [delegationState] Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
     * @param {string} [candidateGroups] Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
     * @param {string} [candidateGroupsExpression] Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
     * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [withCandidateUsers] Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [withoutCandidateUsers] Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {string} [caseInstanceVariables] Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
     * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
     * @param {string} [parentTaskId] Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getTasksCount(processInstanceId?: string, processInstanceIdIn?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyExpression?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, processInstanceBusinessKeyLikeExpression?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionName?: string, processDefinitionNameLike?: string, executionId?: string, caseInstanceId?: string, caseInstanceBusinessKey?: string, caseInstanceBusinessKeyLike?: string, caseDefinitionId?: string, caseDefinitionKey?: string, caseDefinitionName?: string, caseDefinitionNameLike?: string, caseExecutionId?: string, activityInstanceIdIn?: string, tenantIdIn?: string, withoutTenantId?: boolean, assignee?: string, assigneeExpression?: string, assigneeLike?: string, assigneeLikeExpression?: string, assigneeIn?: string, owner?: string, ownerExpression?: string, candidateGroup?: string, candidateGroupExpression?: string, candidateUser?: string, candidateUserExpression?: string, includeAssignedTasks?: boolean, involvedUser?: string, involvedUserExpression?: string, assigned?: boolean, unassigned?: boolean, taskDefinitionKey?: string, taskDefinitionKeyIn?: string, taskDefinitionKeyLike?: string, name?: string, nameNotEqual?: string, nameLike?: string, nameNotLike?: string, description?: string, descriptionLike?: string, priority?: number, maxPriority?: number, minPriority?: number, dueDate?: string, dueDateExpression?: string, dueAfter?: string, dueAfterExpression?: string, dueBefore?: string, dueBeforeExpression?: string, followUpDate?: string, followUpDateExpression?: string, followUpAfter?: string, followUpAfterExpression?: string, followUpBefore?: string, followUpBeforeExpression?: string, followUpBeforeOrNotExistent?: string, followUpBeforeOrNotExistentExpression?: string, createdOn?: string, createdOnExpression?: string, createdAfter?: string, createdAfterExpression?: string, createdBefore?: string, createdBeforeExpression?: string, delegationState?: 'PENDING' | 'RESOLVED', candidateGroups?: string, candidateGroupsExpression?: string, withCandidateGroups?: boolean, withoutCandidateGroups?: boolean, withCandidateUsers?: boolean, withoutCandidateUsers?: boolean, active?: boolean, suspended?: boolean, taskVariables?: string, processVariables?: string, caseInstanceVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, parentTaskId?: string, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).getTasksCount(processInstanceId, processInstanceIdIn, processInstanceBusinessKey, processInstanceBusinessKeyExpression, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, processInstanceBusinessKeyLikeExpression, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionName, processDefinitionNameLike, executionId, caseInstanceId, caseInstanceBusinessKey, caseInstanceBusinessKeyLike, caseDefinitionId, caseDefinitionKey, caseDefinitionName, caseDefinitionNameLike, caseExecutionId, activityInstanceIdIn, tenantIdIn, withoutTenantId, assignee, assigneeExpression, assigneeLike, assigneeLikeExpression, assigneeIn, owner, ownerExpression, candidateGroup, candidateGroupExpression, candidateUser, candidateUserExpression, includeAssignedTasks, involvedUser, involvedUserExpression, assigned, unassigned, taskDefinitionKey, taskDefinitionKeyIn, taskDefinitionKeyLike, name, nameNotEqual, nameLike, nameNotLike, description, descriptionLike, priority, maxPriority, minPriority, dueDate, dueDateExpression, dueAfter, dueAfterExpression, dueBefore, dueBeforeExpression, followUpDate, followUpDateExpression, followUpAfter, followUpAfterExpression, followUpBefore, followUpBeforeExpression, followUpBeforeOrNotExistent, followUpBeforeOrNotExistentExpression, createdOn, createdOnExpression, createdAfter, createdAfterExpression, createdBefore, createdBeforeExpression, delegationState, candidateGroups, candidateGroupsExpression, withCandidateGroups, withoutCandidateGroups, withCandidateUsers, withoutCandidateUsers, active, suspended, taskVariables, processVariables, caseInstanceVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, parentTaskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reports a business error in the context of a running task by id. The error code must be specified to identify the BPMN error handler. See the documentation for [Reporting Bpmn Error](https://docs.camunda.org/manual/7.13/reference/bpmn20/tasks/user-task/#reporting-bpmn-error) in User Tasks.
     * @param {string} id The id of the task a BPMN error is reported for.
     * @param {TaskBpmnErrorDto} [taskBpmnErrorDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public handleBpmnError(id: string, taskBpmnErrorDto?: TaskBpmnErrorDto, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).handleBpmnError(id, taskBpmnErrorDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reports an escalation in the context of a running task by id. The escalation code must be specified to identify the escalation handler. See the documentation for [Reporting Bpmn Escalation](https://docs.camunda.org/manual/7.13/reference/bpmn20/tasks/user-task/#reporting-bpmn-escalation) in User Tasks.
     * @param {string} id The id of the task in which context a BPMN escalation is reported.
     * @param {TaskEscalationDto} [taskEscalationDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public handleEscalation(id: string, taskEscalationDto?: TaskEscalationDto, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).handleEscalation(id, taskEscalationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Queries for tasks that fulfill a given filter. This method is slightly more powerful than the [Get Tasks](https://docs.camunda.org/manual/7.13/reference/rest/task/get-query/) method because it allows filtering by multiple process or task variables of types `String`, `Number` or `Boolean`. The size of the result set can be retrieved by using the [Get Task Count (POST)](https://docs.camunda.org/manual/7.13/reference/rest/task/post-query-count/) method.  **Security Consideration**: There are several parameters (such as `assigneeExpression`) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) in the user guide for details.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {TaskQueryDto} [taskQueryDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public queryTasks(firstResult?: number, maxResults?: number, taskQueryDto?: TaskQueryDto, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).queryTasks(firstResult, maxResults, taskQueryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the number of tasks that fulfill the given filter. Corresponds to the size of the result set of the [Get Tasks (POST)](https://docs.camunda.org/manual/7.13/reference/rest/task/post-query/) method and takes the same parameters.  **Security Consideration**: There are several parameters (such as `assigneeExpression`) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) in the user guide for details.
     * @param {TaskQueryDto} [taskQueryDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public queryTasksCount(taskQueryDto?: TaskQueryDto, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).queryTasksCount(taskQueryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resolves a task and updates execution variables.  Resolving a task marks that the assignee is done with the task delegated to them, and that it can be sent back to the owner. Can only be executed when the task has been delegated. The assignee will be set to the owner, who performed the delegation.
     * @param {string} id The id of the task to resolve.
     * @param {CompleteTaskDto} [completeTaskDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public resolve(id: string, completeTaskDto?: CompleteTaskDto, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).resolve(id, completeTaskDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes the assignee of a task to a specific user.  **Note:** The difference with the [Claim Task](https://docs.camunda.org/manual/7.13/reference/rest/task/post-claim/) method is that this method does not check if the task already has a user assigned to it.
     * @param {string} id The id of the task to set the assignee for.
     * @param {UserIdDto} [userIdDto] Provide the id of the user that will be the assignee of the task.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public setAssignee(id: string, userIdDto?: UserIdDto, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).setAssignee(id, userIdDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Completes a task and updates process variables using a form submit. There are two difference between this method and the `complete` method:  * If the task is in state `PENDING` - i.e., has been delegated before, it is not completed but resolved. Otherwise it will be completed. * If the task has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See the [Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/_index/#generated-task-forms) section of the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/) for more information.
     * @param {string} id The id of the task to submit the form for.
     * @param {CompleteTaskDto} [completeTaskDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public submit(id: string, completeTaskDto?: CompleteTaskDto, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).submit(id, completeTaskDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resets a task\'s assignee. If successful, the task is not assigned to a user.
     * @param {string} id The id of the task to unclaim.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public unclaim(id: string, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).unclaim(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a task.
     * @param {string} id The id of the task to be updated.
     * @param {TaskDto} [taskDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public updateTask(id: string, taskDto?: TaskDto, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).updateTask(id, taskDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TaskAttachmentApi - axios parameter creator
 * @export
 */
export const TaskAttachmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates an attachment for a task.
         * @param {string} id The id of the task to add the attachment to.
         * @param {string} [attachmentName] The name of the attachment.
         * @param {string} [attachmentDescription] The description of the attachment.
         * @param {string} [attachmentType] The type of the attachment.
         * @param {string} [url] The url to the remote content of the attachment.
         * @param {any} [content] The content of the attachment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAttachment: async (id: string, attachmentName?: string, attachmentDescription?: string, attachmentType?: string, url?: string, content?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addAttachment', 'id', id)
            const localVarPath = `/task/{id}/attachment/create`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (attachmentName !== undefined) { 
                localVarFormParams.append('attachment-name', attachmentName as any);
            }
    
            if (attachmentDescription !== undefined) { 
                localVarFormParams.append('attachment-description', attachmentDescription as any);
            }
    
            if (attachmentType !== undefined) { 
                localVarFormParams.append('attachment-type', attachmentType as any);
            }
    
            if (url !== undefined) { 
                localVarFormParams.append('url', url as any);
            }
    
            if (content !== undefined) { 
                localVarFormParams.append('content', content as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes an attachment from a task by id.
         * @param {string} id The id of the task.
         * @param {string} attachmentId The id of the attachment to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttachment: async (id: string, attachmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAttachment', 'id', id)
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('deleteAttachment', 'attachmentId', attachmentId)
            const localVarPath = `/task/{id}/attachment/{attachmentId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"attachmentId"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a task attachment by task id and attachment id.
         * @param {string} id The id of the task.
         * @param {string} attachmentId The id of the attachment to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachment: async (id: string, attachmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAttachment', 'id', id)
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('getAttachment', 'attachmentId', attachmentId)
            const localVarPath = `/task/{id}/attachment/{attachmentId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"attachmentId"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the binary content of a task attachment by task id and attachment id.
         * @param {string} id The id of the task.
         * @param {string} attachmentId The id of the attachment to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentData: async (id: string, attachmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAttachmentData', 'id', id)
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('getAttachmentData', 'attachmentId', attachmentId)
            const localVarPath = `/task/{id}/attachment/{attachmentId}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"attachmentId"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the attachments for a task.
         * @param {string} id The id of the task to retrieve the attachments for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachments: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAttachments', 'id', id)
            const localVarPath = `/task/{id}/attachment`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskAttachmentApi - functional programming interface
 * @export
 */
export const TaskAttachmentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaskAttachmentApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates an attachment for a task.
         * @param {string} id The id of the task to add the attachment to.
         * @param {string} [attachmentName] The name of the attachment.
         * @param {string} [attachmentDescription] The description of the attachment.
         * @param {string} [attachmentType] The type of the attachment.
         * @param {string} [url] The url to the remote content of the attachment.
         * @param {any} [content] The content of the attachment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAttachment(id: string, attachmentName?: string, attachmentDescription?: string, attachmentType?: string, url?: string, content?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAttachment(id, attachmentName, attachmentDescription, attachmentType, url, content, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes an attachment from a task by id.
         * @param {string} id The id of the task.
         * @param {string} attachmentId The id of the attachment to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAttachment(id: string, attachmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAttachment(id, attachmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a task attachment by task id and attachment id.
         * @param {string} id The id of the task.
         * @param {string} attachmentId The id of the attachment to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAttachment(id: string, attachmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAttachment(id, attachmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the binary content of a task attachment by task id and attachment id.
         * @param {string} id The id of the task.
         * @param {string} attachmentId The id of the attachment to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAttachmentData(id: string, attachmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAttachmentData(id, attachmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the attachments for a task.
         * @param {string} id The id of the task to retrieve the attachments for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAttachments(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AttachmentDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAttachments(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TaskAttachmentApi - factory interface
 * @export
 */
export const TaskAttachmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaskAttachmentApiFp(configuration)
    return {
        /**
         * Creates an attachment for a task.
         * @param {string} id The id of the task to add the attachment to.
         * @param {string} [attachmentName] The name of the attachment.
         * @param {string} [attachmentDescription] The description of the attachment.
         * @param {string} [attachmentType] The type of the attachment.
         * @param {string} [url] The url to the remote content of the attachment.
         * @param {any} [content] The content of the attachment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAttachment(id: string, attachmentName?: string, attachmentDescription?: string, attachmentType?: string, url?: string, content?: any, options?: any): AxiosPromise<AttachmentDto> {
            return localVarFp.addAttachment(id, attachmentName, attachmentDescription, attachmentType, url, content, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes an attachment from a task by id.
         * @param {string} id The id of the task.
         * @param {string} attachmentId The id of the attachment to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttachment(id: string, attachmentId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAttachment(id, attachmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a task attachment by task id and attachment id.
         * @param {string} id The id of the task.
         * @param {string} attachmentId The id of the attachment to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachment(id: string, attachmentId: string, options?: any): AxiosPromise<AttachmentDto> {
            return localVarFp.getAttachment(id, attachmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the binary content of a task attachment by task id and attachment id.
         * @param {string} id The id of the task.
         * @param {string} attachmentId The id of the attachment to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentData(id: string, attachmentId: string, options?: any): AxiosPromise<any> {
            return localVarFp.getAttachmentData(id, attachmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the attachments for a task.
         * @param {string} id The id of the task to retrieve the attachments for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachments(id: string, options?: any): AxiosPromise<Array<AttachmentDto>> {
            return localVarFp.getAttachments(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TaskAttachmentApi - object-oriented interface
 * @export
 * @class TaskAttachmentApi
 * @extends {BaseAPI}
 */
export class TaskAttachmentApi extends BaseAPI {
    /**
     * Creates an attachment for a task.
     * @param {string} id The id of the task to add the attachment to.
     * @param {string} [attachmentName] The name of the attachment.
     * @param {string} [attachmentDescription] The description of the attachment.
     * @param {string} [attachmentType] The type of the attachment.
     * @param {string} [url] The url to the remote content of the attachment.
     * @param {any} [content] The content of the attachment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskAttachmentApi
     */
    public addAttachment(id: string, attachmentName?: string, attachmentDescription?: string, attachmentType?: string, url?: string, content?: any, options?: AxiosRequestConfig) {
        return TaskAttachmentApiFp(this.configuration).addAttachment(id, attachmentName, attachmentDescription, attachmentType, url, content, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes an attachment from a task by id.
     * @param {string} id The id of the task.
     * @param {string} attachmentId The id of the attachment to be removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskAttachmentApi
     */
    public deleteAttachment(id: string, attachmentId: string, options?: AxiosRequestConfig) {
        return TaskAttachmentApiFp(this.configuration).deleteAttachment(id, attachmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a task attachment by task id and attachment id.
     * @param {string} id The id of the task.
     * @param {string} attachmentId The id of the attachment to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskAttachmentApi
     */
    public getAttachment(id: string, attachmentId: string, options?: AxiosRequestConfig) {
        return TaskAttachmentApiFp(this.configuration).getAttachment(id, attachmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the binary content of a task attachment by task id and attachment id.
     * @param {string} id The id of the task.
     * @param {string} attachmentId The id of the attachment to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskAttachmentApi
     */
    public getAttachmentData(id: string, attachmentId: string, options?: AxiosRequestConfig) {
        return TaskAttachmentApiFp(this.configuration).getAttachmentData(id, attachmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the attachments for a task.
     * @param {string} id The id of the task to retrieve the attachments for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskAttachmentApi
     */
    public getAttachments(id: string, options?: AxiosRequestConfig) {
        return TaskAttachmentApiFp(this.configuration).getAttachments(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TaskCommentApi - axios parameter creator
 * @export
 */
export const TaskCommentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a comment for a task by id.
         * @param {string} id The id of the task to add the comment to.
         * @param {CommentDto} [commentDto] **Note:** Only the &#x60;message&#x60; property will be used. Every other property passed to this endpoint will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComment: async (id: string, commentDto?: CommentDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createComment', 'id', id)
            const localVarPath = `/task/{id}/comment/create`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a task comment by task id and comment id.
         * @param {string} id The id of the task.
         * @param {string} commentId The id of the comment to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComment: async (id: string, commentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getComment', 'id', id)
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('getComment', 'commentId', commentId)
            const localVarPath = `/task/{id}/comment/{commentId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the comments for a task by id.
         * @param {string} id The id of the task to retrieve the comments for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComments: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getComments', 'id', id)
            const localVarPath = `/task/{id}/comment`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskCommentApi - functional programming interface
 * @export
 */
export const TaskCommentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaskCommentApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a comment for a task by id.
         * @param {string} id The id of the task to add the comment to.
         * @param {CommentDto} [commentDto] **Note:** Only the &#x60;message&#x60; property will be used. Every other property passed to this endpoint will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createComment(id: string, commentDto?: CommentDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createComment(id, commentDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a task comment by task id and comment id.
         * @param {string} id The id of the task.
         * @param {string} commentId The id of the comment to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getComment(id: string, commentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getComment(id, commentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the comments for a task by id.
         * @param {string} id The id of the task to retrieve the comments for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getComments(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CommentDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getComments(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TaskCommentApi - factory interface
 * @export
 */
export const TaskCommentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaskCommentApiFp(configuration)
    return {
        /**
         * Creates a comment for a task by id.
         * @param {string} id The id of the task to add the comment to.
         * @param {CommentDto} [commentDto] **Note:** Only the &#x60;message&#x60; property will be used. Every other property passed to this endpoint will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComment(id: string, commentDto?: CommentDto, options?: any): AxiosPromise<CommentDto> {
            return localVarFp.createComment(id, commentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a task comment by task id and comment id.
         * @param {string} id The id of the task.
         * @param {string} commentId The id of the comment to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComment(id: string, commentId: string, options?: any): AxiosPromise<CommentDto> {
            return localVarFp.getComment(id, commentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the comments for a task by id.
         * @param {string} id The id of the task to retrieve the comments for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComments(id: string, options?: any): AxiosPromise<Array<CommentDto>> {
            return localVarFp.getComments(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TaskCommentApi - object-oriented interface
 * @export
 * @class TaskCommentApi
 * @extends {BaseAPI}
 */
export class TaskCommentApi extends BaseAPI {
    /**
     * Creates a comment for a task by id.
     * @param {string} id The id of the task to add the comment to.
     * @param {CommentDto} [commentDto] **Note:** Only the &#x60;message&#x60; property will be used. Every other property passed to this endpoint will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskCommentApi
     */
    public createComment(id: string, commentDto?: CommentDto, options?: AxiosRequestConfig) {
        return TaskCommentApiFp(this.configuration).createComment(id, commentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a task comment by task id and comment id.
     * @param {string} id The id of the task.
     * @param {string} commentId The id of the comment to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskCommentApi
     */
    public getComment(id: string, commentId: string, options?: AxiosRequestConfig) {
        return TaskCommentApiFp(this.configuration).getComment(id, commentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the comments for a task by id.
     * @param {string} id The id of the task to retrieve the comments for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskCommentApi
     */
    public getComments(id: string, options?: AxiosRequestConfig) {
        return TaskCommentApiFp(this.configuration).getComments(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TaskIdentityLinkApi - axios parameter creator
 * @export
 */
export const TaskIdentityLinkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds an identity link to a task by id. Can be used to link any user or group to a task and specify a relation.
         * @param {string} id The id of the task to add a link to.
         * @param {IdentityLinkDto} [identityLinkDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addIdentityLink: async (id: string, identityLinkDto?: IdentityLinkDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addIdentityLink', 'id', id)
            const localVarPath = `/task/{id}/identity-links`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identityLinkDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes an identity link from a task by id
         * @param {string} id The id of the task to remove a link from.
         * @param {IdentityLinkDto} [identityLinkDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentityLink: async (id: string, identityLinkDto?: IdentityLinkDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteIdentityLink', 'id', id)
            const localVarPath = `/task/{id}/identity-links/delete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identityLinkDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the identity links for a task by id, which are the users and groups that are in *some* relation to it (including assignee and owner).
         * @param {string} id The id of the task to retrieve the identity links for.
         * @param {string} [type] Filter by the type of links to include.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityLinks: async (id: string, type?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIdentityLinks', 'id', id)
            const localVarPath = `/task/{id}/identity-links`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskIdentityLinkApi - functional programming interface
 * @export
 */
export const TaskIdentityLinkApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaskIdentityLinkApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds an identity link to a task by id. Can be used to link any user or group to a task and specify a relation.
         * @param {string} id The id of the task to add a link to.
         * @param {IdentityLinkDto} [identityLinkDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addIdentityLink(id: string, identityLinkDto?: IdentityLinkDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addIdentityLink(id, identityLinkDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes an identity link from a task by id
         * @param {string} id The id of the task to remove a link from.
         * @param {IdentityLinkDto} [identityLinkDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIdentityLink(id: string, identityLinkDto?: IdentityLinkDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteIdentityLink(id, identityLinkDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the identity links for a task by id, which are the users and groups that are in *some* relation to it (including assignee and owner).
         * @param {string} id The id of the task to retrieve the identity links for.
         * @param {string} [type] Filter by the type of links to include.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityLinks(id: string, type?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentityLinkDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityLinks(id, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TaskIdentityLinkApi - factory interface
 * @export
 */
export const TaskIdentityLinkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaskIdentityLinkApiFp(configuration)
    return {
        /**
         * Adds an identity link to a task by id. Can be used to link any user or group to a task and specify a relation.
         * @param {string} id The id of the task to add a link to.
         * @param {IdentityLinkDto} [identityLinkDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addIdentityLink(id: string, identityLinkDto?: IdentityLinkDto, options?: any): AxiosPromise<void> {
            return localVarFp.addIdentityLink(id, identityLinkDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes an identity link from a task by id
         * @param {string} id The id of the task to remove a link from.
         * @param {IdentityLinkDto} [identityLinkDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentityLink(id: string, identityLinkDto?: IdentityLinkDto, options?: any): AxiosPromise<void> {
            return localVarFp.deleteIdentityLink(id, identityLinkDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the identity links for a task by id, which are the users and groups that are in *some* relation to it (including assignee and owner).
         * @param {string} id The id of the task to retrieve the identity links for.
         * @param {string} [type] Filter by the type of links to include.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityLinks(id: string, type?: string, options?: any): AxiosPromise<Array<IdentityLinkDto>> {
            return localVarFp.getIdentityLinks(id, type, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TaskIdentityLinkApi - object-oriented interface
 * @export
 * @class TaskIdentityLinkApi
 * @extends {BaseAPI}
 */
export class TaskIdentityLinkApi extends BaseAPI {
    /**
     * Adds an identity link to a task by id. Can be used to link any user or group to a task and specify a relation.
     * @param {string} id The id of the task to add a link to.
     * @param {IdentityLinkDto} [identityLinkDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskIdentityLinkApi
     */
    public addIdentityLink(id: string, identityLinkDto?: IdentityLinkDto, options?: AxiosRequestConfig) {
        return TaskIdentityLinkApiFp(this.configuration).addIdentityLink(id, identityLinkDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes an identity link from a task by id
     * @param {string} id The id of the task to remove a link from.
     * @param {IdentityLinkDto} [identityLinkDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskIdentityLinkApi
     */
    public deleteIdentityLink(id: string, identityLinkDto?: IdentityLinkDto, options?: AxiosRequestConfig) {
        return TaskIdentityLinkApiFp(this.configuration).deleteIdentityLink(id, identityLinkDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the identity links for a task by id, which are the users and groups that are in *some* relation to it (including assignee and owner).
     * @param {string} id The id of the task to retrieve the identity links for.
     * @param {string} [type] Filter by the type of links to include.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskIdentityLinkApi
     */
    public getIdentityLinks(id: string, type?: string, options?: AxiosRequestConfig) {
        return TaskIdentityLinkApiFp(this.configuration).getIdentityLinks(id, type, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TaskLocalVariableApi - axios parameter creator
 * @export
 */
export const TaskLocalVariableApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Removes a local variable from a task by id.
         * @param {string} id The id of the task to delete the variable from.
         * @param {string} varName The name of the variable to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaskLocalVariable: async (id: string, varName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTaskLocalVariable', 'id', id)
            // verify required parameter 'varName' is not null or undefined
            assertParamExists('deleteTaskLocalVariable', 'varName', varName)
            const localVarPath = `/task/{id}/localVariables/{varName}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a variable from the context of a given task by id.
         * @param {string} id The id of the task to retrieve the variable from.
         * @param {string} varName The name of the variable to get
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskLocalVariable: async (id: string, varName: string, deserializeValue?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTaskLocalVariable', 'id', id)
            // verify required parameter 'varName' is not null or undefined
            assertParamExists('getTaskLocalVariable', 'varName', varName)
            const localVarPath = `/task/{id}/localVariables/{varName}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (deserializeValue !== undefined) {
                localVarQueryParameter['deserializeValue'] = deserializeValue;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a binary variable from the context of a given task by id. Applicable for byte array and file variables.
         * @param {string} id The id of the task to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskLocalVariableBinary: async (id: string, varName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTaskLocalVariableBinary', 'id', id)
            // verify required parameter 'varName' is not null or undefined
            assertParamExists('getTaskLocalVariableBinary', 'varName', varName)
            const localVarPath = `/task/{id}/localVariables/{varName}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all variables of a given task by id.
         * @param {string} id The id of the task to retrieve the variables from.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskLocalVariables: async (id: string, deserializeValues?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTaskLocalVariables', 'id', id)
            const localVarPath = `/task/{id}/localVariables`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (deserializeValues !== undefined) {
                localVarQueryParameter['deserializeValues'] = deserializeValues;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates or deletes the variables in the context of a task. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
         * @param {string} id The id of the task to set variables for.
         * @param {PatchVariablesDto} [patchVariablesDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyTaskLocalVariables: async (id: string, patchVariablesDto?: PatchVariablesDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('modifyTaskLocalVariables', 'id', id)
            const localVarPath = `/task/{id}/localVariables`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchVariablesDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets a variable in the context of a given task.
         * @param {string} id The id of the task to set the variable for.
         * @param {string} varName The name of the variable to set.
         * @param {VariableValueDto} [variableValueDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTaskLocalVariable: async (id: string, varName: string, variableValueDto?: VariableValueDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putTaskLocalVariable', 'id', id)
            // verify required parameter 'varName' is not null or undefined
            assertParamExists('putTaskLocalVariable', 'varName', varName)
            const localVarPath = `/task/{id}/localVariables/{varName}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableValueDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the serialized value for a binary variable or the binary value for a file variable.
         * @param {string} id The id of the task to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {any} [data] The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory.
         * @param {string} [valueType] The name of the variable type. Either Bytes for a byte array variable or File for a file variable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBinaryTaskLocalVariable: async (id: string, varName: string, data?: any, valueType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setBinaryTaskLocalVariable', 'id', id)
            // verify required parameter 'varName' is not null or undefined
            assertParamExists('setBinaryTaskLocalVariable', 'varName', varName)
            const localVarPath = `/task/{id}/localVariables/{varName}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (data !== undefined) { 
                localVarFormParams.append('data', data as any);
            }
    
            if (valueType !== undefined) { 
                localVarFormParams.append('valueType', valueType as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskLocalVariableApi - functional programming interface
 * @export
 */
export const TaskLocalVariableApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaskLocalVariableApiAxiosParamCreator(configuration)
    return {
        /**
         * Removes a local variable from a task by id.
         * @param {string} id The id of the task to delete the variable from.
         * @param {string} varName The name of the variable to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTaskLocalVariable(id: string, varName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTaskLocalVariable(id, varName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a variable from the context of a given task by id.
         * @param {string} id The id of the task to retrieve the variable from.
         * @param {string} varName The name of the variable to get
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskLocalVariable(id: string, varName: string, deserializeValue?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableValueDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskLocalVariable(id, varName, deserializeValue, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a binary variable from the context of a given task by id. Applicable for byte array and file variables.
         * @param {string} id The id of the task to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskLocalVariableBinary(id: string, varName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskLocalVariableBinary(id, varName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves all variables of a given task by id.
         * @param {string} id The id of the task to retrieve the variables from.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskLocalVariables(id: string, deserializeValues?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: VariableValueDto; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskLocalVariables(id, deserializeValues, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates or deletes the variables in the context of a task. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
         * @param {string} id The id of the task to set variables for.
         * @param {PatchVariablesDto} [patchVariablesDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyTaskLocalVariables(id: string, patchVariablesDto?: PatchVariablesDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyTaskLocalVariables(id, patchVariablesDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets a variable in the context of a given task.
         * @param {string} id The id of the task to set the variable for.
         * @param {string} varName The name of the variable to set.
         * @param {VariableValueDto} [variableValueDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putTaskLocalVariable(id: string, varName: string, variableValueDto?: VariableValueDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putTaskLocalVariable(id, varName, variableValueDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets the serialized value for a binary variable or the binary value for a file variable.
         * @param {string} id The id of the task to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {any} [data] The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory.
         * @param {string} [valueType] The name of the variable type. Either Bytes for a byte array variable or File for a file variable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setBinaryTaskLocalVariable(id: string, varName: string, data?: any, valueType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setBinaryTaskLocalVariable(id, varName, data, valueType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TaskLocalVariableApi - factory interface
 * @export
 */
export const TaskLocalVariableApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaskLocalVariableApiFp(configuration)
    return {
        /**
         * Removes a local variable from a task by id.
         * @param {string} id The id of the task to delete the variable from.
         * @param {string} varName The name of the variable to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaskLocalVariable(id: string, varName: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTaskLocalVariable(id, varName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a variable from the context of a given task by id.
         * @param {string} id The id of the task to retrieve the variable from.
         * @param {string} varName The name of the variable to get
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskLocalVariable(id: string, varName: string, deserializeValue?: boolean, options?: any): AxiosPromise<VariableValueDto> {
            return localVarFp.getTaskLocalVariable(id, varName, deserializeValue, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a binary variable from the context of a given task by id. Applicable for byte array and file variables.
         * @param {string} id The id of the task to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskLocalVariableBinary(id: string, varName: string, options?: any): AxiosPromise<any> {
            return localVarFp.getTaskLocalVariableBinary(id, varName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all variables of a given task by id.
         * @param {string} id The id of the task to retrieve the variables from.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskLocalVariables(id: string, deserializeValues?: boolean, options?: any): AxiosPromise<{ [key: string]: VariableValueDto; }> {
            return localVarFp.getTaskLocalVariables(id, deserializeValues, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates or deletes the variables in the context of a task. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
         * @param {string} id The id of the task to set variables for.
         * @param {PatchVariablesDto} [patchVariablesDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyTaskLocalVariables(id: string, patchVariablesDto?: PatchVariablesDto, options?: any): AxiosPromise<void> {
            return localVarFp.modifyTaskLocalVariables(id, patchVariablesDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets a variable in the context of a given task.
         * @param {string} id The id of the task to set the variable for.
         * @param {string} varName The name of the variable to set.
         * @param {VariableValueDto} [variableValueDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTaskLocalVariable(id: string, varName: string, variableValueDto?: VariableValueDto, options?: any): AxiosPromise<void> {
            return localVarFp.putTaskLocalVariable(id, varName, variableValueDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the serialized value for a binary variable or the binary value for a file variable.
         * @param {string} id The id of the task to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {any} [data] The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory.
         * @param {string} [valueType] The name of the variable type. Either Bytes for a byte array variable or File for a file variable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBinaryTaskLocalVariable(id: string, varName: string, data?: any, valueType?: string, options?: any): AxiosPromise<void> {
            return localVarFp.setBinaryTaskLocalVariable(id, varName, data, valueType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TaskLocalVariableApi - object-oriented interface
 * @export
 * @class TaskLocalVariableApi
 * @extends {BaseAPI}
 */
export class TaskLocalVariableApi extends BaseAPI {
    /**
     * Removes a local variable from a task by id.
     * @param {string} id The id of the task to delete the variable from.
     * @param {string} varName The name of the variable to be removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskLocalVariableApi
     */
    public deleteTaskLocalVariable(id: string, varName: string, options?: AxiosRequestConfig) {
        return TaskLocalVariableApiFp(this.configuration).deleteTaskLocalVariable(id, varName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a variable from the context of a given task by id.
     * @param {string} id The id of the task to retrieve the variable from.
     * @param {string} varName The name of the variable to get
     * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskLocalVariableApi
     */
    public getTaskLocalVariable(id: string, varName: string, deserializeValue?: boolean, options?: AxiosRequestConfig) {
        return TaskLocalVariableApiFp(this.configuration).getTaskLocalVariable(id, varName, deserializeValue, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a binary variable from the context of a given task by id. Applicable for byte array and file variables.
     * @param {string} id The id of the task to retrieve the variable for.
     * @param {string} varName The name of the variable to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskLocalVariableApi
     */
    public getTaskLocalVariableBinary(id: string, varName: string, options?: AxiosRequestConfig) {
        return TaskLocalVariableApiFp(this.configuration).getTaskLocalVariableBinary(id, varName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all variables of a given task by id.
     * @param {string} id The id of the task to retrieve the variables from.
     * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskLocalVariableApi
     */
    public getTaskLocalVariables(id: string, deserializeValues?: boolean, options?: AxiosRequestConfig) {
        return TaskLocalVariableApiFp(this.configuration).getTaskLocalVariables(id, deserializeValues, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates or deletes the variables in the context of a task. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
     * @param {string} id The id of the task to set variables for.
     * @param {PatchVariablesDto} [patchVariablesDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskLocalVariableApi
     */
    public modifyTaskLocalVariables(id: string, patchVariablesDto?: PatchVariablesDto, options?: AxiosRequestConfig) {
        return TaskLocalVariableApiFp(this.configuration).modifyTaskLocalVariables(id, patchVariablesDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets a variable in the context of a given task.
     * @param {string} id The id of the task to set the variable for.
     * @param {string} varName The name of the variable to set.
     * @param {VariableValueDto} [variableValueDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskLocalVariableApi
     */
    public putTaskLocalVariable(id: string, varName: string, variableValueDto?: VariableValueDto, options?: AxiosRequestConfig) {
        return TaskLocalVariableApiFp(this.configuration).putTaskLocalVariable(id, varName, variableValueDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets the serialized value for a binary variable or the binary value for a file variable.
     * @param {string} id The id of the task to retrieve the variable for.
     * @param {string} varName The name of the variable to retrieve.
     * @param {any} [data] The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory.
     * @param {string} [valueType] The name of the variable type. Either Bytes for a byte array variable or File for a file variable.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskLocalVariableApi
     */
    public setBinaryTaskLocalVariable(id: string, varName: string, data?: any, valueType?: string, options?: AxiosRequestConfig) {
        return TaskLocalVariableApiFp(this.configuration).setBinaryTaskLocalVariable(id, varName, data, valueType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TaskVariableApi - axios parameter creator
 * @export
 */
export const TaskVariableApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Removes a variable that is visible to a task. A variable is visible to a task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to delete the variable from.
         * @param {string} varName The name of the variable to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaskVariable: async (id: string, varName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTaskVariable', 'id', id)
            // verify required parameter 'varName' is not null or undefined
            assertParamExists('deleteTaskVariable', 'varName', varName)
            const localVarPath = `/task/{id}/variables/{varName}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a variable from the context of a given task. The variable must be visible from the task. It is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to retrieve the variable from.
         * @param {string} varName The name of the variable to get.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskVariable: async (id: string, varName: string, deserializeValue?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTaskVariable', 'id', id)
            // verify required parameter 'varName' is not null or undefined
            assertParamExists('getTaskVariable', 'varName', varName)
            const localVarPath = `/task/{id}/variables/{varName}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (deserializeValue !== undefined) {
                localVarQueryParameter['deserializeValue'] = deserializeValue;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a binary variable from the context of a given task. Applicable for byte array and file variables. The variable must be visible from the task. It is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskVariableBinary: async (id: string, varName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTaskVariableBinary', 'id', id)
            // verify required parameter 'varName' is not null or undefined
            assertParamExists('getTaskVariableBinary', 'varName', varName)
            const localVarPath = `/task/{id}/variables/{varName}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all variables visible from the task. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to retrieve the variables from.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;). If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskVariables: async (id: string, deserializeValue?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTaskVariables', 'id', id)
            const localVarPath = `/task/{id}/variables`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (deserializeValue !== undefined) {
                localVarQueryParameter['deserializeValue'] = deserializeValue;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates or deletes the variables visible from the task. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to set variables for.
         * @param {PatchVariablesDto} [patchVariablesDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyTaskVariables: async (id: string, patchVariablesDto?: PatchVariablesDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('modifyTaskVariables', 'id', id)
            const localVarPath = `/task/{id}/variables`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchVariablesDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a process variable that is visible from the Task scope. A variable is visible from the task if it is a local task variable, or declared in a parent scope of the task. See the documentation on [variable scopes and visibility](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables#variable-scopes-and-variable-visibility).  **Note**: If a variable doesn\'t exist, the variable is created in the top-most scope visible from the task.
         * @param {string} id The id of the task to set the variable for.
         * @param {string} varName The name of the variable to set.
         * @param {VariableValueDto} [variableValueDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTaskVariable: async (id: string, varName: string, variableValueDto?: VariableValueDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putTaskVariable', 'id', id)
            // verify required parameter 'varName' is not null or undefined
            assertParamExists('putTaskVariable', 'varName', varName)
            const localVarPath = `/task/{id}/variables/{varName}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableValueDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the serialized value for a binary variable or the binary value for a file variable visible from the task. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {any} [data] The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory.
         * @param {string} [valueType] The name of the variable type. Either Bytes for a byte array variable or File for a file variable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBinaryTaskVariable: async (id: string, varName: string, data?: any, valueType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setBinaryTaskVariable', 'id', id)
            // verify required parameter 'varName' is not null or undefined
            assertParamExists('setBinaryTaskVariable', 'varName', varName)
            const localVarPath = `/task/{id}/variables/{varName}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (data !== undefined) { 
                localVarFormParams.append('data', data as any);
            }
    
            if (valueType !== undefined) { 
                localVarFormParams.append('valueType', valueType as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskVariableApi - functional programming interface
 * @export
 */
export const TaskVariableApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaskVariableApiAxiosParamCreator(configuration)
    return {
        /**
         * Removes a variable that is visible to a task. A variable is visible to a task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to delete the variable from.
         * @param {string} varName The name of the variable to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTaskVariable(id: string, varName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTaskVariable(id, varName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a variable from the context of a given task. The variable must be visible from the task. It is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to retrieve the variable from.
         * @param {string} varName The name of the variable to get.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskVariable(id: string, varName: string, deserializeValue?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableValueDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskVariable(id, varName, deserializeValue, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a binary variable from the context of a given task. Applicable for byte array and file variables. The variable must be visible from the task. It is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskVariableBinary(id: string, varName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskVariableBinary(id, varName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves all variables visible from the task. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to retrieve the variables from.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;). If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskVariables(id: string, deserializeValue?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: VariableValueDto; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskVariables(id, deserializeValue, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates or deletes the variables visible from the task. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to set variables for.
         * @param {PatchVariablesDto} [patchVariablesDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyTaskVariables(id: string, patchVariablesDto?: PatchVariablesDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyTaskVariables(id, patchVariablesDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a process variable that is visible from the Task scope. A variable is visible from the task if it is a local task variable, or declared in a parent scope of the task. See the documentation on [variable scopes and visibility](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables#variable-scopes-and-variable-visibility).  **Note**: If a variable doesn\'t exist, the variable is created in the top-most scope visible from the task.
         * @param {string} id The id of the task to set the variable for.
         * @param {string} varName The name of the variable to set.
         * @param {VariableValueDto} [variableValueDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putTaskVariable(id: string, varName: string, variableValueDto?: VariableValueDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putTaskVariable(id, varName, variableValueDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets the serialized value for a binary variable or the binary value for a file variable visible from the task. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {any} [data] The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory.
         * @param {string} [valueType] The name of the variable type. Either Bytes for a byte array variable or File for a file variable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setBinaryTaskVariable(id: string, varName: string, data?: any, valueType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setBinaryTaskVariable(id, varName, data, valueType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TaskVariableApi - factory interface
 * @export
 */
export const TaskVariableApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaskVariableApiFp(configuration)
    return {
        /**
         * Removes a variable that is visible to a task. A variable is visible to a task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to delete the variable from.
         * @param {string} varName The name of the variable to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaskVariable(id: string, varName: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTaskVariable(id, varName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a variable from the context of a given task. The variable must be visible from the task. It is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to retrieve the variable from.
         * @param {string} varName The name of the variable to get.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskVariable(id: string, varName: string, deserializeValue?: boolean, options?: any): AxiosPromise<VariableValueDto> {
            return localVarFp.getTaskVariable(id, varName, deserializeValue, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a binary variable from the context of a given task. Applicable for byte array and file variables. The variable must be visible from the task. It is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskVariableBinary(id: string, varName: string, options?: any): AxiosPromise<any> {
            return localVarFp.getTaskVariableBinary(id, varName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all variables visible from the task. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to retrieve the variables from.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;). If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskVariables(id: string, deserializeValue?: boolean, options?: any): AxiosPromise<{ [key: string]: VariableValueDto; }> {
            return localVarFp.getTaskVariables(id, deserializeValue, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates or deletes the variables visible from the task. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to set variables for.
         * @param {PatchVariablesDto} [patchVariablesDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyTaskVariables(id: string, patchVariablesDto?: PatchVariablesDto, options?: any): AxiosPromise<void> {
            return localVarFp.modifyTaskVariables(id, patchVariablesDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a process variable that is visible from the Task scope. A variable is visible from the task if it is a local task variable, or declared in a parent scope of the task. See the documentation on [variable scopes and visibility](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables#variable-scopes-and-variable-visibility).  **Note**: If a variable doesn\'t exist, the variable is created in the top-most scope visible from the task.
         * @param {string} id The id of the task to set the variable for.
         * @param {string} varName The name of the variable to set.
         * @param {VariableValueDto} [variableValueDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTaskVariable(id: string, varName: string, variableValueDto?: VariableValueDto, options?: any): AxiosPromise<void> {
            return localVarFp.putTaskVariable(id, varName, variableValueDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the serialized value for a binary variable or the binary value for a file variable visible from the task. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {any} [data] The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory.
         * @param {string} [valueType] The name of the variable type. Either Bytes for a byte array variable or File for a file variable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBinaryTaskVariable(id: string, varName: string, data?: any, valueType?: string, options?: any): AxiosPromise<void> {
            return localVarFp.setBinaryTaskVariable(id, varName, data, valueType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TaskVariableApi - object-oriented interface
 * @export
 * @class TaskVariableApi
 * @extends {BaseAPI}
 */
export class TaskVariableApi extends BaseAPI {
    /**
     * Removes a variable that is visible to a task. A variable is visible to a task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
     * @param {string} id The id of the task to delete the variable from.
     * @param {string} varName The name of the variable to be removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskVariableApi
     */
    public deleteTaskVariable(id: string, varName: string, options?: AxiosRequestConfig) {
        return TaskVariableApiFp(this.configuration).deleteTaskVariable(id, varName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a variable from the context of a given task. The variable must be visible from the task. It is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
     * @param {string} id The id of the task to retrieve the variable from.
     * @param {string} varName The name of the variable to get.
     * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskVariableApi
     */
    public getTaskVariable(id: string, varName: string, deserializeValue?: boolean, options?: AxiosRequestConfig) {
        return TaskVariableApiFp(this.configuration).getTaskVariable(id, varName, deserializeValue, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a binary variable from the context of a given task. Applicable for byte array and file variables. The variable must be visible from the task. It is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
     * @param {string} id The id of the task to retrieve the variable for.
     * @param {string} varName The name of the variable to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskVariableApi
     */
    public getTaskVariableBinary(id: string, varName: string, options?: AxiosRequestConfig) {
        return TaskVariableApiFp(this.configuration).getTaskVariableBinary(id, varName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all variables visible from the task. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
     * @param {string} id The id of the task to retrieve the variables from.
     * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;). If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson\&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API\&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskVariableApi
     */
    public getTaskVariables(id: string, deserializeValue?: boolean, options?: AxiosRequestConfig) {
        return TaskVariableApiFp(this.configuration).getTaskVariables(id, deserializeValue, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates or deletes the variables visible from the task. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
     * @param {string} id The id of the task to set variables for.
     * @param {PatchVariablesDto} [patchVariablesDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskVariableApi
     */
    public modifyTaskVariables(id: string, patchVariablesDto?: PatchVariablesDto, options?: AxiosRequestConfig) {
        return TaskVariableApiFp(this.configuration).modifyTaskVariables(id, patchVariablesDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a process variable that is visible from the Task scope. A variable is visible from the task if it is a local task variable, or declared in a parent scope of the task. See the documentation on [variable scopes and visibility](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables#variable-scopes-and-variable-visibility).  **Note**: If a variable doesn\'t exist, the variable is created in the top-most scope visible from the task.
     * @param {string} id The id of the task to set the variable for.
     * @param {string} varName The name of the variable to set.
     * @param {VariableValueDto} [variableValueDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskVariableApi
     */
    public putTaskVariable(id: string, varName: string, variableValueDto?: VariableValueDto, options?: AxiosRequestConfig) {
        return TaskVariableApiFp(this.configuration).putTaskVariable(id, varName, variableValueDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets the serialized value for a binary variable or the binary value for a file variable visible from the task. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
     * @param {string} id The id of the task to retrieve the variable for.
     * @param {string} varName The name of the variable to retrieve.
     * @param {any} [data] The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory.
     * @param {string} [valueType] The name of the variable type. Either Bytes for a byte array variable or File for a file variable.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskVariableApi
     */
    public setBinaryTaskVariable(id: string, varName: string, data?: any, valueType?: string, options?: AxiosRequestConfig) {
        return TaskVariableApiFp(this.configuration).setBinaryTaskVariable(id, varName, data, valueType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VersionApi - axios parameter creator
 * @export
 */
export const VersionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the version of the Rest API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRestAPIVersion: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VersionApi - functional programming interface
 * @export
 */
export const VersionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VersionApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the version of the Rest API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRestAPIVersion(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRestAPIVersion(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VersionApi - factory interface
 * @export
 */
export const VersionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VersionApiFp(configuration)
    return {
        /**
         * Retrieves the version of the Rest API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRestAPIVersion(options?: any): AxiosPromise<VersionDto> {
            return localVarFp.getRestAPIVersion(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VersionApi - object-oriented interface
 * @export
 * @class VersionApi
 * @extends {BaseAPI}
 */
export class VersionApi extends BaseAPI {
    /**
     * Retrieves the version of the Rest API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionApi
     */
    public getRestAPIVersion(options?: AxiosRequestConfig) {
        return VersionApiFp(this.configuration).getRestAPIVersion(options).then((request) => request(this.axios, this.basePath));
    }
}


